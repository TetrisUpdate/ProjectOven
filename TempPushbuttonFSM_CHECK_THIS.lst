0000              1   ;----------------------------------------------------------------------
0000              2   ; 76E003 ADC test program (reflow oven controller + push buttons)
0000              3   ; Reads channel 7 on P1.1, pin 14
0000              4   ; This version uses the LM4040 voltage reference connected to pin 6 (P1.7/AIN0)
0000              5   ; Incorporates push-button control to set up times/temperatures and start FSM.
0000              6   ;----------------------------------------------------------------------
0000              7   
                  9   $LIST
0000             11   
0000             12   ;  N76E003 pinout:
0000             13   ;                               -------
0000             14   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             15   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             16   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             17   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             18   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             19   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             20   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             21   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             22   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             23   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             24   ;                               -------
0000             25   ;
0000             26   
0000             27   ;----------------------------------------------------------------------
0000             28   ; System/Timer/Constants
0000             29   ;----------------------------------------------------------------------
0000             30   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             31   BAUD              EQU 115200   ; Baud rate of UART in bps
0000             32   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             33   
0000             34   TIMER2_RATE       EQU 100      ; 100 Hz -> 10ms tick
0000             35   TIMER2_RELOAD     EQU ((65536-(CLK/TIMER2_RATE)))
0000             36   
0000             37   SAMPLES_PER_DISPLAY  EQU 300
0000             38   REFRESHES_PER_SECOND EQU 45
0000             39   TIMER0_DENOM         EQU (SAMPLES_PER_DISPLAY*REFRESHES_PER_SECOND)
0000             40   TIMER0_RELOAD        EQU (0x10000-(CLK/TIMER0_DENOM))
0000             41   
0000             42   ORG 0x0000
0000 020674      43       ljmp main
0003             44   
002B             45   org 0x002B
002B 020385      46       ljmp Timer2_ISR
002E             47   
002E             48   ;----------------------------------------------------------------------
002E             49   ; Hardware Pin Definitions
002E             50   ;----------------------------------------------------------------------
002E             51   
002E             52   ; PUSH BUTTONS (single-pin read approach)
002E             53   PB_INPUT_PIN   EQU P1.5  ; The single pin used to read all 5 PBs
002E             54   MUX_CONTROL_0  EQU P0.0  
002E             55   MUX_CONTROL_1  EQU P0.1  
002E             56   MUX_CONTROL_2  EQU P0.2  
002E             57   MUX_CONTROL_3  EQU P0.3  
002E             58   MUX_CONTROL_4  EQU P1.3  
002E             59   
002E             60   ; LCD assignments
002E             61   LCD_RS  equ P1.3
002E             62   LCD_E   equ P1.4
002E             63   LCD_D4  equ P0.0
002E             64   LCD_D5  equ P0.1
002E             65   LCD_D6  equ P0.2
002E             66   LCD_D7  equ P0.3
002E             67   SSR_BOX equ P0.4
002E             68   
002E             69   ; Strings for LCD
002E 43757272    70   test_message:     db 'Current Temp.:', 0
     656E7420
     54656D70
     2E3A00
003D 4465672E    71   value_message:    db 'Deg. C', 0
     204300
0044             72   
0044             73   cseg
0044             74   
                 76   	$LIST
00F8             78   
00F8             79   ;----------------------------------------------------------------------
00F8             80   ; 32-bit math placeholders
00F8             81   ;----------------------------------------------------------------------
0030             82   DSEG at 30H
0030             83   x:   ds 4
0034             84   y:   ds 4
0038             85   bcd: ds 5
003D             86   VAL_LM4040: ds 2
003F             87   
003F             88   ; Variables
003F             89   state:              ds 1
0040             90   StoreMeasurements:  ds 4
0044             91   TempStore:          ds 2
0046             92   MeasurementCounter: ds 2
0048             93   SamplesPerDisplay:  ds 2
004A             94   TimePerSample:      ds 1
004B             95   LastMeasurement:    ds 4
004F             96   StoreThermocouple:  ds 4
0053             97   CurrentTemp:        ds 4
0057             98   FinalLM335:         ds 4
005B             99   FinalTemp:          ds 4
005F            100   selected_state:          ds 1
0060            101   
0060            102   Count1ms:      ds 2
0062            103   pwm_counter:   ds 1
0063            104   pwm:           ds 1
0064            105   
0064            106   ; Oven settings
0064            107   temp_soak: ds 1  ; For state 1
0065            108   time_soak: ds 1  ; For state 2
0066            109   temp_refl: ds 1  ; For state 3
0067            110   time_refl: ds 1  ; For state 4
0068            111   
0068            112   seconds: ds 1
0069            113   
0069            114   ;----------------------------------------------------------------------
0069            115   ; Bit variables (BSEG)
0069            116   ;----------------------------------------------------------------------
0000            117   BSEG
0000            118   mf:            dbit 1
0001            119   m_flag:        dbit 1
0002            120   err_tmp:       dbit 1
0003            121   err_tmp_150:   dbit 1
0004            122   
0004            123   start:         dbit 1  ; Start the FSM
0005            124   temp_state1:   dbit 1
0006            125   time_state2:   dbit 1
0007            126   temp_state3:   dbit 1
0008            127   time_state4:   dbit 1
0009            128   temp_state5:   dbit 1
000A            129   
000A            130   ; For push buttons
000A            131   PB0: dbit 1  ; Start/Pause
000B            132   PB1: dbit 1  ; Toggle selected parameter
000C            133   PB2: dbit 1  ; Increment
000D            134   PB3: dbit 1  ; Decrement
000E            135   PB4: dbit 1  ; Unused or extra
000F            136   
000F            137   ;SETATS
000F            138   
000F            139   ; We include math32 at the end of initialization
                546   $LIST
                141   $LIST
0368            143   
0368            144   ;----------------------------------------------------------------------
0368            145   ; Timer2 Initialization & ISR
0368            146   ;----------------------------------------------------------------------
0368            147   Timer2_Init:
0368 75C800     148       mov T2CON, #0       ; Stop timer, mode = auto-reload
036B 75CD78     149       mov TH2, #high(TIMER2_RELOAD)
036E 75CC90     150       mov TL2, #low(TIMER2_RELOAD)
0371 43C980     151       orl T2MOD, #0x80    ; Enable auto-reload
0374 75CB78     152       mov RCMP2H, #high(TIMER2_RELOAD)
0377 75CA90     153       mov RCMP2L, #low(TIMER2_RELOAD)
037A E4         154       clr  a
037B F560       155       mov  Count1ms+0, a
037D F561       156       mov  Count1ms+1, a
037F 439B80     157       orl  EIE, #0x80     ; Enable timer2 interrupt (ET2=1)
0382 D2CA       158       setb TR2            ; Start Timer2
0384 22         159       ret
0385            160   
0385            161   Timer2_ISR:
0385 C2CF       162       clr TF2 ; Must clear TF2 manually on N76
0387 C0E0       163       push acc
0389 C0D0       164       push psw
038B            165   
038B            166       ;---------------------------------
038B            167       ; 1ms counter
038B            168       ;---------------------------------
038B 0560       169       inc Count1ms+0
038D E560       170       mov a, Count1ms+0
038F 7028       171       jnz Inc_Done
0391 0561       172       inc Count1ms+1
0393            173   
0393            174       ;---------------------------------
0393            175       ; PWM for SSR control
0393            176       ;---------------------------------
0393 0562       177       inc pwm_counter
0395 C3         178       clr c
0396 E563       179       mov a, pwm
0398 9562       180       subb a, pwm_counter ; if pwm_counter <= pwm, c=1
039A B3         181       cpl c
039B 9284       182       mov SSR_BOX, c
039D            183   
039D E562       184       mov a, pwm_counter
039F B46410     185       cjne a, #100, jumpy1
03A2 756200     186       mov pwm_counter, #0
03A5 0568       187       inc seconds
03A7 E4         188       clr a
03A8 E568       189       mov a, seconds
03AA B46008     190       cjne a, #0x60, oneMin
03AD D201       191       setb m_flag
03AF 0203B9     192       ljmp Inc_Done
03B2            193   
03B2            194   jumpy1:
03B2 02047B     195       ljmp Timer2_ISR_done
03B5            196   
03B5            197   oneMin:
03B5            198       ; If you also need a second-flag for main, do so here:
03B5            199       ; setb s_flag
03B5 E4         200       clr a
03B6 0203B9     201       ljmp Inc_Done
03B9            202   
03B9            203   Inc_Done:
03B9            204       ;---------------------------------
03B9            205       ; Example: Half-second tasks
03B9            206       ;---------------------------------
03B9 E560       207       mov a, Count1ms+0
03BB B4E805     208       cjne a, #low(1000), State_0 ; Not needed, the PWM stuff keeps track of seconds, also this is wrong since we have a 10ms interval between timer interrupts now, not 1ms
03BE E561       209       mov a, Count1ms+1
03C0 B40300     210       cjne a, #high(1000), State_0
03C3            211       ; If both match, ~1 second has passed
03C3            212       ; setb half_seconds_flag
03C3            213       ; add any code here if needed
03C3            214   
03C3            215   State_0:
03C3 E53F       216       mov a, state
03C5 B4000D     217            cjne a, #0, State_1
03C8 E4         218       clr a
03C9 756300     219            mov pwm, #0
03CC 200457     220            jb start, jumpy ; This needs to be moved to before cjne, since otherwise we never go to state 1
03CF 753F01     221            mov state, #1
03D2 02047B     222            ljmp Timer2_ISR_done
03D5            223            
03D5            224   State_1:
03D5 E53F       225            mov a, state
03D7 B4012E     226            cjne a, #1, State_2
03DA 756364     227            mov pwm, #100                                   ; set pwm for relfow oven to 100%
03DD 200113     228            jb m_flag, Cond_check
03E0 A205       229            mov c, temp_state1
03E2 E4         230            clr a                                                   ; clear the accumulator
03E3 92E0       231            mov acc.0, c
03E5 C3         232            clr c                                                   ; clear the carry bit
03E6 B4003D     233            cjne a, #0, jumpy       ; mf = 1 if oven temp <= set temp, jump out of ISR. mf = 0 if oven temp > set temp, thus move onto next state                   
03E9 E4         234            clr a                                           
03EA 756800     235            mov seconds, #0
03ED 753F02     236            mov state, #2
03F0 020408     237            ljmp State_2
03F3            238   
03F3            239   Cond_check: ; cjne is not bit-addressable, therefore we must move bits into byte registers (i.e. accumulator and register b)
03F3 A202       240            mov c, err_tmp
03F5 E4         241            clr a 
03F6 92E0       242            mov acc.0, c ; mov value in carry to the lowest bit of the accumulator
03F8 A201       243            mov c, m_flag
03FA C201       244            clr m_flag ; clear minute flag
03FC 75F000     245            mov b, #00h 
03FF 92F0       246            mov b.0, c ; mov value in carry to the lowest bit of the B regrister
0401 C3         247            clr c
0402 B5F072     248            cjne a, b, State_error
0405 0203D5     249            ljmp State_1
0408            250   
0408            251   State_2: ;transition to state three if more than 60 seconds have passed
0408 E53F       252            mov a, state
040A B4021C     253            cjne a, #2, State_3
040D 756314     254            mov pwm, #20
0410 300364     255            jnb err_tmp_150, State_error
0413 A206       256            mov c, time_state2
0415 E4         257            clr a                                                   ; clear the accumulator
0416 92E0       258            mov acc.0, c
0418 C3         259            clr c                                                   ; clear the carry bit
0419 B5680A     260            cjne a, seconds, jumpy
041C E4         261            clr a
041D 756800     262            mov seconds, #0                         
0420 753F03     263            mov state, #3
0423 020429     264       ljmp State_3
0426            265   
0426            266   jumpy:
0426 02047B     267       ljmp Timer2_ISR_done
0429            268   
0429            269   State_3: 
0429 E53F       270            mov a, state
042B B40316     271            cjne a, #3, State_4 ; check if state = 3, if not, move to state_4
042E 756364     272            mov pwm, #100 ; set pwm to 100%
0431 300343     273            jnb err_tmp_150, State_error
0434 A207       274            mov c, temp_state3
0436 E4         275            clr a                                                   ; clear the accumulator
0437 92E0       276            mov acc.0, c
0439 C3         277            clr c                                                   ; clear the carry bit
043A B4003E     278            cjne a, #0, Timer2_ISR_done ; 
043D E4         279            clr a
043E 756800     280            mov seconds, #0
0441 753F04     281            mov state, #4
0444            282   
0444            283   State_4:
0444 E53F       284            mov a, state
0446 B40416     285            cjne a, #4, State_5
0449 756314     286            mov pwm, #20
044C 300328     287            jnb err_tmp_150, State_error
044F A208       288            mov c, time_state4
0451 E4         289            clr a                                                   ; clear the accumulator
0452 92E0       290            mov acc.0, c
0454 C3         291            clr c                                                   ; clear the carry bit
0455 B56823     292            cjne a, seconds, Timer2_ISR_done
0458 E4         293            clr a
0459 756800     294            mov seconds, #0
045C 753F05     295            mov state, #5
045F            296   
045F            297   State_5:
045F E53F       298            mov a, state
0461 B40517     299            cjne a, #5, Timer2_ISR_done
0464 756300     300            mov pwm, #0
0467 A209       301            mov c, temp_state5
0469 E4         302            clr a                                                   ; clear the accumulator
046A 92E0       303            mov acc.0, c
046C C3         304            clr c                                                   ; clear the carry bit
046D B4010B     305            cjne a, #1, Timer2_ISR_done
0470 E4         306            clr a
0471 756800     307            mov seconds, #0
0474 753F00     308            mov state, #0
0477            309   
0477            310   State_error:
0477 E53F       311            mov a, state
0479 7400       312            mov a, #0
047B            313            ; probably should put branch for warning message here
047B            314   
047B            315   Timer2_ISR_done:
047B D0D0       316       pop psw
047D D0E0       317       pop acc
047F 32         318       reti
0480            319   
0480            320   ;----------------------------------------------------------------------
0480            321   ; Initialization
0480            322   ;----------------------------------------------------------------------
0480            323   Init_All:
0480            324       ; Configure all the pins for bidirectional I/O
0480 75AC00     325       mov P3M1, #0x00
0483 75AD00     326       mov P3M2, #0x00
0486 75B300     327       mov P1M1, #0x00
0489 75B400     328       mov P1M2, #0x00
048C 75B100     329       mov P0M1, #0x00
048F 75B200     330       mov P0M2, #0x00
0492            331   
0492 120368     332       lcall Timer2_Init
0495            333   
0495            334       ; Timer1 for UART
0495 438E10     335       orl  CKCON, #0x10     ; Timer1 uses system clock
0498 438780     336       orl  PCON,  #0x80     ; SMOD=1 -> double baud
049B 759852     337       mov  SCON,  #0x52     ; UART mode 1, REN=1
049E 53C4DF     338       anl  T3CON, #0b11011111
04A1 53890F     339       anl  TMOD,  #0x0F
04A4 438920     340       orl  TMOD,  #0x20     ; Timer1 Mode2 (8-bit auto-reload)
04A7 758DF7     341       mov  TH1, #TIMER1_RELOAD
04AA D28E       342       setb TR1
04AC            343   
04AC            344       ; Timer0 for waitms
04AC C28C       345       clr TR0
04AE 438E08     346       orl CKCON, #0x08
04B1 5389F0     347       anl TMOD,  #0xF0
04B4 438901     348       orl TMOD,  #0x01      ; 16-bit mode
04B7            349       ; ADC pins: P1.1 (AIN7), P1.7 (AIN0)
04B7 43B382     350       orl P1M1, #0b10000010 ; Set P1.1 & P1.7 as input
04BA 53B47D     351       anl P1M2, #0b01111101
04BD            352   
04BD            353       ; Initialize ADC
04BD 53E8F0     354       anl ADCCON0, #0xF0
04C0 43E807     355       orl ADCCON0, #0x07    ; default to channel 7
04C3 75F600     356       mov AINDIDS, #0x00    ; disable all digital inputs
04C6 43F681     357       orl AINDIDS, #0b10000001 ; activate AIN0 and AIN7
04C9 43E101     358       orl ADCCON1, #0x01    ; enable ADC
04CC 22         359       ret
04CD            360   
04CD            361   ;----------------------------------------------------------------------
04CD            362   ; Delay Routines
04CD            363   ;----------------------------------------------------------------------
04CD            364   wait_1ms:
04CD C28C       365       clr TR0
04CF C28D       366       clr TF0
04D1 758CFB     367       mov TH0, #high(TIMER0_RELOAD)
04D4 758A33     368       mov TL0, #low(TIMER0_RELOAD)
04D7 D28C       369       setb TR0
04D9 308DFD     370       jnb TF0, $
04DC 22         371       ret
04DD            372   
04DD            373   ; Wait R2 milliseconds
04DD            374   waitms:
04DD 1204CD     375       lcall wait_1ms
04E0 DAFB       376       djnz R2, waitms
04E2 22         377       ret
04E3            378   
04E3            379   ;----------------------------------------------------------------------
04E3            380   ; LCD_PB: Read the 5 push buttons into PB0..PB4 bits
04E3            381   ;----------------------------------------------------------------------
04E3            382   LCD_PB:
04E3            383       ; Default all PB bits to 1 (released)
04E3 D20A       384       setb PB0 
04E5 D20B       385       setb PB1
04E7 D20C       386       setb PB2
04E9 D20D       387       setb PB3
04EB D20E       388       setb PB4
04ED            389       ; The input pin is idle-high (pull-up)
04ED D295       390       setb PB_INPUT_PIN
04EF            391   
04EF            392       ; Set MUX lines to 0 first
04EF C280       393       clr MUX_CONTROL_0
04F1 C281       394       clr MUX_CONTROL_1
04F3 C282       395       clr MUX_CONTROL_2
04F5 C283       396       clr MUX_CONTROL_3
04F7 C293       397       clr MUX_CONTROL_4
04F9            398   
04F9            399       ;---------------------------------
04F9            400       ; Debouncing
04F9            401       ;---------------------------------
04F9 20953A     402       jb  PB_INPUT_PIN, LCD_PB_Done 
04FC 7A32       403       mov R2, #50
04FE 1204DD     404       lcall waitms
0501            405       
0501 209532     406       jb  PB_INPUT_PIN, LCD_PB_Done
0504            407   
0504            408       ; Now set all MUX lines = 1 to read them individually
0504 D280       409       setb MUX_CONTROL_0
0506 D281       410       setb MUX_CONTROL_1
0508 D282       411       setb MUX_CONTROL_2
050A D283       412       setb MUX_CONTROL_3
050C D293       413       setb MUX_CONTROL_4
050E            414   
050E            415       ; Check PB4
050E C293       416       clr MUX_CONTROL_4
0510 A295       417       mov c, PB_INPUT_PIN
0512 920E       418       mov PB4, c
0514 D293       419       setb MUX_CONTROL_4
0516            420   
0516            421       ; Check PB3
0516 C283       422       clr MUX_CONTROL_3
0518 A295       423       mov c, PB_INPUT_PIN
051A 920D       424       mov PB3, c
051C D283       425       setb MUX_CONTROL_3
051E            426   
051E            427       ; Check PB2
051E C282       428       clr MUX_CONTROL_2
0520 A295       429       mov c, PB_INPUT_PIN
0522 920C       430       mov PB2, c
0524 D282       431       setb MUX_CONTROL_2
0526            432   
0526            433       ; Check PB1
0526 C281       434       clr MUX_CONTROL_1
0528 A295       435       mov c, PB_INPUT_PIN
052A 920B       436       mov PB1, c
052C D281       437       setb MUX_CONTROL_1
052E            438   
052E            439       ; Check PB0
052E C280       440       clr MUX_CONTROL_0
0530 A295       441       mov c, PB_INPUT_PIN
0532 920A       442       mov PB0, c
0534 D280       443       setb MUX_CONTROL_0
0536            444   
0536            445   LCD_PB_Done:
0536 22         446       ret
0537            447   
0537            448   ;----------------------------------------------------------------------
0537            449   ; Display_formated_BCD: Display the result with decimal
0537            450   ;----------------------------------------------------------------------
0537            451   Display_formated_BCD:
0537 C0E0       452            push acc
0539 7401       452            mov a, #1
053B 14         452            dec a
053C 1200DB     452            lcall ?Set_Cursor_2 ; Select column and row
053F D0E0       452            pop acc
0541 C000       453            push ar0
0543 A83A       453            mov r0, bcd+2
0545 1200E2     453            lcall ?Display_BCD
0548 D000       453            pop ar0
054A C000       454            push ar0
054C A839       454            mov r0, bcd+1
054E 1200E2     454            lcall ?Display_BCD
0551 D000       454            pop ar0
0553 C0E0       455            push acc
0555 742E       455            mov a, #'.'
0557 120093     455            lcall ?WriteData
055A D0E0       455            pop acc
055C C000       456            push ar0
055E A838       456            mov r0, bcd+0
0560 1200E2     456            lcall ?Display_BCD
0563 D000       456            pop ar0
0565 C0E0       457            push acc
0567 74DF       457            mov a, #0xDF
0569 120093     457            lcall ?WriteData
056C D0E0       457            pop acc    ; Degree symbol
056E C0E0       458            push acc
0570 7443       458            mov a, #'C'
0572 120093     458            lcall ?WriteData
0575 D0E0       458            pop acc
0577 C0E0       459            push acc
0579 7401       459            mov a, #1
057B 14         459            dec a
057C 1200DB     459            lcall ?Set_Cursor_2 ; Select column and row
057F D0E0       459            pop acc
0581 C0E0       460            push acc
0583 7420       460            mov a, #' '
0585 120093     460            lcall ?WriteData
0588 D0E0       460            pop acc
058A 22         461       ret
058B            462   
058B            463   ;----------------------------------------------------------------------
058B            464   ; Read_ADC: reads current ADC channel into R0:R1 (12-bit)
058B            465   ;----------------------------------------------------------------------
058B            466   Read_ADC:
058B C2EF       467       clr  ADCF
058D D2EE       468       setb ADCS
058F 30EFFD     469       jnb  ADCF, $          ; Wait conversion
0592 E5C2       470       mov  a, ADCRL
0594 540F       471       anl  a, #0x0F
0596 F8         472       mov  R0, a
0597 E5C3       473       mov  a, ADCRH
0599 C4         474       swap a
059A C0E0       475       push acc
059C 540F       476       anl  a, #0x0F
059E F9         477       mov  R1, a
059F D0E0       478       pop  acc
05A1 54F0       479       anl  a, #0xF0
05A3 48         480       orl  a, R0
05A4 F8         481       mov  R0, a
05A5 22         482       ret
05A6            483   
05A6            484   ;----------------------------------------------------------------------
05A6            485   ; New code for push-button-based FSM parameter updates
05A6            486   ; We intercept button presses in SendSerial
05A6            487   ;----------------------------------------------------------------------
05A6            488   SendBCD:
05A6            489   
05A6 E53A       490            mov a, bcd+2
05A8 540F       491            anl a, #0x0F ; Isolate ones place
05AA 2430       492            add a, #'0' ; Convert value to ASCII
05AC 120601     493            lcall SendSerial
05AF            494   
05AF E539       495            mov a, bcd+1
05B1 54F0       496            anl a, #0xF0 ; Isolate tens place
05B3 C4         497            swap a ; Put high nibble into lower nibble
05B4 2430       498            add a, #'0' ; Convert value to ASCII
05B6 120601     499            lcall SendSerial
05B9            500   
05B9 E539       501            mov a, bcd+1
05BB 540F       502            anl a, #0x0F ; Isolate ones place
05BD 2430       503            add a, #'0' ; Convert value to ASCII
05BF 120601     504            lcall SendSerial
05C2            505   
05C2 742E       506            mov a, #'.'
05C4 120601     507            lcall SendSerial
05C7            508   
05C7 E538       509            mov a, bcd+0
05C9 54F0       510            anl a, #0xF0 ; Isolate 0.1 place
05CB C4         511            swap a ; Put high nibble into lower nibble
05CC 2430       512            add a, #'0' ; Convert value to ASCII
05CE 120601     513            lcall SendSerial
05D1            514   
05D1 E538       515            mov a, bcd+0
05D3 540F       516            anl a, #0x0F ; Isolate 0.01 place
05D5 2430       517            add a, #'0' ; Convert value to ASCII
05D7 120601     518            lcall SendSerial
05DA            519   
05DA 7420       520       mov a, #' '
05DC 120601     521       lcall SendSerial
05DF            522   
05DF 7400       523       mov a, #0
05E1 A205       524       mov c, temp_state1
05E3 92E0       525       mov acc.0, c
05E5 2430       526       add a, #'0'
05E7 120601     527       lcall SendSerial
05EA            528       
05EA 7420       529       mov a, #' '
05EC 120601     530       lcall SendSerial
05EF            531       
05EF E53F       532       mov a, state
05F1 2430       533       add a, #'0'
05F3 120601     534       lcall SendSerial
05F6            535   
05F6 740A       536            mov a, #'\n'
05F8 120601     537            lcall SendSerial
05FB            538   
05FB 740D       539            mov a, #'\r'
05FD 120601     540            lcall SendSerial
0600            541   
0600 22         542            ret
0601            543   
0601            544   
0601            545   SendSerial:
0601            546       ; Simulate sending 'a' to UART
0601 C299       547       clr  TI
0603 F599       548       mov  SBUF, a
0605            549       ; Wait for TX
0605            550   WaitTx:
0605 3099FD     551       jnb TI, WaitTx
0608 C299       552       clr TI
060A            553   
060A            554       ; Now check buttons each time we "send":
060A            555       ; If button is pressed (bit=0), jump to its handler.
060A 300A0A     556       jnb PB0, start_oven
060D 300B0D     557       jnb PB1, toggle_state
0610 300C18     558       jnb PB2, inc_value
0613 300D37     559       jnb PB3, dec_value
0616            560       ; PB4 is unused for now, do nothing if pressed.
0616            561   
0616 22         562       ret
0617            563   
0617            564   ; Start the FSM
0617            565   start_oven:
0617            566       ;setb start                                  ; set the flag to 1, indicating that the FSM should begin
0617 753F01     567       mov state, #1                                ; return to main or update display as needed
061A 020673     568       ljmp end_button_logic           ; jump to exit logic
061D            569   
061D            570   ; Toggle which parameter is selected (1..4)
061D            571   toggle_state:
061D E55F       572       mov a, selected_state           ; load the selected state to the accumulator
061F 2401       573       add a, #1                       ; icnrement the selection
0621 B40502     574       cjne a, #5, noWrap              ; if not greater than 4, jump to noWrap
0624 7401       575       mov a, #1                       ; if (selected_state == 5), reset the selected state, i.e. selected_state == 1
0626            576   noWrap:
0626 F55F       577       mov selected_state, a           ; store the updated selected_state
0628 020673     578       ljmp end_button_logic           ; jump to exit logic
062B            579   
062B            580   ; Increment whichever parameter is selected
062B            581   ; ** DOUBLE CHECK THIS LOGIC IM NOT TOO SURE **
062B            582   inc_value:
062B E55F       583       mov a, selected_state           ; load the selected state into the accumulator
062D B40105     584       cjne a, #1, checkState2         ; if selected_state != temp_soak, check the next selected state
0630 0564       585       inc temp_soak                   ; increment temp_soak if above condition not true
0632 020673     586       ljmp end_button_logic           ; jump to exit logic
0635            587   
0635            588   checkState2:                    
0635 B40205     589       cjne a, #2, checkState3         ; if not time_soak, check the next parameter
0638 0565       590       inc time_soak                   ; increment time_soak
063A 020673     591       ljmp end_button_logic           ; jump to exit logic
063D            592   
063D            593   checkState3:
063D B40305     594       cjne a, #3, checkState4         ; if not temp_refl, check next parameter
0640 0566       595       inc temp_refl                   ; increment temp_refl
0642 020673     596       ljmp end_button_logic           ; jump to exit logic
0645            597   
0645            598   checkState4:                        
0645 B4042B     599       cjne a, #4, end_button_logic    ; if not time_refl, exit 
0648 0567       600       inc time_refl                   ; inc time_refl
064A 020673     601       ljmp end_button_logic           ; jump to exit logic
064D            602   
064D            603   ; Decrement whichever parameter is selected
064D            604   ; ** SAME IDEA BUT CHECK THE LOGIC PLEASE ** 
064D            605   dec_value:
064D E55F       606       mov a, selected_state
064F B40106     607       cjne a, #1, dcheckState2
0652 D5641E     608       djnz temp_soak, end_button_logic
0655 020673     609       ljmp end_button_logic
0658            610   
0658            611   dcheckState2:
0658 B40206     612       cjne a, #2, dcheckState3
065B D56515     613       djnz time_soak, end_button_logic
065E 020673     614       ljmp end_button_logic
0661            615   
0661            616   dcheckState3:
0661 B40306     617       cjne a, #3, dcheckState4
0664 D5660C     618       djnz temp_refl, end_button_logic
0667 020673     619       ljmp end_button_logic
066A            620   
066A            621   dcheckState4:
066A B40406     622       cjne a, #4, end_button_logic
066D D56703     623       djnz time_refl, end_button_logic
0670 020673     624       ljmp end_button_logic
0673            625   
0673            626   end_button_logic:
0673 22         627       ret
0674            628   
0674            629   ;----------------------------------------------------------------------
0674            630   ; main
0674            631   ;----------------------------------------------------------------------
0674            632   main:
0674 75817F     633       mov sp, #0x7F
0677 120480     634       lcall Init_All
067A 12009D     635       lcall LCD_4BIT
067D            636   
067D 754601     637       mov MeasurementCounter+0, #1
0680 754700     638       mov MeasurementCounter+1, #0
0683 754A01     639       mov TimePerSample, #1
0686            640   
0686 75482C     641       mov SamplesPerDisplay+0, #low(SAMPLES_PER_DISPLAY)
0689 754901     642       mov SamplesPerDisplay+1, #high(SAMPLES_PER_DISPLAY)
068C            643   
068C            644       ; We start with "state=0" (idle)
068C 753F00     645       mov state, #0
068F C204       646       clr start 
0691 C201       647       clr m_flag
0693            648   
0693            649       ; Default setpoints
0693 756428     650       mov temp_soak, #40
0696 75653C     651       mov time_soak, #60
0699 7566DC     652       mov temp_refl, #220
069C 75672D     653       mov time_refl, #45
069F            654   
069F            655       ; Which parameter we are currently adjusting: 1=temp_soak,2=time_soak,3=temp_refl,4=time_refl
069F 755F01     656       mov selected_state, #1
06A2            657   
06A2 754B00     658       mov LastMeasurement+0, #0
06A5 754C00     659       mov LastMeasurement+1, #0
06A8 754D00     660       mov LastMeasurement+2, #0
06AB 754E00     661       mov LastMeasurement+3, #0
06AE            662       
06AE            663       ;clr temp_state1
06AE            664   
06AE            665       ; Show initial LCD message
06AE C0E0       666            push acc
06B0 7401       666            mov a, #1
06B2 14         666            dec a
06B3 1200DD     666            lcall ?Set_Cursor_1 ; Select column and row
06B6 D0E0       666            pop acc
06B8 C083       667            push dph
06BA C082       667            push dpl
06BC C0E0       667            push acc
06BE 90002E     667            mov dptr, #test_message
06C1 1200D0     667            lcall ?Send_Constant_String
06C4 D0E0       667            pop acc
06C6 D082       667            pop dpl
06C8 D083       667            pop dph
06CA            668   
06CA            669   Forever:
06CA            670       ; Example read reference (AIN0)
06CA 53E8F0     671       anl  ADCCON0, #0xF0
06CD 43E800     672       orl  ADCCON0, #0x00 ; Channel0
06D0 12058B     673       lcall Read_ADC
06D3 883D       674       mov  VAL_LM4040+0, R0
06D5 893E       675       mov  VAL_LM4040+1, R1
06D7            676   
06D7            677       ; Read LM335 on AIN7
06D7 53E8F0     678       anl  ADCCON0, #0xF0
06DA 43E807     679       orl  ADCCON0, #0x07
06DD 12058B     680       lcall Read_ADC
06E0            681   
06E0            682       ; Convert to "voltage" in x
06E0 8830       683       mov  x+0, R0
06E2 8931       684       mov  x+1, R1
06E4 753200     685       mov  x+2, #0
06E7 753300     686       mov  x+3, #0
06EA 7534FF     687            mov y+0, #low (40959 % 0x10000) 
06ED 75359F     687            mov y+1, #high(40959 % 0x10000) 
06F0 753600     687            mov y+2, #low (40959 / 0x10000) 
06F3 753700     687            mov y+3, #high(40959 / 0x10000)        ; e.g. 4.0959 => times 10000 in math
06F6 120272     688       lcall mul32
06F9 853D34     689       mov  y+0, VAL_LM4040+0
06FC 853E35     690       mov  y+1, VAL_LM4040+1
06FF 753600     691       mov  y+2, #0
0702 753700     692       mov  y+3, #0
0705 1202FF     693       lcall div32
0708            694   
0708            695       ; Add partial result to StoreMeasurements
0708 854034     696       mov  y+0, StoreMeasurements+0
070B 854135     697       mov  y+1, StoreMeasurements+1
070E 854236     698       mov  y+2, StoreMeasurements+2
0711 854337     699       mov  y+3, StoreMeasurements+3
0714 1201BD     700       lcall add32
0717 853040     701       mov  StoreMeasurements+0, x+0
071A 853141     702       mov  StoreMeasurements+1, x+1
071D 853242     703       mov  StoreMeasurements+2, x+2
0720 853343     704       mov  StoreMeasurements+3, x+3
0723            705   
0723            706       ; Read thermocouple on AIN4
0723 53E8F0     707       anl  ADCCON0, #0xF0
0726 43E804     708       orl  ADCCON0, #0x04
0729 12058B     709       lcall Read_ADC
072C            710   
072C 8830       711       mov  x+0, R0
072E 8931       712       mov  x+1, R1
0730 753200     713       mov  x+2, #0
0733 753300     714       mov  x+3, #0
0736 7534FF     715            mov y+0, #low (40959 % 0x10000) 
0739 75359F     715            mov y+1, #high(40959 % 0x10000) 
073C 753600     715            mov y+2, #low (40959 / 0x10000) 
073F 753700     715            mov y+3, #high(40959 / 0x10000) 
0742 120272     716       lcall mul32
0745 853D34     717       mov  y+0, VAL_LM4040+0
0748 853E35     718       mov  y+1, VAL_LM4040+1
074B 753600     719       mov  y+2, #0
074E 753700     720       mov  y+3, #0
0751 1202FF     721       lcall div32
0754            722   
0754            723       ; Add partial result to StoreThermocouple
0754 854F34     724       mov  y+0, StoreThermocouple+0
0757 855035     725       mov  y+1, StoreThermocouple+1
075A 855136     726       mov  y+2, StoreThermocouple+2
075D 855237     727       mov  y+3, StoreThermocouple+3
0760 1201BD     728       lcall add32
0763 85304F     729       mov  StoreThermocouple+0, x+0
0766 853150     730       mov  StoreThermocouple+1, x+1
0769 853251     731       mov  StoreThermocouple+2, x+2
076C 853352     732       mov  StoreThermocouple+3, x+3
076F            733   
076F            734       ; Delay between samples
076F AA4A       735       mov R2, TimePerSample
0771 1204DD     736       lcall waitms
0774            737   
0774            738       ; Decrement measurement counter
0774 1546       739       dec MeasurementCounter+0
0776 E546       740       mov a, MeasurementCounter+0
0778 B4FF02     741       cjne a, #0xFF, CheckHigh
077B 1547       742       dec MeasurementCounter+1
077D            743   CheckHigh:
077D E546       744       mov a, MeasurementCounter+0
077F 4547       745       orl a, MeasurementCounter+1
0781 6003       746       jz  DisplayValue
0783 0208C9     747       ljmp EndForever
0786            748   
0786            749   ;----------------------------------------------------------------------
0786            750   ; If enough measurements collected -> compute final temperature
0786            751   ;----------------------------------------------------------------------
0786            752   DisplayValue:
0786 753400     753            mov y+0, #low (0 % 0x10000) 
0789 753500     753            mov y+1, #high(0 % 0x10000) 
078C 753600     753            mov y+2, #low (0 / 0x10000) 
078F 753700     753            mov y+3, #high(0 / 0x10000) 
0792            754       ; Combine for LM335 reading
0792 854030     755       mov x+0, StoreMeasurements+0
0795 854131     756       mov x+1, StoreMeasurements+1
0798 854232     757       mov x+2, StoreMeasurements+2
079B 854333     758       mov x+3, StoreMeasurements+3
079E E548       759       mov a, SamplesPerDisplay+0
07A0 F534       760       mov y+0, a
07A2 F546       761       mov MeasurementCounter+0, a
07A4 E549       762       mov a, SamplesPerDisplay+1
07A6 F535       763       mov y+1, a
07A8 F547       764       mov MeasurementCounter+1, a
07AA 1202FF     765       lcall div32
07AD            766   
07AD            767       ; Subtract 273.00 => Celsius reading
07AD 7534A4     768            mov y+0, #low (27300 % 0x10000) 
07B0 75356A     768            mov y+1, #high(27300 % 0x10000) 
07B3 753600     768            mov y+2, #low (27300 / 0x10000) 
07B6 753700     768            mov y+3, #high(27300 / 0x10000) 
07B9 1201DE     769       lcall sub32
07BC 853057     770       mov FinalLM335+0, x+0
07BF 853158     771       mov FinalLM335+1, x+1
07C2 853259     772       mov FinalLM335+2, x+2
07C5 85335A     773       mov FinalLM335+3, x+3
07C8            774   
07C8            775       ; Combine for thermocouple reading
07C8 753400     776            mov y+0, #low (0 % 0x10000) 
07CB 753500     776            mov y+1, #high(0 % 0x10000) 
07CE 753600     776            mov y+2, #low (0 / 0x10000) 
07D1 753700     776            mov y+3, #high(0 / 0x10000) 
07D4 854F30     777       mov x+0, StoreThermocouple+0
07D7 855031     778       mov x+1, StoreThermocouple+1
07DA 855132     779       mov x+2, StoreThermocouple+2
07DD 855233     780       mov x+3, StoreThermocouple+3
07E0 E548       781       mov a, SamplesPerDisplay+0
07E2 F534       782       mov y+0, a
07E4 E549       783       mov a, SamplesPerDisplay+1
07E6 F535       784       mov y+1, a
07E8 1202FF     785       lcall div32
07EB            786   
07EB            787       ; Add thermocouple to LM335 reading => final in x
07EB 753400     788            mov y+0, #low (0 % 0x10000) 
07EE 753500     788            mov y+1, #high(0 % 0x10000) 
07F1 753600     788            mov y+2, #low (0 / 0x10000) 
07F4 753700     788            mov y+3, #high(0 / 0x10000) 
07F7 855734     789       mov y+0, FinalLM335+0
07FA 855835     790       mov y+1, FinalLM335+1
07FD 855936     791       mov y+2, FinalLM335+2
0800 855A37     792       mov y+3, FinalLM335+3
0803 1201BD     793       lcall add32
0806            794   
0806 85305B     795       mov FinalTemp+0, x+0
0809 85315C     796       mov FinalTemp+1, x+1
080C 85325D     797       mov FinalTemp+2, x+2
080F 85335E     798       mov FinalTemp+3, x+3
0812            799   
0812            800       ; --------------------------------------------------------
0812            801       ; Compare final temperature with soak/reflow setpoints
0812            802       ; --------------------------------------------------------
0812 753464     803            mov y+0, #low (100 % 0x10000) 
0815 753500     803            mov y+1, #high(100 % 0x10000) 
0818 753600     803            mov y+2, #low (100 / 0x10000) 
081B 753700     803            mov y+3, #high(100 / 0x10000) 
081E 856430     804       mov x+0, temp_soak
0821 753100     805       mov x+1, #0
0824 753200     806       mov x+2, #0
0827 753300     807       mov x+3, #0
082A 120272     808       lcall mul32
082D 855B34     809       mov y+0, FinalTemp+0
0830 855C35     810       mov y+1, FinalTemp+1
0833 855D36     811       mov y+2, FinalTemp+2
0836 855E37     812       mov y+3, FinalTemp+3
0839 12025E     813       lcall x_gteq_y
083C 850005     814       mov temp_state1, mf
083F            815   
083F 753464     816            mov y+0, #low (100 % 0x10000) 
0842 753500     816            mov y+1, #high(100 % 0x10000) 
0845 753600     816            mov y+2, #low (100 / 0x10000) 
0848 753700     816            mov y+3, #high(100 / 0x10000) 
084B 856630     817       mov x+0, temp_refl
084E 753100     818       mov x+1, #0
0851 753200     819       mov x+2, #0
0854 753300     820       mov x+3, #0
0857 120272     821       lcall mul32
085A 855B34     822       mov y+0, FinalTemp+0
085D 855C35     823       mov y+1, FinalTemp+1
0860 855D36     824       mov y+2, FinalTemp+2
0863 855E37     825       mov y+3, FinalTemp+3
0866 12025E     826       lcall x_gteq_y
0869 850007     827       mov temp_state3, mf
086C            828   
086C            829       ; Check error states
086C 855B30     830       mov x+0, FinalTemp+0
086F 855C31     831       mov x+1, FinalTemp+1
0872 855D32     832       mov x+2, FinalTemp+2
0875 855E33     833       mov x+3, FinalTemp+3
0878            834   
0878 7534A8     835            mov y+0, #low (25000 % 0x10000) 
087B 753561     835            mov y+1, #high(25000 % 0x10000) 
087E 753600     835            mov y+2, #low (25000 / 0x10000) 
0881 753700     835            mov y+3, #high(25000 / 0x10000) 
0884 12025E     836       lcall x_gteq_y
0887 850003     837       mov err_tmp_150, mf
088A            838   
088A 753488     839            mov y+0, #low (5000 % 0x10000) 
088D 753513     839            mov y+1, #high(5000 % 0x10000) 
0890 753600     839            mov y+2, #low (5000 / 0x10000) 
0893 753700     839            mov y+3, #high(5000 / 0x10000) 
0896 12025E     840       lcall x_gteq_y
0899 850002     841       mov err_tmp, mf
089C            842   
089C            843       ; Convert FinalTemp => BCD => display
089C 1200F8     844       lcall hex2bcd
089F 120537     845       lcall Display_formated_BCD
08A2 1205A6     846       lcall SendBCD
08A5            847   
08A5            848       ; Reset accumulators
08A5 754000     849       mov StoreMeasurements+0, #0
08A8 754100     850       mov StoreMeasurements+1, #0
08AB 754200     851       mov StoreMeasurements+2, #0
08AE 754300     852       mov StoreMeasurements+3, #0
08B1 754F00     853       mov StoreThermocouple+0, #0
08B4 755000     854       mov StoreThermocouple+1, #0
08B7 755100     855       mov StoreThermocouple+2, #0
08BA 755200     856       mov StoreThermocouple+3, #0
08BD 755700     857       mov FinalLM335+0, #0
08C0 755801     858       mov FinalLM335+1, #1
08C3 755902     859       mov FinalLM335+2, #2
08C6 755A03     860       mov FinalLM335+3, #3
08C9            861   
08C9            862   EndForever:
08C9            863       ; Always read the push buttons each pass
08C9 1204E3     864       lcall LCD_PB
08CC            865   
08CC            866   
08CC 753000     867       mov x+0, #0
08CF 753100     868       mov x+1, #0
08D2 753200     869       mov x+2, #0
08D5 753300     870       mov x+3, #0
08D8 0206CA     871       ljmp Forever
08DB            872   
08DB            873   END
