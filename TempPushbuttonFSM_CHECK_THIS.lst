0000              1   ;----------------------------------------------------------------------
0000              2   ; 76E003 ADC test program (reflow oven controller + push buttons)
0000              3   ; Reads channel 7 on P1.1, pin 14
0000              4   ; This version uses the LM4040 voltage reference connected to pin 6 (P1.7/AIN0)
0000              5   ; Incorporates push-button control to set up times/temperatures and start FSM.
0000              6   ;----------------------------------------------------------------------
0000              7   
                  9   $LIST
0000             11   
0000             12   ;  N76E003 pinout:
0000             13   ;                               -------
0000             14   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             15   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             16   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             17   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             18   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             19   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             20   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             21   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             22   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             23   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             24   ;                               -------
0000             25   ;
0000             26   
0000             27   ;----------------------------------------------------------------------
0000             28   ; System/Timer/Constants
0000             29   ;----------------------------------------------------------------------
0000             30   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             31   BAUD              EQU 115200   ; Baud rate of UART in bps
0000             32   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             33   
0000             34   TIMER2_RATE       EQU 100      ; 100 Hz -> 10ms tick
0000             35   TIMER2_RELOAD     EQU ((65536-(CLK/TIMER2_RATE)))
0000             36   
0000             37   SAMPLES_PER_DISPLAY  EQU 300
0000             38   REFRESHES_PER_SECOND EQU 45
0000             39   TIMER0_DENOM         EQU (SAMPLES_PER_DISPLAY*REFRESHES_PER_SECOND)
0000             40   TIMER0_RELOAD        EQU (0x10000-(CLK/TIMER0_DENOM))
0000             41   
0000             42   ORG 0x0000
0000 020671      43       ljmp main
0003             44   
002B             45   org 0x002B
002B 020385      46       ljmp Timer2_ISR
002E             47   
002E             48   ;----------------------------------------------------------------------
002E             49   ; Hardware Pin Definitions
002E             50   ;----------------------------------------------------------------------
002E             51   
002E             52   ; PUSH BUTTONS (single-pin read approach)
002E             53   PB_INPUT_PIN   EQU P1.5  ; The single pin used to read all 5 PBs
002E             54   MUX_CONTROL_0  EQU P0.0  
002E             55   MUX_CONTROL_1  EQU P0.1  
002E             56   MUX_CONTROL_2  EQU P0.2  
002E             57   MUX_CONTROL_3  EQU P0.3  
002E             58   MUX_CONTROL_4  EQU P1.3  
002E             59   
002E             60   ; LCD assignments
002E             61   LCD_RS  equ P1.3
002E             62   LCD_E   equ P1.4
002E             63   LCD_D4  equ P0.0
002E             64   LCD_D5  equ P0.1
002E             65   LCD_D6  equ P0.2
002E             66   LCD_D7  equ P0.3
002E             67   SSR_BOX equ P0.4
002E             68   
002E             69   ; Strings for LCD
002E 43757272    70   test_message:     db 'Current Temp.:', 0
     656E7420
     54656D70
     2E3A00
003D 4465672E    71   value_message:    db 'Deg. C', 0
     204300
0044             72   
0044             73   cseg
0044             74   
                 76   	$LIST
00F8             78   
00F8             79   ;----------------------------------------------------------------------
00F8             80   ; 32-bit math placeholders
00F8             81   ;----------------------------------------------------------------------
0030             82   DSEG at 30H
0030             83   x:   ds 4
0034             84   y:   ds 4
0038             85   bcd: ds 5
003D             86   VAL_LM4040: ds 2
003F             87   
003F             88   ; Variables
003F             89   state:              ds 1
0040             90   StoreMeasurements:  ds 4
0044             91   TempStore:          ds 2
0046             92   MeasurementCounter: ds 2
0048             93   SamplesPerDisplay:  ds 2
004A             94   TimePerSample:      ds 1
004B             95   LastMeasurement:    ds 4
004F             96   StoreThermocouple:  ds 4
0053             97   CurrentTemp:        ds 4
0057             98   FinalLM335:         ds 4
005B             99   FinalTemp:          ds 4
005F            100   selected_state:          ds 1
0060            101   
0060            102   Count1ms:      ds 2
0062            103   pwm_counter:   ds 1
0063            104   pwm:           ds 1
0064            105   
0064            106   ; Oven settings
0064            107   temp_soak: ds 1  ; For state 1
0065            108   time_soak: ds 1  ; For state 2
0066            109   temp_refl: ds 1  ; For state 3
0067            110   time_refl: ds 1  ; For state 4
0068            111   
0068            112   seconds: ds 1
0069            113   
0069            114   ;----------------------------------------------------------------------
0069            115   ; Bit variables (BSEG)
0069            116   ;----------------------------------------------------------------------
0000            117   BSEG
0000            118   mf:            dbit 1
0001            119   m_flag:        dbit 1
0002            120   err_tmp:       dbit 1
0003            121   err_tmp_150:   dbit 1
0004            122   
0004            123   start:         dbit 1  ; Start the FSM
0005            124   temp_state1:   dbit 1
0006            125   time_state2:   dbit 1
0007            126   temp_state3:   dbit 1
0008            127   time_state4:   dbit 1
0009            128   temp_state5:   dbit 1
000A            129   
000A            130   ; For push buttons
000A            131   PB0: dbit 1  ; Start/Pause
000B            132   PB1: dbit 1  ; Toggle selected parameter
000C            133   PB2: dbit 1  ; Increment
000D            134   PB3: dbit 1  ; Decrement
000E            135   PB4: dbit 1  ; Unused or extra
000F            136   
000F            137   ;SETATS
000F            138   
000F            139   ; We include math32 at the end of initialization
                546   $LIST
                141   $LIST
0368            143   
0368            144   ;----------------------------------------------------------------------
0368            145   ; Timer2 Initialization & ISR
0368            146   ;----------------------------------------------------------------------
0368            147   Timer2_Init:
0368 75C800     148       mov T2CON, #0       ; Stop timer, mode = auto-reload
036B 75CD78     149       mov TH2, #high(TIMER2_RELOAD)
036E 75CC90     150       mov TL2, #low(TIMER2_RELOAD)
0371 43C980     151       orl T2MOD, #0x80    ; Enable auto-reload
0374 75CB78     152       mov RCMP2H, #high(TIMER2_RELOAD)
0377 75CA90     153       mov RCMP2L, #low(TIMER2_RELOAD)
037A E4         154       clr  a
037B F560       155       mov  Count1ms+0, a
037D F561       156       mov  Count1ms+1, a
037F 439B80     157       orl  EIE, #0x80     ; Enable timer2 interrupt (ET2=1)
0382 D2CA       158       setb TR2            ; Start Timer2
0384 22         159       ret
0385            160   
0385            161   Timer2_ISR:
0385 C2CF       162       clr TF2 ; Must clear TF2 manually on N76
0387 C0E0       163       push acc
0389 C0D0       164       push psw
038B            165   
038B            166       ;---------------------------------
038B            167       ; 1ms counter
038B            168       ;---------------------------------
038B 0560       169       inc Count1ms+0
038D E560       170       mov a, Count1ms+0
038F 7028       171       jnz Inc_Done
0391 0561       172       inc Count1ms+1
0393            173   
0393            174       ;---------------------------------
0393            175       ; PWM for SSR control
0393            176       ;---------------------------------
0393 0562       177       inc pwm_counter
0395 C3         178       clr c
0396 E563       179       mov a, pwm
0398 9562       180       subb a, pwm_counter ; if pwm_counter <= pwm, c=1
039A B3         181       cpl c
039B 9284       182       mov SSR_BOX, c
039D            183   
039D E562       184       mov a, pwm_counter
039F B46410     185       cjne a, #100, jumpy1
03A2 756200     186       mov pwm_counter, #0
03A5 0568       187       inc seconds
03A7 E4         188       clr a
03A8 E568       189       mov a, seconds
03AA B46008     190       cjne a, #0x60, oneMin
03AD D201       191       setb m_flag
03AF 0203B9     192       ljmp Inc_Done
03B2            193   
03B2            194   jumpy1:
03B2 020478     195       ljmp Timer2_ISR_done
03B5            196   
03B5            197   oneMin:
03B5            198       ; If you also need a second-flag for main, do so here:
03B5            199       ; setb s_flag
03B5 E4         200       clr a
03B6 0203B9     201       ljmp Inc_Done
03B9            202   
03B9            203   Inc_Done:
03B9            204       ;---------------------------------
03B9            205       ; Example: Half-second tasks
03B9            206       ;---------------------------------
03B9 E560       207       mov a, Count1ms+0
03BB B4E805     208       cjne a, #low(1000), State_0 ; Not needed, the PWM stuff keeps track of seconds, also this is wrong since we have a 10ms interval between timer interrupts now, not 1ms
03BE E561       209       mov a, Count1ms+1
03C0 B40300     210       cjne a, #high(1000), State_0
03C3            211       ; If both match, ~1 second has passed
03C3            212       ; setb half_seconds_flag
03C3            213       ; add any code here if needed
03C3            214   
03C3            215   State_0:
03C3 E53F       216       mov a, state
03C5 B4000D     217            cjne a, #0, State_1
03C8 E4         218       clr a
03C9 756300     219            mov pwm, #0
03CC 200454     220            jb start, jumpy ; This needs to be moved to before cjne, since otherwise we never go to state 1
03CF 753F01     221            mov state, #1
03D2 020478     222            ljmp Timer2_ISR_done
03D5            223            
03D5            224   State_1:
03D5 E53F       225            mov a, state
03D7 B4012B     226            cjne a, #1, State_2
03DA 756364     227            mov pwm, #100                                   ; set pwm for relfow oven to 100%
03DD            228            ;jb m_flag, Cond_check
03DD A205       229            mov c, temp_state1
03DF E4         230            clr a                                                   ; clear the accumulator
03E0 92E0       231            mov acc.0, c
03E2 C3         232            clr c                                                   ; clear the carry bit
03E3 B4003D     233            cjne a, #0, jumpy       ; mf = 1 if oven temp <= set temp, jump out of ISR. mf = 0 if oven temp > set temp, thus move onto next state                   
03E6 E4         234            clr a                                           
03E7 756800     235            mov seconds, #0
03EA 753F02     236            mov state, #2
03ED 020405     237            ljmp State_2
03F0            238   
03F0            239   Cond_check: ; cjne is not bit-addressable, therefore we must move bits into byte registers (i.e. accumulator and register b)
03F0 A202       240            mov c, err_tmp
03F2 E4         241            clr a 
03F3 92E0       242            mov acc.0, c ; mov value in carry to the lowest bit of the accumulator
03F5 A201       243            mov c, m_flag
03F7 C201       244            clr m_flag ; clear minute flag
03F9 75F000     245            mov b, #00h 
03FC 92F0       246            mov b.0, c ; mov value in carry to the lowest bit of the B regrister
03FE C3         247            clr c
03FF B5F072     248            cjne a, b, State_error
0402 0203D5     249            ljmp State_1
0405            250   
0405            251   State_2: ;transition to state three if more than 60 seconds have passed
0405 E53F       252            mov a, state
0407 B4021C     253            cjne a, #2, State_3
040A 756314     254            mov pwm, #20
040D 300364     255            jnb err_tmp_150, State_error
0410 A206       256            mov c, time_state2
0412 E4         257            clr a                                                   ; clear the accumulator
0413 92E0       258            mov acc.0, c
0415 C3         259            clr c                                                   ; clear the carry bit
0416 B5680A     260            cjne a, seconds, jumpy
0419 E4         261            clr a
041A 756800     262            mov seconds, #0                         
041D 753F03     263            mov state, #3
0420 020426     264       ljmp State_3
0423            265   
0423            266   jumpy:
0423 020478     267       ljmp Timer2_ISR_done
0426            268   
0426            269   State_3: 
0426 E53F       270            mov a, state
0428 B40316     271            cjne a, #3, State_4 ; check if state = 3, if not, move to state_4
042B 756364     272            mov pwm, #100 ; set pwm to 100%
042E 300343     273            jnb err_tmp_150, State_error
0431 A207       274            mov c, temp_state3
0433 E4         275            clr a                                                   ; clear the accumulator
0434 92E0       276            mov acc.0, c
0436 C3         277            clr c                                                   ; clear the carry bit
0437 B4003E     278            cjne a, #0, Timer2_ISR_done ; 
043A E4         279            clr a
043B 756800     280            mov seconds, #0
043E 753F04     281            mov state, #4
0441            282   
0441            283   State_4:
0441 E53F       284            mov a, state
0443 B40416     285            cjne a, #4, State_5
0446 756314     286            mov pwm, #20
0449 300328     287            jnb err_tmp_150, State_error
044C A208       288            mov c, time_state4
044E E4         289            clr a                                                   ; clear the accumulator
044F 92E0       290            mov acc.0, c
0451 C3         291            clr c                                                   ; clear the carry bit
0452 B56823     292            cjne a, seconds, Timer2_ISR_done
0455 E4         293            clr a
0456 756800     294            mov seconds, #0
0459 753F05     295            mov state, #5
045C            296   
045C            297   State_5:
045C E53F       298            mov a, state
045E B40517     299            cjne a, #5, Timer2_ISR_done
0461 756300     300            mov pwm, #0
0464 A209       301            mov c, temp_state5
0466 E4         302            clr a                                                   ; clear the accumulator
0467 92E0       303            mov acc.0, c
0469 C3         304            clr c                                                   ; clear the carry bit
046A B4010B     305            cjne a, #1, Timer2_ISR_done
046D E4         306            clr a
046E 756800     307            mov seconds, #0
0471 753F00     308            mov state, #0
0474            309   
0474            310   State_error:
0474 E53F       311            mov a, state
0476 7400       312            mov a, #0
0478            313            ; probably should put branch for warning message here
0478            314   
0478            315   Timer2_ISR_done:
0478 D0D0       316       pop psw
047A D0E0       317       pop acc
047C 32         318       reti
047D            319   
047D            320   ;----------------------------------------------------------------------
047D            321   ; Initialization
047D            322   ;----------------------------------------------------------------------
047D            323   Init_All:
047D            324       ; Configure all the pins for bidirectional I/O
047D 75AC00     325       mov P3M1, #0x00
0480 75AD00     326       mov P3M2, #0x00
0483 75B300     327       mov P1M1, #0x00
0486 75B400     328       mov P1M2, #0x00
0489 75B100     329       mov P0M1, #0x00
048C 75B200     330       mov P0M2, #0x00
048F            331   
048F 120368     332       lcall Timer2_Init
0492            333   
0492            334       ; Timer1 for UART
0492 438E10     335       orl  CKCON, #0x10     ; Timer1 uses system clock
0495 438780     336       orl  PCON,  #0x80     ; SMOD=1 -> double baud
0498 759852     337       mov  SCON,  #0x52     ; UART mode 1, REN=1
049B 53C4DF     338       anl  T3CON, #0b11011111
049E 53890F     339       anl  TMOD,  #0x0F
04A1 438920     340       orl  TMOD,  #0x20     ; Timer1 Mode2 (8-bit auto-reload)
04A4 758DF7     341       mov  TH1, #TIMER1_RELOAD
04A7 D28E       342       setb TR1
04A9            343   
04A9            344       ; Timer0 for waitms
04A9 C28C       345       clr TR0
04AB 438E08     346       orl CKCON, #0x08
04AE 5389F0     347       anl TMOD,  #0xF0
04B1 438901     348       orl TMOD,  #0x01      ; 16-bit mode
04B4            349       ; ADC pins: P1.1 (AIN7), P1.7 (AIN0)
04B4 43B382     350       orl P1M1, #0b10000010 ; Set P1.1 & P1.7 as input
04B7 53B47D     351       anl P1M2, #0b01111101
04BA            352   
04BA            353       ; Initialize ADC
04BA 53E8F0     354       anl ADCCON0, #0xF0
04BD 43E807     355       orl ADCCON0, #0x07    ; default to channel 7
04C0 75F600     356       mov AINDIDS, #0x00    ; disable all digital inputs
04C3 43F681     357       orl AINDIDS, #0b10000001 ; activate AIN0 and AIN7
04C6 43E101     358       orl ADCCON1, #0x01    ; enable ADC
04C9 22         359       ret
04CA            360   
04CA            361   ;----------------------------------------------------------------------
04CA            362   ; Delay Routines
04CA            363   ;----------------------------------------------------------------------
04CA            364   wait_1ms:
04CA C28C       365       clr TR0
04CC C28D       366       clr TF0
04CE 758CFB     367       mov TH0, #high(TIMER0_RELOAD)
04D1 758A33     368       mov TL0, #low(TIMER0_RELOAD)
04D4 D28C       369       setb TR0
04D6 308DFD     370       jnb TF0, $
04D9 22         371       ret
04DA            372   
04DA            373   ; Wait R2 milliseconds
04DA            374   waitms:
04DA 1204CA     375       lcall wait_1ms
04DD DAFB       376       djnz R2, waitms
04DF 22         377       ret
04E0            378   
04E0            379   ;----------------------------------------------------------------------
04E0            380   ; LCD_PB: Read the 5 push buttons into PB0..PB4 bits
04E0            381   ;----------------------------------------------------------------------
04E0            382   LCD_PB:
04E0            383       ; Default all PB bits to 1 (released)
04E0 D20A       384       setb PB0 
04E2 D20B       385       setb PB1
04E4 D20C       386       setb PB2
04E6 D20D       387       setb PB3
04E8 D20E       388       setb PB4
04EA            389       ; The input pin is idle-high (pull-up)
04EA D295       390       setb PB_INPUT_PIN
04EC            391   
04EC            392       ; Set MUX lines to 0 first
04EC C280       393       clr MUX_CONTROL_0
04EE C281       394       clr MUX_CONTROL_1
04F0 C282       395       clr MUX_CONTROL_2
04F2 C283       396       clr MUX_CONTROL_3
04F4 C293       397       clr MUX_CONTROL_4
04F6            398   
04F6            399       ;---------------------------------
04F6            400       ; Debouncing
04F6            401       ;---------------------------------
04F6 20953A     402       jb  PB_INPUT_PIN, LCD_PB_Done 
04F9 7A32       403       mov R2, #50
04FB 1204DA     404       lcall waitms
04FE            405       
04FE 209532     406       jb  PB_INPUT_PIN, LCD_PB_Done
0501            407   
0501            408       ; Now set all MUX lines = 1 to read them individually
0501 D280       409       setb MUX_CONTROL_0
0503 D281       410       setb MUX_CONTROL_1
0505 D282       411       setb MUX_CONTROL_2
0507 D283       412       setb MUX_CONTROL_3
0509 D293       413       setb MUX_CONTROL_4
050B            414   
050B            415       ; Check PB4
050B C293       416       clr MUX_CONTROL_4
050D A295       417       mov c, PB_INPUT_PIN
050F 920E       418       mov PB4, c
0511 D293       419       setb MUX_CONTROL_4
0513            420   
0513            421       ; Check PB3
0513 C283       422       clr MUX_CONTROL_3
0515 A295       423       mov c, PB_INPUT_PIN
0517 920D       424       mov PB3, c
0519 D283       425       setb MUX_CONTROL_3
051B            426   
051B            427       ; Check PB2
051B C282       428       clr MUX_CONTROL_2
051D A295       429       mov c, PB_INPUT_PIN
051F 920C       430       mov PB2, c
0521 D282       431       setb MUX_CONTROL_2
0523            432   
0523            433       ; Check PB1
0523 C281       434       clr MUX_CONTROL_1
0525 A295       435       mov c, PB_INPUT_PIN
0527 920B       436       mov PB1, c
0529 D281       437       setb MUX_CONTROL_1
052B            438   
052B            439       ; Check PB0
052B C280       440       clr MUX_CONTROL_0
052D A295       441       mov c, PB_INPUT_PIN
052F 920A       442       mov PB0, c
0531 D280       443       setb MUX_CONTROL_0
0533            444   
0533            445   LCD_PB_Done:
0533 22         446       ret
0534            447   
0534            448   ;----------------------------------------------------------------------
0534            449   ; Display_formated_BCD: Display the result with decimal
0534            450   ;----------------------------------------------------------------------
0534            451   Display_formated_BCD:
0534 C0E0       452            push acc
0536 7401       452            mov a, #1
0538 14         452            dec a
0539 1200DB     452            lcall ?Set_Cursor_2 ; Select column and row
053C D0E0       452            pop acc
053E C000       453            push ar0
0540 A83A       453            mov r0, bcd+2
0542 1200E2     453            lcall ?Display_BCD
0545 D000       453            pop ar0
0547 C000       454            push ar0
0549 A839       454            mov r0, bcd+1
054B 1200E2     454            lcall ?Display_BCD
054E D000       454            pop ar0
0550 C0E0       455            push acc
0552 742E       455            mov a, #'.'
0554 120093     455            lcall ?WriteData
0557 D0E0       455            pop acc
0559 C000       456            push ar0
055B A838       456            mov r0, bcd+0
055D 1200E2     456            lcall ?Display_BCD
0560 D000       456            pop ar0
0562 C0E0       457            push acc
0564 74DF       457            mov a, #0xDF
0566 120093     457            lcall ?WriteData
0569 D0E0       457            pop acc    ; Degree symbol
056B C0E0       458            push acc
056D 7443       458            mov a, #'C'
056F 120093     458            lcall ?WriteData
0572 D0E0       458            pop acc
0574 C0E0       459            push acc
0576 7401       459            mov a, #1
0578 14         459            dec a
0579 1200DB     459            lcall ?Set_Cursor_2 ; Select column and row
057C D0E0       459            pop acc
057E C0E0       460            push acc
0580 7420       460            mov a, #' '
0582 120093     460            lcall ?WriteData
0585 D0E0       460            pop acc
0587 22         461       ret
0588            462   
0588            463   ;----------------------------------------------------------------------
0588            464   ; Read_ADC: reads current ADC channel into R0:R1 (12-bit)
0588            465   ;----------------------------------------------------------------------
0588            466   Read_ADC:
0588 C2EF       467       clr  ADCF
058A D2EE       468       setb ADCS
058C 30EFFD     469       jnb  ADCF, $          ; Wait conversion
058F E5C2       470       mov  a, ADCRL
0591 540F       471       anl  a, #0x0F
0593 F8         472       mov  R0, a
0594 E5C3       473       mov  a, ADCRH
0596 C4         474       swap a
0597 C0E0       475       push acc
0599 540F       476       anl  a, #0x0F
059B F9         477       mov  R1, a
059C D0E0       478       pop  acc
059E 54F0       479       anl  a, #0xF0
05A0 48         480       orl  a, R0
05A1 F8         481       mov  R0, a
05A2 22         482       ret
05A3            483   
05A3            484   ;----------------------------------------------------------------------
05A3            485   ; New code for push-button-based FSM parameter updates
05A3            486   ; We intercept button presses in SendSerial
05A3            487   ;----------------------------------------------------------------------
05A3            488   SendBCD:
05A3            489   
05A3 E53A       490            mov a, bcd+2
05A5 540F       491            anl a, #0x0F ; Isolate ones place
05A7 2430       492            add a, #'0' ; Convert value to ASCII
05A9 1205FE     493            lcall SendSerial
05AC            494   
05AC E539       495            mov a, bcd+1
05AE 54F0       496            anl a, #0xF0 ; Isolate tens place
05B0 C4         497            swap a ; Put high nibble into lower nibble
05B1 2430       498            add a, #'0' ; Convert value to ASCII
05B3 1205FE     499            lcall SendSerial
05B6            500   
05B6 E539       501            mov a, bcd+1
05B8 540F       502            anl a, #0x0F ; Isolate ones place
05BA 2430       503            add a, #'0' ; Convert value to ASCII
05BC 1205FE     504            lcall SendSerial
05BF            505   
05BF 742E       506            mov a, #'.'
05C1 1205FE     507            lcall SendSerial
05C4            508   
05C4 E538       509            mov a, bcd+0
05C6 54F0       510            anl a, #0xF0 ; Isolate 0.1 place
05C8 C4         511            swap a ; Put high nibble into lower nibble
05C9 2430       512            add a, #'0' ; Convert value to ASCII
05CB 1205FE     513            lcall SendSerial
05CE            514   
05CE E538       515            mov a, bcd+0
05D0 540F       516            anl a, #0x0F ; Isolate 0.01 place
05D2 2430       517            add a, #'0' ; Convert value to ASCII
05D4 1205FE     518            lcall SendSerial
05D7            519   
05D7 7420       520       mov a, #' '
05D9 1205FE     521       lcall SendSerial
05DC            522   
05DC 7400       523       mov a, #0
05DE A205       524       mov c, temp_state1
05E0 92E0       525       mov acc.0, c
05E2 2430       526       add a, #'0'
05E4 1205FE     527       lcall SendSerial
05E7            528       
05E7 7420       529       mov a, #' '
05E9 1205FE     530       lcall SendSerial
05EC            531       
05EC E53F       532       mov a, state
05EE 2430       533       add a, #'0'
05F0 1205FE     534       lcall SendSerial
05F3            535   
05F3 740A       536            mov a, #'\n'
05F5 1205FE     537            lcall SendSerial
05F8            538   
05F8 740D       539            mov a, #'\r'
05FA 1205FE     540            lcall SendSerial
05FD            541   
05FD 22         542            ret
05FE            543   
05FE            544   
05FE            545   SendSerial:
05FE            546       ; Simulate sending 'a' to UART
05FE C299       547       clr  TI
0600 F599       548       mov  SBUF, a
0602            549       ; Wait for TX
0602            550   WaitTx:
0602 3099FD     551       jnb TI, WaitTx
0605 C299       552       clr TI
0607            553   
0607            554       ; Now check buttons each time we "send":
0607            555       ; If button is pressed (bit=0), jump to its handler.
0607 300A0A     556       jnb PB0, start_oven
060A 300B0D     557       jnb PB1, toggle_state
060D 300C18     558       jnb PB2, inc_value
0610 300D37     559       jnb PB3, dec_value
0613            560       ; PB4 is unused for now, do nothing if pressed.
0613            561   
0613 22         562       ret
0614            563   
0614            564   ; Start the FSM
0614            565   start_oven:
0614            566       ;setb start                                  ; set the flag to 1, indicating that the FSM should begin
0614 753F01     567       mov state, #1                                ; return to main or update display as needed
0617 020670     568       ljmp end_button_logic           ; jump to exit logic
061A            569   
061A            570   ; Toggle which parameter is selected (1..4)
061A            571   toggle_state:
061A E55F       572       mov a, selected_state           ; load the selected state to the accumulator
061C 2401       573       add a, #1                       ; icnrement the selection
061E B40502     574       cjne a, #5, noWrap              ; if not greater than 4, jump to noWrap
0621 7401       575       mov a, #1                       ; if (selected_state == 5), reset the selected state, i.e. selected_state == 1
0623            576   noWrap:
0623 F55F       577       mov selected_state, a           ; store the updated selected_state
0625 020670     578       ljmp end_button_logic           ; jump to exit logic
0628            579   
0628            580   ; Increment whichever parameter is selected
0628            581   ; ** DOUBLE CHECK THIS LOGIC IM NOT TOO SURE **
0628            582   inc_value:
0628 E55F       583       mov a, selected_state           ; load the selected state into the accumulator
062A B40105     584       cjne a, #1, checkState2         ; if selected_state != temp_soak, check the next selected state
062D 0564       585       inc temp_soak                   ; increment temp_soak if above condition not true
062F 020670     586       ljmp end_button_logic           ; jump to exit logic
0632            587   
0632            588   checkState2:                    
0632 B40205     589       cjne a, #2, checkState3         ; if not time_soak, check the next parameter
0635 0565       590       inc time_soak                   ; increment time_soak
0637 020670     591       ljmp end_button_logic           ; jump to exit logic
063A            592   
063A            593   checkState3:
063A B40305     594       cjne a, #3, checkState4         ; if not temp_refl, check next parameter
063D 0566       595       inc temp_refl                   ; increment temp_refl
063F 020670     596       ljmp end_button_logic           ; jump to exit logic
0642            597   
0642            598   checkState4:                        
0642 B4042B     599       cjne a, #4, end_button_logic    ; if not time_refl, exit 
0645 0567       600       inc time_refl                   ; inc time_refl
0647 020670     601       ljmp end_button_logic           ; jump to exit logic
064A            602   
064A            603   ; Decrement whichever parameter is selected
064A            604   ; ** SAME IDEA BUT CHECK THE LOGIC PLEASE ** 
064A            605   dec_value:
064A E55F       606       mov a, selected_state
064C B40106     607       cjne a, #1, dcheckState2
064F D5641E     608       djnz temp_soak, end_button_logic
0652 020670     609       ljmp end_button_logic
0655            610   
0655            611   dcheckState2:
0655 B40206     612       cjne a, #2, dcheckState3
0658 D56515     613       djnz time_soak, end_button_logic
065B 020670     614       ljmp end_button_logic
065E            615   
065E            616   dcheckState3:
065E B40306     617       cjne a, #3, dcheckState4
0661 D5660C     618       djnz temp_refl, end_button_logic
0664 020670     619       ljmp end_button_logic
0667            620   
0667            621   dcheckState4:
0667 B40406     622       cjne a, #4, end_button_logic
066A D56703     623       djnz time_refl, end_button_logic
066D 020670     624       ljmp end_button_logic
0670            625   
0670            626   end_button_logic:
0670 22         627       ret
0671            628   
0671            629   ;----------------------------------------------------------------------
0671            630   ; main
0671            631   ;----------------------------------------------------------------------
0671            632   main:
0671 75817F     633       mov sp, #0x7F
0674 12047D     634       lcall Init_All
0677 12009D     635       lcall LCD_4BIT
067A            636   
067A 754601     637       mov MeasurementCounter+0, #1
067D 754700     638       mov MeasurementCounter+1, #0
0680 754A01     639       mov TimePerSample, #1
0683            640   
0683 75482C     641       mov SamplesPerDisplay+0, #low(SAMPLES_PER_DISPLAY)
0686 754901     642       mov SamplesPerDisplay+1, #high(SAMPLES_PER_DISPLAY)
0689            643   
0689            644       ; We start with "state=0" (idle)
0689 753F00     645       mov state, #0
068C C204       646       clr start 
068E C201       647       clr m_flag
0690            648   
0690            649       ; Default setpoints
0690 756428     650       mov temp_soak, #40
0693 75653C     651       mov time_soak, #60
0696 7566DC     652       mov temp_refl, #220
0699 75672D     653       mov time_refl, #45
069C            654   
069C            655       ; Which parameter we are currently adjusting: 1=temp_soak,2=time_soak,3=temp_refl,4=time_refl
069C 755F01     656       mov selected_state, #1
069F            657   
069F 754B00     658       mov LastMeasurement+0, #0
06A2 754C00     659       mov LastMeasurement+1, #0
06A5 754D00     660       mov LastMeasurement+2, #0
06A8 754E00     661       mov LastMeasurement+3, #0
06AB            662       
06AB D205       663       setb temp_state1
06AD            664   
06AD            665       ; Show initial LCD message
06AD C0E0       666            push acc
06AF 7401       666            mov a, #1
06B1 14         666            dec a
06B2 1200DD     666            lcall ?Set_Cursor_1 ; Select column and row
06B5 D0E0       666            pop acc
06B7 C083       667            push dph
06B9 C082       667            push dpl
06BB C0E0       667            push acc
06BD 90002E     667            mov dptr, #test_message
06C0 1200D0     667            lcall ?Send_Constant_String
06C3 D0E0       667            pop acc
06C5 D082       667            pop dpl
06C7 D083       667            pop dph
06C9            668   
06C9            669   Forever:
06C9            670       ; Example read reference (AIN0)
06C9 53E8F0     671       anl  ADCCON0, #0xF0
06CC 43E800     672       orl  ADCCON0, #0x00 ; Channel0
06CF 120588     673       lcall Read_ADC
06D2 883D       674       mov  VAL_LM4040+0, R0
06D4 893E       675       mov  VAL_LM4040+1, R1
06D6            676   
06D6            677       ; Read LM335 on AIN7
06D6 53E8F0     678       anl  ADCCON0, #0xF0
06D9 43E807     679       orl  ADCCON0, #0x07
06DC 120588     680       lcall Read_ADC
06DF            681   
06DF            682       ; Convert to "voltage" in x
06DF 8830       683       mov  x+0, R0
06E1 8931       684       mov  x+1, R1
06E3 753200     685       mov  x+2, #0
06E6 753300     686       mov  x+3, #0
06E9 7534FF     687            mov y+0, #low (40959 % 0x10000) 
06EC 75359F     687            mov y+1, #high(40959 % 0x10000) 
06EF 753600     687            mov y+2, #low (40959 / 0x10000) 
06F2 753700     687            mov y+3, #high(40959 / 0x10000)        ; e.g. 4.0959 => times 10000 in math
06F5 120272     688       lcall mul32
06F8 853D34     689       mov  y+0, VAL_LM4040+0
06FB 853E35     690       mov  y+1, VAL_LM4040+1
06FE 753600     691       mov  y+2, #0
0701 753700     692       mov  y+3, #0
0704 1202FF     693       lcall div32
0707            694   
0707            695       ; Add partial result to StoreMeasurements
0707 854034     696       mov  y+0, StoreMeasurements+0
070A 854135     697       mov  y+1, StoreMeasurements+1
070D 854236     698       mov  y+2, StoreMeasurements+2
0710 854337     699       mov  y+3, StoreMeasurements+3
0713 1201BD     700       lcall add32
0716 853040     701       mov  StoreMeasurements+0, x+0
0719 853141     702       mov  StoreMeasurements+1, x+1
071C 853242     703       mov  StoreMeasurements+2, x+2
071F 853343     704       mov  StoreMeasurements+3, x+3
0722            705   
0722            706       ; Read thermocouple on AIN4
0722 53E8F0     707       anl  ADCCON0, #0xF0
0725 43E804     708       orl  ADCCON0, #0x04
0728 120588     709       lcall Read_ADC
072B            710   
072B 8830       711       mov  x+0, R0
072D 8931       712       mov  x+1, R1
072F 753200     713       mov  x+2, #0
0732 753300     714       mov  x+3, #0
0735 7534FF     715            mov y+0, #low (40959 % 0x10000) 
0738 75359F     715            mov y+1, #high(40959 % 0x10000) 
073B 753600     715            mov y+2, #low (40959 / 0x10000) 
073E 753700     715            mov y+3, #high(40959 / 0x10000) 
0741 120272     716       lcall mul32
0744 853D34     717       mov  y+0, VAL_LM4040+0
0747 853E35     718       mov  y+1, VAL_LM4040+1
074A 753600     719       mov  y+2, #0
074D 753700     720       mov  y+3, #0
0750 1202FF     721       lcall div32
0753            722   
0753            723       ; Add partial result to StoreThermocouple
0753 854F34     724       mov  y+0, StoreThermocouple+0
0756 855035     725       mov  y+1, StoreThermocouple+1
0759 855136     726       mov  y+2, StoreThermocouple+2
075C 855237     727       mov  y+3, StoreThermocouple+3
075F 1201BD     728       lcall add32
0762 85304F     729       mov  StoreThermocouple+0, x+0
0765 853150     730       mov  StoreThermocouple+1, x+1
0768 853251     731       mov  StoreThermocouple+2, x+2
076B 853352     732       mov  StoreThermocouple+3, x+3
076E            733   
076E            734       ; Delay between samples
076E AA4A       735       mov R2, TimePerSample
0770 1204DA     736       lcall waitms
0773            737   
0773            738       ; Decrement measurement counter
0773 1546       739       dec MeasurementCounter+0
0775 E546       740       mov a, MeasurementCounter+0
0777 B4FF02     741       cjne a, #0xFF, CheckHigh
077A 1547       742       dec MeasurementCounter+1
077C            743   CheckHigh:
077C E546       744       mov a, MeasurementCounter+0
077E 4547       745       orl a, MeasurementCounter+1
0780 6003       746       jz  DisplayValue
0782 0208C8     747       ljmp EndForever
0785            748   
0785            749   ;----------------------------------------------------------------------
0785            750   ; If enough measurements collected -> compute final temperature
0785            751   ;----------------------------------------------------------------------
0785            752   DisplayValue:
0785 753400     753            mov y+0, #low (0 % 0x10000) 
0788 753500     753            mov y+1, #high(0 % 0x10000) 
078B 753600     753            mov y+2, #low (0 / 0x10000) 
078E 753700     753            mov y+3, #high(0 / 0x10000) 
0791            754       ; Combine for LM335 reading
0791 854030     755       mov x+0, StoreMeasurements+0
0794 854131     756       mov x+1, StoreMeasurements+1
0797 854232     757       mov x+2, StoreMeasurements+2
079A 854333     758       mov x+3, StoreMeasurements+3
079D E548       759       mov a, SamplesPerDisplay+0
079F F534       760       mov y+0, a
07A1 F546       761       mov MeasurementCounter+0, a
07A3 E549       762       mov a, SamplesPerDisplay+1
07A5 F535       763       mov y+1, a
07A7 F547       764       mov MeasurementCounter+1, a
07A9 1202FF     765       lcall div32
07AC            766   
07AC            767       ; Subtract 273.00 => Celsius reading
07AC 7534A4     768            mov y+0, #low (27300 % 0x10000) 
07AF 75356A     768            mov y+1, #high(27300 % 0x10000) 
07B2 753600     768            mov y+2, #low (27300 / 0x10000) 
07B5 753700     768            mov y+3, #high(27300 / 0x10000) 
07B8 1201DE     769       lcall sub32
07BB 853057     770       mov FinalLM335+0, x+0
07BE 853158     771       mov FinalLM335+1, x+1
07C1 853259     772       mov FinalLM335+2, x+2
07C4 85335A     773       mov FinalLM335+3, x+3
07C7            774   
07C7            775       ; Combine for thermocouple reading
07C7 753400     776            mov y+0, #low (0 % 0x10000) 
07CA 753500     776            mov y+1, #high(0 % 0x10000) 
07CD 753600     776            mov y+2, #low (0 / 0x10000) 
07D0 753700     776            mov y+3, #high(0 / 0x10000) 
07D3 854F30     777       mov x+0, StoreThermocouple+0
07D6 855031     778       mov x+1, StoreThermocouple+1
07D9 855132     779       mov x+2, StoreThermocouple+2
07DC 855233     780       mov x+3, StoreThermocouple+3
07DF E548       781       mov a, SamplesPerDisplay+0
07E1 F534       782       mov y+0, a
07E3 E549       783       mov a, SamplesPerDisplay+1
07E5 F535       784       mov y+1, a
07E7 1202FF     785       lcall div32
07EA            786   
07EA            787       ; Add thermocouple to LM335 reading => final in x
07EA 753400     788            mov y+0, #low (0 % 0x10000) 
07ED 753500     788            mov y+1, #high(0 % 0x10000) 
07F0 753600     788            mov y+2, #low (0 / 0x10000) 
07F3 753700     788            mov y+3, #high(0 / 0x10000) 
07F6 855734     789       mov y+0, FinalLM335+0
07F9 855835     790       mov y+1, FinalLM335+1
07FC 855936     791       mov y+2, FinalLM335+2
07FF 855A37     792       mov y+3, FinalLM335+3
0802 1201BD     793       lcall add32
0805            794   
0805 85305B     795       mov FinalTemp+0, x+0
0808 85315C     796       mov FinalTemp+1, x+1
080B 85325D     797       mov FinalTemp+2, x+2
080E 85335E     798       mov FinalTemp+3, x+3
0811            799   
0811            800       ; --------------------------------------------------------
0811            801       ; Compare final temperature with soak/reflow setpoints
0811            802       ; --------------------------------------------------------
0811 753464     803            mov y+0, #low (100 % 0x10000) 
0814 753500     803            mov y+1, #high(100 % 0x10000) 
0817 753600     803            mov y+2, #low (100 / 0x10000) 
081A 753700     803            mov y+3, #high(100 / 0x10000) 
081D 856430     804       mov x+0, temp_soak
0820 753100     805       mov x+1, #0
0823 753200     806       mov x+2, #0
0826 753300     807       mov x+3, #0
0829 120272     808       lcall mul32
082C 855B34     809       mov y+0, FinalTemp+0
082F 855C35     810       mov y+1, FinalTemp+1
0832 855D36     811       mov y+2, FinalTemp+2
0835 855E37     812       mov y+3, FinalTemp+3
0838 12025E     813       lcall x_gteq_y
083B 850005     814       mov temp_state1, mf
083E            815   
083E 753464     816            mov y+0, #low (100 % 0x10000) 
0841 753500     816            mov y+1, #high(100 % 0x10000) 
0844 753600     816            mov y+2, #low (100 / 0x10000) 
0847 753700     816            mov y+3, #high(100 / 0x10000) 
084A 856630     817       mov x+0, temp_refl
084D 753100     818       mov x+1, #0
0850 753200     819       mov x+2, #0
0853 753300     820       mov x+3, #0
0856 120272     821       lcall mul32
0859 855B34     822       mov y+0, FinalTemp+0
085C 855C35     823       mov y+1, FinalTemp+1
085F 855D36     824       mov y+2, FinalTemp+2
0862 855E37     825       mov y+3, FinalTemp+3
0865 12025E     826       lcall x_gteq_y
0868 850007     827       mov temp_state3, mf
086B            828   
086B            829       ; Check error states
086B 855B30     830       mov x+0, FinalTemp+0
086E 855C31     831       mov x+1, FinalTemp+1
0871 855D32     832       mov x+2, FinalTemp+2
0874 855E33     833       mov x+3, FinalTemp+3
0877            834   
0877 7534A8     835            mov y+0, #low (25000 % 0x10000) 
087A 753561     835            mov y+1, #high(25000 % 0x10000) 
087D 753600     835            mov y+2, #low (25000 / 0x10000) 
0880 753700     835            mov y+3, #high(25000 / 0x10000) 
0883 12025E     836       lcall x_gteq_y
0886 850003     837       mov err_tmp_150, mf
0889            838   
0889 753488     839            mov y+0, #low (5000 % 0x10000) 
088C 753513     839            mov y+1, #high(5000 % 0x10000) 
088F 753600     839            mov y+2, #low (5000 / 0x10000) 
0892 753700     839            mov y+3, #high(5000 / 0x10000) 
0895 12025E     840       lcall x_gteq_y
0898 850002     841       mov err_tmp, mf
089B            842   
089B            843       ; Convert FinalTemp => BCD => display
089B 1200F8     844       lcall hex2bcd
089E 120534     845       lcall Display_formated_BCD
08A1 1205A3     846       lcall SendBCD
08A4            847   
08A4            848       ; Reset accumulators
08A4 754000     849       mov StoreMeasurements+0, #0
08A7 754100     850       mov StoreMeasurements+1, #0
08AA 754200     851       mov StoreMeasurements+2, #0
08AD 754300     852       mov StoreMeasurements+3, #0
08B0 754F00     853       mov StoreThermocouple+0, #0
08B3 755000     854       mov StoreThermocouple+1, #0
08B6 755100     855       mov StoreThermocouple+2, #0
08B9 755200     856       mov StoreThermocouple+3, #0
08BC 755700     857       mov FinalLM335+0, #0
08BF 755801     858       mov FinalLM335+1, #1
08C2 755902     859       mov FinalLM335+2, #2
08C5 755A03     860       mov FinalLM335+3, #3
08C8            861   
08C8            862   EndForever:
08C8            863       ; Always read the push buttons each pass
08C8 1204E0     864       lcall LCD_PB
08CB            865   
08CB            866   
08CB 753000     867       mov x+0, #0
08CE 753100     868       mov x+1, #0
08D1 753200     869       mov x+2, #0
08D4 753300     870       mov x+3, #0
08D7 0206C9     871       ljmp Forever
08DA            872   
08DA            873   END
