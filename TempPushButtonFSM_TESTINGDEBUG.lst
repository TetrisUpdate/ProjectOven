0000              1   ;----------------------------------------------------------------------
0000              2   ; 76E003 ADC test program (reflow oven controller + push buttons)
0000              3   ; Reads channel 7 on P1.1, pin 14
0000              4   ; This version uses the LM4040 voltage reference connected to pin 6 (P1.7/AIN0)
0000              5   ; Incorporates push-button control to set up times/temperatures and start FSM.
0000              6   ;----------------------------------------------------------------------
0000              7   
                  9   $LIST
0000             11   
0000             12   ;  N76E003 pinout:
0000             13   ;                               -------
0000             14   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             15   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             16   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             17   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             18   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             19   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             20   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             21   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             22   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             23   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             24   ;                               -------
0000             25   ;
0000             26   
0000             27   ;----------------------------------------------------------------------
0000             28   ; System/Timer/Constants
0000             29   ;----------------------------------------------------------------------
0000             30   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             31   BAUD              EQU 115200   ; Baud rate of UART in bps
0000             32   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             33   
0000             34   TIMER2_RATE       EQU 100      ; 100 Hz -> 10ms tick
0000             35   TIMER2_RELOAD     EQU ((65536-(CLK/(16*TIMER2_RATE))))
0000             36   
0000             37   TIMER0_RATE          EQU 2250
0000             38   TIMER0_RELOAD        EQU (0x10000-(CLK/TIMER0_RATE))
0000             39   
0000             40   SAMPLES_PER_DISPLAY EQU 150
0000             41   REFRESHES_PER_SECOND EQU 15
0000             42   
0000             43   ORG 0x0000
0000 020906      44       ljmp main
0003             45   
0003             46   ; Timer/Counter 0 overflow interrupt vector
000B             47   org 0x000B
000B 0203A8      48            ljmp Timer0_ISR
000E             49   
000E             50   ; Timer/Counter 2 overflow interrupt vector
002B             51   org 0x002B
002B 0203DB      52       ljmp Timer2_ISR
002E             53   
002E             54   ;----------------------------------------------------------------------
002E             55   ; Hardware Pin Definitions
002E             56   ;----------------------------------------------------------------------
002E             57   
002E             58   ; PUSH BUTTONS (single-pin read approach)
002E             59   PB_INPUT_PIN   EQU P1.5  ; The single pin used to read all 5 PBs
002E             60   MUX_CONTROL_0  EQU P1.3  
002E             61   MUX_CONTROL_1  EQU P0.0  
002E             62   MUX_CONTROL_2  EQU P0.1  
002E             63   MUX_CONTROL_3  EQU P0.2  
002E             64   MUX_CONTROL_4  EQU P0.3  
002E             65   SOUND_OUT      EQU P3.0
002E             66   
002E             67   ; LCD assignments
002E             68   LCD_RS  equ P1.3
002E             69   LCD_E   equ P1.4
002E             70   LCD_D4  equ P0.0
002E             71   LCD_D5  equ P0.1
002E             72   LCD_D6  equ P0.2
002E             73   LCD_D7  equ P0.3
002E             74   SSR_BOX equ P0.4
002E             75   
002E             76   ; Strings for LCD
002E 43757272    77   test_message:     db 'Current Temp.:', 0
     656E7420
     54656D70
     2E3A00
003D 4465672E    78   value_message:    db 'Deg. C', 0
     204300
0044             79   
0044 54656D70    80   temp_soak_string: db 'Temp Soak:    ', 0
     20536F61
     6B3A2020
     202000
0053 54696D65    81   time_soak_string: db 'Time Soak:    ', 0
     20536F61
     6B3A2020
     202000
0062 54656D70    82   temp_refl_string: db 'Temp Reflow: ', 0
     20526566
     6C6F773A
     2000
0070 54696D65    83   time_refl_string: db 'Time Reflow: ', 0
     20526566
     6C6F773A
     2000
007E             84   
007E 204300      85   degree_label: db ' C', 0
0081 207300      86   seconds_label: db ' s', 0
0084             87   
0084             88   
0084             89   cseg
0084             90   
                 92   	$LIST
0138             94   
0138             95   ;----------------------------------------------------------------------
0138             96   ; 32-bit math placeholders
0138             97   ;----------------------------------------------------------------------
0030             98   DSEG at 30H
0030             99   x:   ds 4
0034            100   y:   ds 4
0038            101   bcd: ds 5
003D            102   VAL_LM4040: ds 2
003F            103   
003F            104   ; Variables
003F            105   state:              ds 1
0040            106   StoreMeasurements:  ds 4
0044            107   Store:          ds 2
0046            108   MeasurementCounter: ds 2
0048            109   SamplesPerDisplay:  ds 2
004A            110   TimePerSample:      ds 1
004B            111   LastMeasurement:    ds 4
004F            112   StoreThermocouple:  ds 4
0053            113   CurrentTemp:        ds 4
0057            114   FinalLM335:         ds 4
005B            115   FinalTemp:          ds 4
005F            116   selected_state:          ds 1
0060            117   
0060            118   save_x:             ds 4
0064            119   
0064            120   Count1ms:      ds 2
0066            121   pwm_counter:   ds 1
0067            122   pwm:           ds 1
0068            123   
0068            124   debounce_count_0 :ds 1
0069            125   debounce_count_1 :ds 1
006A            126   debounce_count_2 :ds 1
006B            127   debounce_count_3 :ds 1
006C            128   debounce_count_4 :ds 1
006D            129   
006D            130   ; Oven settings
006D            131   temp_soak: ds 1  ; For state 1
006E            132   time_soak: ds 1  ; For state 2
006F            133   temp_refl: ds 1  ; For state 3
0070            134   time_refl: ds 1  ; For state 4
0071            135   
0071            136   seconds: ds 1
0072            137   state_sec: ds 1
0073            138   
0073            139   ;----------------------------------------------------------------------
0073            140   ; Bit variables (BSEG)
0073            141   ;----------------------------------------------------------------------
0000            142   BSEG
0000            143   mf:            dbit 1
0001            144   m_flag:        dbit 1
0002            145   s_flag:        dbit 1
0003            146   err_tmp:       dbit 1
0004            147   err_tmp_150:   dbit 1
0005            148   display_flag:  dbit 1
0006            149   
0006            150   inc_lock:      dbit 1
0007            151   
0007            152   start:         dbit 1  ; Start the FSM
0008            153   temp_state1:   dbit 1
0009            154   temp_state3:   dbit 1
000A            155   temp_state5:   dbit 1
000B            156   
000B            157   debug_bit:     dbit 1 ;Set to true to check which lines of code actually execute
000C            158   debug_bit1:    dbit 1
000D            159   kill_flag:      dbit 1 ; kill switch
000E            160   
000E            161   ; For push buttons
000E            162   PB0: dbit 1  ; Start/Pause
000F            163   PB1: dbit 1  ; Toggle selected parameter
0010            164   PB2: dbit 1  ; Increment
0011            165   PB3: dbit 1  ; Decrement
0012            166   PB4: dbit 1  ; Unused or extra
0013            167   
0013            168   PB0_db: dbit 1
0014            169   PB1_db: dbit 1
0015            170   PB2_db: dbit 1
0016            171   PB3_db: dbit 1
0017            172   PB4_db: dbit 1
0018            173   
0018            174   sound_flag: dbit 1
0019            175   
0019            176   ;SETATS
0019            177   
0019            178   ; We include math32 at the end of initialization
                546   $LIST
                180   $LIST
03A8            182   
03A8            183   ;----------------------------------------------------------------------
03A8            184   ; Timer2 Initialization & ISR
03A8            185   ;----------------------------------------------------------------------
03A8            186   
03A8            187   
03A8            188   
03A8            189   
03A8            190   
03A8            191   
03A8            192   Timer0_ISR:
03A8            193            ;clr TF0  ; According to the data sheet this is done for us already.
03A8            194            ; Timer 0 doesn't have 16-bit auto-reload, so
03A8 C28C       195            clr TR0
03AA 758CE3     196            mov TH0, #high(TIMER0_RELOAD) ;TH0 and TL0 are only 8 bits, so we need to load each half individually
03AD 758A2F     197            mov TL0, #low(TIMER0_RELOAD) ; For 0xF830 for example, #high gives 0xF8, #low gives #0x30
03B0 D28C       198            setb TR0 ; Start timer 0
03B2 201804     199            jb sound_flag, Timer0_ISR_Sound
03B5 C2B0       200            clr SOUND_OUT
03B7 8004       201            sjmp Timer0_ISR_Done
03B9            202   Timer0_ISR_Sound:
03B9 B2B0       203            cpl SOUND_OUT
03BB 8000       204            sjmp Timer0_ISR_Done
03BD            205   Timer0_ISR_Done:
03BD 32         206            reti
03BE            207   
03BE            208   
03BE            209   Timer2_Init:
03BE 75C800     210       mov T2CON, #0       ; Stop timer, mode = auto-reload
03C1 75CDD7     211       mov TH2, #high(TIMER2_RELOAD)
03C4 75CC79     212       mov TL2, #low(TIMER2_RELOAD)
03C7 43C9A0     213       orl T2MOD, #0b1010_0000    ; Enable auto-reload
03CA 75CBD7     214       mov RCMP2H, #high(TIMER2_RELOAD)
03CD 75CA79     215       mov RCMP2L, #low(TIMER2_RELOAD)
03D0 E4         216       clr  a
03D1 F564       217       mov  Count1ms+0, a
03D3 F565       218       mov  Count1ms+1, a
03D5 439B80     219       orl  EIE, #0x80     ; Enable timer2 interrupt (ET2=1)
03D8 D2CA       220       setb TR2            ; Start Timer2
03DA 22         221       ret
03DB            222   
03DB            223   Timer2_ISR:
03DB C2CF       224       clr TF2 ; Must clear TF2 manually on N76
03DD C0E0       225       push acc
03DF C0D0       226       push psw
03E1 853060     227       mov save_x+0, x+0
03E4 853161     228       mov save_x+1, x+1
03E7 853262     229       mov save_x+2, x+2
03EA 853363     230       mov save_x+3, x+3
03ED            231   
03ED            232       ;---------------------------------
03ED            233       ; PWM for SSR control
03ED            234       ;---------------------------------
03ED 0566       235       inc pwm_counter ;Every 10ms, pwm_counter is incremented
03EF C3         236       clr c
03F0 E567       237       mov a, pwm
03F2 9566       238       subb a, pwm_counter ; if pwm_counter <= pwm, c=1, so if pwm=20 for example, if 210ms has passed, c = 0, and the SSR box is always on
03F4            239       ;cpl c
03F4 9284       240       mov SSR_BOX, c
03F6            241       
03F6            242   CheckButton0:
03F6 200E0D     243       jb PB0, CheckButton1 ;Skip to CheckPWM if a button is not pushed
03F9 0568       244       inc debounce_count_0
03FB E568       245       mov a, debounce_count_0
03FD B40F06     246       cjne a, #15, CheckButton1
0400 C213       247            clr PB0_db
0402 756800     248       mov debounce_count_0, #0
0405 E4         249       clr a
0406            250   
0406            251   CheckButton1:
0406 200F0D     252       jb PB1, CheckButton2 ;Skip to CheckPWM if a button is not pushed
0409 0569       253       inc debounce_count_1
040B E569       254       mov a, debounce_count_1
040D B40F06     255       cjne a, #15, CheckButton2
0410 C214       256            clr PB1_db
0412 756900     257       mov debounce_count_1, #0
0415 E4         258       clr a
0416            259   
0416            260   CheckButton2:
0416 20100D     261       jb PB2, CheckButton3 ;Skip to CheckPWM if a button is not pushed
0419 056A       262       inc debounce_count_2
041B E56A       263       mov a, debounce_count_2
041D B40F06     264       cjne a, #15, CheckButton3
0420 C215       265            clr PB2_db
0422 756A00     266       mov debounce_count_2, #0
0425 E4         267       clr a
0426            268   
0426            269   CheckButton3:
0426 20110D     270       jb PB3, CheckButton4 ;Skip to CheckPWM if a button is not pushed
0429 056B       271       inc debounce_count_3
042B E56B       272       mov a, debounce_count_3
042D B40F06     273       cjne a, #15, CheckButton4
0430 C216       274            clr PB3_db
0432 756B00     275       mov debounce_count_3, #0
0435 E4         276       clr a
0436            277   
0436            278   CheckButton4:
0436 20120D     279       jb PB4, CheckPWM ;Skip to CheckPWM if a button is not pushed
0439 056C       280       inc debounce_count_4
043B E56C       281       mov a, debounce_count_4
043D B40F06     282       cjne a, #15, CheckPWM
0440 C217       283            clr PB4_db
0442 756C00     284       mov debounce_count_4, #0
0445 E4         285       clr a
0446            286   
0446            287   
0446            288   CheckPWM:
0446 E566       289       mov a, pwm_counter
0448 B4641F     290       cjne a, #100, State_0 ; If 1 second has not passed, skip to State_0
044B 756600     291       mov pwm_counter, #0 ; Reset pwm_counter
044E E53F       292       mov a, state
0450 B40003     293       cjne a, #0, SecondsLogic
0453 02046A     294       ljmp State_0
0456            295   
0456            296   
0456            297   SecondsLogic:
0456 0571       298       inc seconds ; Increment seconds
0458 0572       299       inc state_sec ; Will only increment in states 2 and 4, gets reset to 0 in all other states otherrwise
045A E4         300       clr a
045B E53F       301       mov a, state
045D B4010A     302       cjne a, #1, State_0
0460 E571       303       mov a, seconds
0462 B43C05     304       cjne a, #60, State_0 ;If exactly 60 seconds has not passed, skip to State_0, otherwise set m_flag to indicate a minute has passed
0465 D201       305       setb m_flag
0467 02046A     306       ljmp State_0
046A            307   
046A            308   
046A            309   State_0:
046A E53F       310       mov a, state
046C B40010     311            cjne a, #0, State_1
046F E4         312       clr a
0470 757200     313       mov state_sec, #0
0473 756700     314            mov pwm, #0
0476 30074C     315            jnb start, jumpy 
0479 753F01     316            mov state, #1
047C 020558     317            ljmp Display_1
047F            318            
047F            319   State_1:
047F 200D46     320       jb kill_flag, jumpyError
0482 E53F       321            mov a, state
0484 B40122     322            cjne a, #1, State_2
0487 757200     323            mov state_sec, #0
048A 756764     324            mov pwm, #100                                   ; set pwm for relfow oven to 100%
048D 20010F     325            jb m_flag, Cond_check
0490 D20C       326       setb debug_bit1
0492 300830     327            jnb temp_state1, jumpy          ; mf = 1 if oven temp <= set temp, jump out of ISR. mf = 0 if oven temp > set temp, thus move onto next state                   
0495 E4         328            clr a                                           
0496 753F02     329            mov state, #2
0499 757200     330       mov state_sec, #0
049C 0204A9     331            ljmp State_2
049F            332   
049F            333   Cond_check: ; cjne is not bit-addressable, therefore we must move bits into byte registers (i.e. accumulator and register b)
049F D20B       334            setb debug_bit
04A1 300327     335       jnb err_tmp, jumpyErrorKill
04A4 C201       336       clr m_flag
04A6 0204C5     337            ljmp jumpy
04A9            338   
04A9            339   
04A9            340   State_2: ;transition to state three if more than 60 seconds have passed
04A9 200D1C     341       jb kill_flag, jumpyError
04AC E53F       342            mov a, state
04AE B4021D     343            cjne a, #2, State_3
04B1 756714     344            mov pwm, #20
04B4 200414     345            jb err_tmp_150, jumpyErrorKill
04B7 E4         346       clr a        
04B8            347   
04B8            348       
04B8 E572       349       mov a, state_sec
04BA C3         350       clr c
04BB 956E       351       subb a, time_soak ; If state_sec - time_soak is negative (so not enough time has passed), then c = 1, 
04BD 4006       352       jc jumpy
04BF 753F03     353            mov state, #3
04C2 757200     354       mov state_sec, #0
04C5            355   
04C5            356   jumpy:
04C5 02054D     357       ljmp Display_0
04C8            358   jumpyError:
04C8 020528     359       ljmp State_error
04CB            360   jumpyErrorkill:
04CB 020522     361       ljmp State_error_kill
04CE            362   
04CE            363   
04CE            364   State_3: 
04CE 200D57     365       jb kill_flag, State_error
04D1 E53F       366            mov a, state
04D3 B40313     367            cjne a, #3, State_4 ; check if state = 3, if not, move to state_4
04D6 756764     368            mov pwm, #100 ; set pwm to 100%
04D9 757200     369       mov state_sec, #0
04DC 200443     370            jb err_tmp_150, State_error_kill
04DF            371            ;mov c, temp_state3
04DF            372            ;clr a                                                          ; clear the accumulator
04DF            373            ;mov acc.0, c
04DF            374            ;clr c                                                          ; clear the carry bit
04DF            375            ;cjne a, #0, Timer2_ISR_done ;
04DF 3009E3     376       jnb temp_state3, jumpy
04E2 E4         377            clr a
04E3 757200     378       mov state_sec, #0
04E6 753F04     379            mov state, #4
04E9            380   
04E9            381   State_4:
04E9 200D3C     382       jb kill_flag, State_error
04EC E53F       383            mov a, state
04EE B40413     384            cjne a, #4, State_5
04F1 756714     385            mov pwm, #20
04F4 20042B     386            jb err_tmp_150, State_error_kill
04F7 E4         387       clr a
04F8 E572       388       mov a, state_sec
04FA 9570       389       subb a, time_refl
04FC 40C7       390       jc jumpy    
04FE 753F05     391            mov state, #5
0501 757200     392       mov state_sec, #0
0504            393   
0504            394   State_5:
0504 200D21     395       jb kill_flag, State_error
0507 E53F       396            mov a, state
0509 B405B9     397            cjne a, #5, jumpy
050C 756700     398            mov pwm, #0
050F 757200     399       mov state_sec, #0
0512 20040D     400       jb err_tmp_150, State_error_kill
0515 300AAD     401       jnb temp_state5, jumpy
0518 753F00     402            mov state, #0
051B 757200     403       mov state_sec, #0
051E D218       404       setb sound_flag
0520 800C       405       sjmp State_end
0522            406   
0522            407   
0522            408   State_error_kill:
0522 7400       409            mov a, #0
0524 F53F       410            mov state, a
0526 8006       411       sjmp State_end
0528            412       
0528            413   State_error:
0528 7400       414            mov a, #0
052A F53F       415            mov state, a
052C 801F       416       sjmp Display_0
052E            417   
052E            418   State_end:
052E C3         419       clr c
052F A207       420       mov c, start
0531 E4         421       clr a
0532 92E0       422       mov acc.0, c
0534 F4         423       cpl a                                ; set the flag to 1, indicating that the FSM should begin
0535 A2E0       424       mov c, acc.0
0537 9207       425       mov start, c
0539 E4         426       clr a
053A C3         427       clr c
053B A20D       428       mov c, kill_flag
053D 92E0       429       mov acc.0, c
053F F4         430       cpl a                    ; compliment kill
0540 A2E0       431       mov c, acc.0 
0542 920D       432       mov kill_flag, c
0544 C201       433       clr m_flag
0546 757100     434       mov seconds, #0
0549 C218       435       clr sound_flag
054B 8000       436       sjmp Display_0
054D            437   
054D            438            ; probably should put branch for warning message here
054D            439   
054D            440   ; Second FSM for displaying values for each state
054D            441   
054D            442   Display_0: ; Displays state 0 - Oven On
054D 020558     443       ljmp Display_1 ;Temporary, test until we set up Display_0
0550 E55F       444       mov a, selected_state
0552 B40003     445       cjne a, #0, Display_1
0555 0206E7     446       ljmp Timer2_ISR_done
0558            447   
0558            448   Display_1: ; Displays state 1 - Soak Temp.
0558 E55F       449       mov a, selected_state
055A B40161     450       cjne a, #1, Display_2
055D 30055B     451       jnb display_flag, jumpyEnd
0560 C0E0       452            push acc
0562 7401       452            mov a, #1
0564 14         452            dec a
0565 12011D     452            lcall ?Set_Cursor_1 ; Select column and row
0568 D0E0       452            pop acc
056A C083       453            push dph
056C C082       453            push dpl
056E C0E0       453            push acc
0570 900044     453            mov dptr, #temp_soak_string
0573 120110     453            lcall ?Send_Constant_String
0576 D0E0       453            pop acc
0578 D082       453            pop dpl
057A D083       453            pop dph
057C C205       454       clr display_flag
057E 753000     455            mov x+0, #low (0 % 0x10000) 
0581 753100     455            mov x+1, #high(0 % 0x10000) 
0584 753200     455            mov x+2, #low (0 / 0x10000) 
0587 753300     455            mov x+3, #high(0 / 0x10000) 
058A 856D30     456       mov x+0, temp_soak
058D 120138     457       lcall hex2bcd
0590 C0E0       458            push acc
0592 7401       458            mov a, #1
0594 14         458            dec a
0595 12011B     458            lcall ?Set_Cursor_2 ; Select column and row
0598 D0E0       458            pop acc
059A C000       459            push ar0
059C A839       459            mov r0, bcd+1
059E 120122     459            lcall ?Display_BCD
05A1 D000       459            pop ar0
05A3 C000       460            push ar0
05A5 A838       460            mov r0, bcd+0
05A7 120122     460            lcall ?Display_BCD
05AA D000       460            pop ar0
05AC 753000     461            mov x+0, #low (0 % 0x10000) 
05AF 753100     461            mov x+1, #high(0 % 0x10000) 
05B2 753200     461            mov x+2, #low (0 / 0x10000) 
05B5 753300     461            mov x+3, #high(0 / 0x10000)  
05B8 0206E7     462       ljmp Timer2_ISR_done
05BB            463   
05BB            464   jumpyEnd:
05BB 0206E7     465       ljmp Timer2_ISR_done
05BE            466   
05BE            467   Display_2: ; Displays state 2 - Soak Time
05BE E55F       468       mov a, selected_state
05C0 B4025E     469       cjne a, #2, Display_3
05C3 3005F5     470       jnb display_flag, jumpyEnd
05C6 C0E0       471            push acc
05C8 7401       471            mov a, #1
05CA 14         471            dec a
05CB 12011D     471            lcall ?Set_Cursor_1 ; Select column and row
05CE D0E0       471            pop acc
05D0 C083       472            push dph
05D2 C082       472            push dpl
05D4 C0E0       472            push acc
05D6 900053     472            mov dptr, #time_soak_string
05D9 120110     472            lcall ?Send_Constant_String
05DC D0E0       472            pop acc
05DE D082       472            pop dpl
05E0 D083       472            pop dph
05E2 C205       473       clr display_flag
05E4 753000     474            mov x+0, #low (0 % 0x10000) 
05E7 753100     474            mov x+1, #high(0 % 0x10000) 
05EA 753200     474            mov x+2, #low (0 / 0x10000) 
05ED 753300     474            mov x+3, #high(0 / 0x10000) 
05F0 856E30     475       mov x+0, time_soak
05F3 120138     476       lcall hex2bcd
05F6 C0E0       477            push acc
05F8 7401       477            mov a, #1
05FA 14         477            dec a
05FB 12011B     477            lcall ?Set_Cursor_2 ; Select column and row
05FE D0E0       477            pop acc
0600 C000       478            push ar0
0602 A839       478            mov r0, bcd+1
0604 120122     478            lcall ?Display_BCD
0607 D000       478            pop ar0            ; x is 8 bits, we represent in hex as 0xFF, therefore FF is displayed
0609 C000       479            push ar0
060B A838       479            mov r0, bcd+0
060D 120122     479            lcall ?Display_BCD
0610 D000       479            pop ar0
0612 753000     480            mov x+0, #low (0 % 0x10000) 
0615 753100     480            mov x+1, #high(0 % 0x10000) 
0618 753200     480            mov x+2, #low (0 / 0x10000) 
061B 753300     480            mov x+3, #high(0 / 0x10000)  
061E 0206E7     481       ljmp Timer2_ISR_done
0621            482   
0621            483   
0621            484   
0621            485   Display_3: ; Displays state 3 - Reflow Temp.
0621 E55F       486       mov a, selected_state
0623 B4035E     487       cjne a, #3, Display_4
0626 300592     488       jnb display_flag, jumpyEnd
0629 C0E0       489            push acc
062B 7401       489            mov a, #1
062D 14         489            dec a
062E 12011D     489            lcall ?Set_Cursor_1 ; Select column and row
0631 D0E0       489            pop acc
0633 C083       490            push dph
0635 C082       490            push dpl
0637 C0E0       490            push acc
0639 900062     490            mov dptr, #temp_refl_string
063C 120110     490            lcall ?Send_Constant_String
063F D0E0       490            pop acc
0641 D082       490            pop dpl
0643 D083       490            pop dph
0645 C205       491       clr display_flag
0647 753000     492            mov x+0, #low (0 % 0x10000) 
064A 753100     492            mov x+1, #high(0 % 0x10000) 
064D 753200     492            mov x+2, #low (0 / 0x10000) 
0650 753300     492            mov x+3, #high(0 / 0x10000) 
0653 856F30     493       mov x+0, temp_refl
0656 120138     494       lcall hex2bcd
0659 C0E0       495            push acc
065B 7401       495            mov a, #1
065D 14         495            dec a
065E 12011B     495            lcall ?Set_Cursor_2 ; Select column and row
0661 D0E0       495            pop acc
0663 C000       496            push ar0
0665 A839       496            mov r0, bcd+1
0667 120122     496            lcall ?Display_BCD
066A D000       496            pop ar0
066C C000       497            push ar0
066E A838       497            mov r0, bcd+0
0670 120122     497            lcall ?Display_BCD
0673 D000       497            pop ar0
0675 753000     498            mov x+0, #low (0 % 0x10000) 
0678 753100     498            mov x+1, #high(0 % 0x10000) 
067B 753200     498            mov x+2, #low (0 / 0x10000) 
067E 753300     498            mov x+3, #high(0 / 0x10000)  
0681 0206E7     499       ljmp Timer2_ISR_done
0684            500       
0684            501   
0684            502   Display_4: ; Displays state 4 - Reflow Time
0684 E55F       503       mov a, selected_state
0686 B4045E     504       cjne a, #4, Timer2_ISR_Done
0689 30055B     505       jnb display_flag, Timer2_ISR_done
068C C0E0       506            push acc
068E 7401       506            mov a, #1
0690 14         506            dec a
0691 12011D     506            lcall ?Set_Cursor_1 ; Select column and row
0694 D0E0       506            pop acc
0696 C083       507            push dph
0698 C082       507            push dpl
069A C0E0       507            push acc
069C 900070     507            mov dptr, #time_refl_string
069F 120110     507            lcall ?Send_Constant_String
06A2 D0E0       507            pop acc
06A4 D082       507            pop dpl
06A6 D083       507            pop dph
06A8 C205       508       clr display_flag
06AA 753000     509            mov x+0, #low (0 % 0x10000) 
06AD 753100     509            mov x+1, #high(0 % 0x10000) 
06B0 753200     509            mov x+2, #low (0 / 0x10000) 
06B3 753300     509            mov x+3, #high(0 / 0x10000) 
06B6 857030     510       mov x+0, time_refl
06B9 120138     511       lcall hex2bcd
06BC C0E0       512            push acc
06BE 7401       512            mov a, #1
06C0 14         512            dec a
06C1 12011B     512            lcall ?Set_Cursor_2 ; Select column and row
06C4 D0E0       512            pop acc
06C6 C000       513            push ar0
06C8 A839       513            mov r0, bcd+1
06CA 120122     513            lcall ?Display_BCD
06CD D000       513            pop ar0            ; x is 8 bits, we represent in hex as 0xFF, therefore FF is displayed
06CF C000       514            push ar0
06D1 A838       514            mov r0, bcd+0
06D3 120122     514            lcall ?Display_BCD
06D6 D000       514            pop ar0
06D8 753000     515            mov x+0, #low (0 % 0x10000) 
06DB 753100     515            mov x+1, #high(0 % 0x10000) 
06DE 753200     515            mov x+2, #low (0 / 0x10000) 
06E1 753300     515            mov x+3, #high(0 / 0x10000)                
06E4 0206E7     516       ljmp Timer2_ISR_done
06E7            517       
06E7            518   
06E7            519   Timer2_ISR_done:
06E7 D0D0       520       pop psw
06E9 D0E0       521       pop acc
06EB 856030     522       mov x+0, save_x+0 
06EE 856131     523       mov x+1, save_x+1
06F1 856232     524       mov x+2, save_x+2
06F4 856333     525       mov x+3, save_x+3
06F7 32         526       reti
06F8            527   
06F8            528   ;----------------------------------------------------------------------
06F8            529   ; Initialization
06F8            530   ;----------------------------------------------------------------------
06F8            531   Init_All:
06F8            532       ; Configure all the pins for bidirectional I/O
06F8 75AC00     533       mov P3M1, #0x00
06FB 75AD00     534       mov P3M2, #0x00
06FE 75B300     535       mov P1M1, #0x00
0701 75B400     536       mov P1M2, #0x00
0704 75B100     537       mov P0M1, #0x00
0707 75B200     538       mov P0M2, #0x00
070A            539   
070A 1203BE     540       lcall Timer2_Init
070D            541   
070D            542       ; Timer1 for UART
070D 438E10     543       orl  CKCON, #0x10     ; Timer1 uses system clock
0710 438780     544       orl  PCON,  #0x80     ; SMOD=1 -> double baud
0713 759852     545       mov  SCON,  #0x52     ; UART mode 1, REN=1
0716 53C4DF     546       anl  T3CON, #0b11011111
0719 53890F     547       anl  TMOD,  #0x0F
071C 438920     548       orl  TMOD,  #0x20     ; Timer1 Mode2 (8-bit auto-reload)
071F 758DF7     549       mov  TH1, #TIMER1_RELOAD
0722 D28E       550       setb TR1
0724            551   
0724            552       ; Timer0 for waitms
0724 C28C       553       clr TR0
0726 438E08     554       orl CKCON, #0x08
0729 5389F0     555       anl TMOD,  #0xF0
072C 438901     556       orl TMOD,  #0x01      ; 16-bit mode
072F 758CE3     557       mov TH0, #high(TIMER0_RELOAD)
0732 758A2F     558       mov TL0, #low(TIMER0_RELOAD)
0735 D2A9       559       setb ET0 ; Enable timer 0  interrupt
0737 D28C       560       setb TR0 ; Start timer 0
0739            561       ; ADC pins: P1.1 (AIN7), P1.7 (AIN0)
0739 43B382     562       orl P1M1, #0b10000010 ; Set P1.1 & P1.7 as input
073C 53B47D     563       anl P1M2, #0b01111101
073F            564   
073F            565       ; Initialize ADC
073F 53E8F0     566       anl ADCCON0, #0xF0
0742 43E807     567       orl ADCCON0, #0x07    ; default to channel 7
0745 75F600     568       mov AINDIDS, #0x00    ; disable all digital inputs
0748 43F681     569       orl AINDIDS, #0b10000001 ; activate AIN0 and AIN7
074B 43E101     570       orl ADCCON1, #0x01    ; enable ADC
074E 22         571       ret
074F            572   
074F            573   ;----------------------------------------------------------------------
074F            574   ; Delay Routines
074F            575   ;----------------------------------------------------------------------
074F            576   wait_1ms:
074F C28C       577       clr TR0
0751 C28D       578       clr TF0
0753 758CE3     579       mov TH0, #high(TIMER0_RELOAD)
0756 758A2F     580       mov TL0, #low(TIMER0_RELOAD)
0759 D28C       581       setb TR0
075B 308DFD     582       jnb TF0, $
075E 22         583       ret
075F            584   
075F            585   ; Wait R2 milliseconds
075F            586   waitms:
075F 12074F     587       lcall wait_1ms
0762 DAFB       588       djnz R2, waitms
0764 22         589       ret
0765            590   
0765            591   ;----------------------------------------------------------------------
0765            592   ; LCD_PB: Read the 5 push buttons into PB0..PB4 bits
0765            593   ;----------------------------------------------------------------------
0765            594   LCD_PB:
0765            595       ; Default all PB bits to 1 (released)
0765 D20E       596       setb PB0 
0767 D20F       597       setb PB1
0769 D210       598       setb PB2
076B D211       599       setb PB3
076D D212       600       setb PB4
076F            601       ; The input pin is idle-high (pull-up)
076F D295       602       setb PB_INPUT_PIN
0771            603   
0771            604       ; Set MUX lines to 0 first
0771 C293       605       clr MUX_CONTROL_0
0773 C280       606       clr MUX_CONTROL_1
0775 C281       607       clr MUX_CONTROL_2
0777 C282       608       clr MUX_CONTROL_3
0779 C283       609       clr MUX_CONTROL_4
077B            610   
077B            611       ;---------------------------------
077B            612       ; Debouncing
077B            613       ;---------------------------------
077B            614   
077B            615       ; Now set all MUX lines = 1 to read them individually
077B D293       616       setb MUX_CONTROL_0
077D D280       617       setb MUX_CONTROL_1
077F D281       618       setb MUX_CONTROL_2
0781 D282       619       setb MUX_CONTROL_3
0783 D283       620       setb MUX_CONTROL_4
0785            621   
0785            622       ; Check PB4
0785 C283       623       clr MUX_CONTROL_4
0787 A295       624       mov c, PB_INPUT_PIN
0789 9212       625       mov PB4, c
078B D283       626       setb MUX_CONTROL_4
078D            627   
078D            628       ; Check PB3
078D C282       629       clr MUX_CONTROL_3
078F A295       630       mov c, PB_INPUT_PIN
0791 9211       631       mov PB3, c
0793 D282       632       setb MUX_CONTROL_3
0795            633   
0795            634       ; Check PB2
0795 C281       635       clr MUX_CONTROL_2
0797 A295       636       mov c, PB_INPUT_PIN
0799 9210       637       mov PB2, c
079B D281       638       setb MUX_CONTROL_2
079D            639   
079D            640       ; Check PB1
079D C280       641       clr MUX_CONTROL_1
079F A295       642       mov c, PB_INPUT_PIN
07A1 920F       643       mov PB1, c
07A3 D280       644       setb MUX_CONTROL_1
07A5            645   
07A5            646       ; Check PB0
07A5 C293       647       clr MUX_CONTROL_0
07A7 A295       648       mov c, PB_INPUT_PIN
07A9 920E       649       mov PB0, c
07AB D293       650       setb MUX_CONTROL_0
07AD            651   
07AD            652   
07AD            653   LCD_PB_Done:
07AD D293       654       setb LCD_RS
07AF D294       655       setb LCD_E
07B1 22         656       ret
07B2            657   
07B2            658   ;----------------------------------------------------------------------
07B2            659   ; Display_formated_BCD: Display the result with decimal
07B2            660   ;----------------------------------------------------------------------
07B2            661   Display_formated_BCD:
07B2 C0E0       662            push acc
07B4 7408       662            mov a, #8
07B6 14         662            dec a
07B7 12011B     662            lcall ?Set_Cursor_2 ; Select column and row
07BA D0E0       662            pop acc
07BC C000       663            push ar0
07BE A83A       663            mov r0, bcd+2
07C0 120122     663            lcall ?Display_BCD
07C3 D000       663            pop ar0
07C5 C000       664            push ar0
07C7 A839       664            mov r0, bcd+1
07C9 120122     664            lcall ?Display_BCD
07CC D000       664            pop ar0
07CE C0E0       665            push acc
07D0 742E       665            mov a, #'.'
07D2 1200D3     665            lcall ?WriteData
07D5 D0E0       665            pop acc
07D7 C000       666            push ar0
07D9 A838       666            mov r0, bcd+0
07DB 120122     666            lcall ?Display_BCD
07DE D000       666            pop ar0
07E0 C0E0       667            push acc
07E2 74DF       667            mov a, #0xDF
07E4 1200D3     667            lcall ?WriteData
07E7 D0E0       667            pop acc    ; Degree symbol
07E9 C0E0       668            push acc
07EB 7443       668            mov a, #'C'
07ED 1200D3     668            lcall ?WriteData
07F0 D0E0       668            pop acc
07F2 C0E0       669            push acc
07F4 7408       669            mov a, #8
07F6 14         669            dec a
07F7 12011B     669            lcall ?Set_Cursor_2 ; Select column and row
07FA D0E0       669            pop acc
07FC C0E0       670            push acc
07FE 7420       670            mov a, #' '
0800 1200D3     670            lcall ?WriteData
0803 D0E0       670            pop acc
0805 C0E0       671            push acc
0807 740F       671            mov a, #15
0809 14         671            dec a
080A 12011D     671            lcall ?Set_Cursor_1 ; Select column and row
080D D0E0       671            pop acc
080F C000       672            push ar0
0811 A83F       672            mov r0, state
0813 120122     672            lcall ?Display_BCD
0816 D000       672            pop ar0
0818 22         673       ret
0819            674   
0819            675   ;----------------------------------------------------------------------
0819            676   ; Read_ADC: reads current ADC channel into R0:R1 (12-bit)
0819            677   ;----------------------------------------------------------------------
0819            678   Read_ADC:
0819 C2EF       679       clr  ADCF
081B D2EE       680       setb ADCS
081D 30EFFD     681       jnb  ADCF, $          ; Wait conversion
0820 E5C2       682       mov  a, ADCRL
0822 540F       683       anl  a, #0x0F
0824 F8         684       mov  R0, a
0825 E5C3       685       mov  a, ADCRH
0827 C4         686       swap a
0828 C0E0       687       push acc
082A 540F       688       anl  a, #0x0F
082C F9         689       mov  R1, a
082D D0E0       690       pop  acc
082F 54F0       691       anl  a, #0xF0
0831 48         692       orl  a, R0
0832 F8         693       mov  R0, a
0833 22         694       ret
0834            695   
0834            696   ;----------------------------------------------------------------------
0834            697   ; New code for push-button-based FSM parameter updates
0834            698   ; We intercept button presses in SendSerial
0834            699   ;----------------------------------------------------------------------
0834            700   SendBCD:
0834            701   
0834 E53A       702            mov a, bcd+2
0836 540F       703            anl a, #0x0F ; Isolate ones place
0838 2430       704            add a, #'0' ; Convert value to ASCII
083A 120873     705            lcall SendSerial
083D            706   
083D E539       707            mov a, bcd+1
083F 54F0       708            anl a, #0xF0 ; Isolate tens place
0841 C4         709            swap a ; Put high nibble into lower nibble
0842 2430       710            add a, #'0' ; Convert value to ASCII
0844 120873     711            lcall SendSerial
0847            712   
0847 E539       713            mov a, bcd+1
0849 540F       714            anl a, #0x0F ; Isolate ones place
084B 2430       715            add a, #'0' ; Convert value to ASCII
084D 120873     716            lcall SendSerial
0850            717   
0850 742E       718            mov a, #'.'
0852 120873     719            lcall SendSerial
0855            720   
0855 E538       721            mov a, bcd+0
0857 54F0       722            anl a, #0xF0 ; Isolate 0.1 place
0859 C4         723            swap a ; Put high nibble into lower nibble
085A 2430       724            add a, #'0' ; Convert value to ASCII
085C 120873     725            lcall SendSerial
085F            726   
085F E538       727            mov a, bcd+0
0861 540F       728            anl a, #0x0F ; Isolate 0.01 place
0863 2430       729            add a, #'0' ; Convert value to ASCII
0865 120873     730            lcall SendSerial
0868            731   
0868 740A       732            mov a, #'\n'
086A 120873     733            lcall SendSerial
086D            734   
086D 740D       735            mov a, #'\r'
086F 120873     736            lcall SendSerial
0872            737   
0872 22         738            ret
0873            739   
0873            740   SendSerial:
0873 C299       741            clr TI
0875 F599       742            mov SBUF, a
0877 3099FD     743            jnb TI, $
087A 22         744            ret
087B            745   
087B            746   button_logic:
087B 30130A     747       jnb PB0_db, start_oven
087E 301422     748       jnb PB1_db, toggle_state
0881 301531     749       jnb PB2_db, inc_value
0884 301654     750       jnb PB3_db, dec_value
0887            751       ; PB4 is unused for now, do nothing if pressed.
0887            752   
0887 22         753       ret
0888            754   
0888            755   ; Start the FSM
0888            756   start_oven:
0888 D213       757       setb PB0_db
088A C3         758            clr c
088B A207       759       mov c, start
088D E4         760       clr a
088E 92E0       761       mov acc.0, c
0890 F4         762       cpl a                                ; set the flag to 1, indicating that the FSM should begin
0891 A2E0       763       mov c, acc.0
0893 9207       764       mov start, c
0895 E4         765       clr a
0896 C3         766       clr c
0897 A20D       767       mov c, kill_flag
0899 92E0       768       mov acc.0, c
089B F4         769       cpl a                    ; compliment kill
089C A2E0       770       mov c, acc.0 
089E 920D       771       mov kill_flag, c
08A0            772       ;mov start, # 1                                ; return to main or update display as needed
08A0 020905     773       ljmp end_button_logic           ; jump to exit logic
08A3            774   
08A3            775   ; Toggle which parameter is selected (1..4)
08A3            776   toggle_state:
08A3 D205       777       setb display_flag
08A5 D214       778       setb PB1_db
08A7 E55F       779       mov a, selected_state           ; load the selected state to the accumulator
08A9 2401       780       add a, #1                       ; icnrement the selection
08AB B40502     781       cjne a, #5, noWrap              ; if not greater than 4, jump to noWrap
08AE 7401       782       mov a, #1                       ; if (selected_state == 5), reset the selected state, i.e. selected_state == 1
08B0            783   noWrap:
08B0 F55F       784       mov selected_state, a           ; store the updated selected_state
08B2 020905     785       ljmp end_button_logic           ; jump to exit logic
08B5            786   
08B5            787   ; Increment whichever parameter is selected
08B5            788   ; ** DOUBLE CHECK THIS LOGIC IM NOT TOO SURE **
08B5            789   inc_value:
08B5 D205       790       setb display_flag
08B7 D215       791       setb PB2_db
08B9 E55F       792       mov a, selected_state           ; load the selected state into the accumulator
08BB B40105     793       cjne a, #1, checkState2         ; if selected_state != temp_soak, check the next selected state
08BE 056D       794       inc temp_soak                   ; increment temp_soak if above condition not true
08C0 020905     795       ljmp end_button_logic           ; jump to exit logic
08C3            796   
08C3            797   checkState2:                    
08C3 B40205     798       cjne a, #2, checkState3         ; if not time_soak, check the next parameter
08C6 056E       799       inc time_soak                   ; increment time_soak
08C8 020905     800       ljmp end_button_logic           ; jump to exit logic
08CB            801   
08CB            802   checkState3:
08CB B40305     803       cjne a, #3, checkState4         ; if not temp_refl, check next parameter
08CE 056F       804       inc temp_refl                   ; increment temp_refl
08D0 020905     805       ljmp end_button_logic           ; jump to exit logic
08D3            806   
08D3            807   checkState4:                        
08D3 B4042F     808       cjne a, #4, end_button_logic    ; if not time_refl, exit 
08D6 0570       809       inc time_refl                   ; inc time_refl
08D8 020905     810       ljmp end_button_logic           ; jump to exit logic
08DB            811   
08DB            812   ; Decrement whichever parameter is selected
08DB            813   ; ** SAME IDEA BUT CHECK THE LOGIC PLEASE ** 
08DB            814   dec_value:
08DB D205       815       setb display_flag
08DD D216       816       setb PB3_db
08DF E55F       817       mov a, selected_state
08E1            818       
08E1 B40106     819       cjne a, #1, dcheckState2
08E4 D56D1E     820       djnz temp_soak, end_button_logic
08E7 020905     821       ljmp end_button_logic
08EA            822   
08EA            823   dcheckState2:
08EA B40206     824       cjne a, #2, dcheckState3
08ED D56E15     825       djnz time_soak, end_button_logic
08F0 020905     826       ljmp end_button_logic
08F3            827   
08F3            828   dcheckState3:
08F3 B40306     829       cjne a, #3, dcheckState4
08F6 D56F0C     830       djnz temp_refl, end_button_logic
08F9 020905     831       ljmp end_button_logic
08FC            832   
08FC            833   dcheckState4:
08FC B40406     834       cjne a, #4, end_button_logic
08FF D57003     835       djnz time_refl, end_button_logic
0902 020905     836       ljmp end_button_logic
0905            837   
0905            838   end_button_logic:
0905 22         839       ret
0906            840   
0906            841   
0906            842   ;----------------------------------------------------------------------
0906            843   ; main
0906            844   ;----------------------------------------------------------------------
0906            845   main:
0906 75817F     846       mov sp, #0x7F
0909 1206F8     847       lcall Init_All
090C 1200DD     848       lcall LCD_4BIT
090F 1203BE     849       lcall Timer2_Init ; initialize interupts 
0912 D2AF       850       setb EA
0914            851   
0914 C284       852       clr SSR_BOX
0916            853   
0916 754601     854       mov MeasurementCounter+0, #1
0919 754700     855       mov MeasurementCounter+1, #0
091C 754A02     856       mov TimePerSample, #2
091F            857   
091F 754896     858       mov SamplesPerDisplay+0, #low(SAMPLES_PER_DISPLAY)
0922 754900     859       mov SamplesPerDisplay+1, #high(SAMPLES_PER_DISPLAY)
0925            860   
0925            861       ; We start with "state=0" (idle)
0925 753F00     862       mov state, #0
0928 C207       863       clr start ; compliment in start_oven
092A C201       864       clr m_flag
092C D20D       865       setb kill_flag
092E            866   
092E            867       ; Default setpoints
092E 756D64     868       mov temp_soak, #100
0931 756E37     869       mov time_soak, #55
0934 756FD2     870       mov temp_refl, #210
0937 757028     871       mov time_refl, #40
093A            872   
093A            873       ; Which parameter we are currently adjusting: 1=temp_soak,2=time_soak,3=temp_refl,4=time_refl
093A 755F01     874       mov selected_state, #1
093D            875   
093D 754B00     876       mov LastMeasurement+0, #0
0940 754C00     877       mov LastMeasurement+1, #0
0943 754D00     878       mov LastMeasurement+2, #0
0946 754E00     879       mov LastMeasurement+3, #0
0949            880       
0949 C208       881       clr temp_state1
094B C209       882       clr temp_state3
094D C20B       883       clr debug_bit
094F C20C       884       clr debug_bit1
0951 C203       885       clr err_tmp
0953 C204       886       clr err_tmp_150
0955 D205       887       setb display_flag
0957 757100     888       mov seconds, #0
095A 757200     889       mov state_sec, #0
095D 756600     890       mov pwm_counter, #0
0960 756700     891       mov pwm, #0
0963 D213       892       setb PB0_db
0965 D214       893       setb PB1_db
0967 D215       894       setb PB2_db
0969 D216       895       setb PB3_db
096B D217       896       setb PB4_db
096D C218       897       clr sound_flag
096F            898       ; Show initial LCD message
096F            899       ;Set_Cursor(1, 1)
096F            900       ;Send_Constant_String(#test_message)
096F            901   
096F            902   Forever:
096F            903       ; Always read the push buttons each pass
096F 120765     904            lcall LCD_PB
0972 12087B     905            lcall button_logic
0975            906            
0975            907   
0975            908   SkipCheck:
0975            909       ; Example read reference (AIN0)
0975 53E8F0     910       anl  ADCCON0, #0xF0
0978 43E800     911       orl  ADCCON0, #0x00 ; Channel0
097B 120819     912       lcall Read_ADC
097E 883D       913       mov  VAL_LM4040+0, R0
0980 893E       914       mov  VAL_LM4040+1, R1
0982            915   
0982            916       ; Read LM335 on AIN7
0982 53E8F0     917       anl  ADCCON0, #0xF0
0985 43E807     918       orl  ADCCON0, #0x07
0988 120819     919       lcall Read_ADC
098B            920   
098B            921       ; Convert to "voltage" in x
098B 8830       922       mov  x+0, R0
098D 8931       923       mov  x+1, R1
098F 753200     924       mov  x+2, #0
0992 753300     925       mov  x+3, #0
0995 7534FF     926            mov y+0, #low (40959 % 0x10000) 
0998 75359F     926            mov y+1, #high(40959 % 0x10000) 
099B 753600     926            mov y+2, #low (40959 / 0x10000) 
099E 753700     926            mov y+3, #high(40959 / 0x10000)        ; e.g. 4.0959 => times 10000 in math
09A1 1202B2     927       lcall mul32
09A4 853D34     928       mov  y+0, VAL_LM4040+0
09A7 853E35     929       mov  y+1, VAL_LM4040+1
09AA 753600     930       mov  y+2, #0
09AD 753700     931       mov  y+3, #0
09B0 12033F     932       lcall div32
09B3            933   
09B3            934       ; Add partial result to StoreMeasurements
09B3 854034     935       mov  y+0, StoreMeasurements+0
09B6 854135     936       mov  y+1, StoreMeasurements+1
09B9 854236     937       mov  y+2, StoreMeasurements+2
09BC 854337     938       mov  y+3, StoreMeasurements+3
09BF 1201FD     939       lcall add32
09C2 853040     940       mov  StoreMeasurements+0, x+0
09C5 853141     941       mov  StoreMeasurements+1, x+1
09C8 853242     942       mov  StoreMeasurements+2, x+2
09CB 853343     943       mov  StoreMeasurements+3, x+3
09CE            944   
09CE            945       ; Read thermocouple on AIN4
09CE 53E8F0     946       anl  ADCCON0, #0xF0
09D1 43E804     947       orl  ADCCON0, #0x04
09D4 120819     948       lcall Read_ADC
09D7            949   
09D7 8830       950       mov  x+0, R0
09D9 8931       951       mov  x+1, R1
09DB 753200     952       mov  x+2, #0
09DE 753300     953       mov  x+3, #0
09E1 7534FF     954            mov y+0, #low (40959 % 0x10000) 
09E4 75359F     954            mov y+1, #high(40959 % 0x10000) 
09E7 753600     954            mov y+2, #low (40959 / 0x10000) 
09EA 753700     954            mov y+3, #high(40959 / 0x10000) 
09ED 1202B2     955       lcall mul32
09F0 853D34     956       mov  y+0, VAL_LM4040+0
09F3 853E35     957       mov  y+1, VAL_LM4040+1
09F6 753600     958       mov  y+2, #0
09F9 753700     959       mov  y+3, #0
09FC 12033F     960       lcall div32
09FF            961   
09FF 7534A3     962            mov y+0, #low (9635 % 0x10000) 
0A02 753525     962            mov y+1, #high(9635 % 0x10000) 
0A05 753600     962            mov y+2, #low (9635 / 0x10000) 
0A08 753700     962            mov y+3, #high(9635 / 0x10000) 
0A0B 1202B2     963       lcall mul32
0A0E            964   
0A0E 753410     965            mov y+0, #low (10000 % 0x10000) 
0A11 753527     965            mov y+1, #high(10000 % 0x10000) 
0A14 753600     965            mov y+2, #low (10000 / 0x10000) 
0A17 753700     965            mov y+3, #high(10000 / 0x10000) 
0A1A 12033F     966       lcall div32
0A1D            967   
0A1D            968       ; Add partial result to StoreThermocouple
0A1D 854F34     969       mov  y+0, StoreThermocouple+0
0A20 855035     970       mov  y+1, StoreThermocouple+1
0A23 855136     971       mov  y+2, StoreThermocouple+2
0A26 855237     972       mov  y+3, StoreThermocouple+3
0A29 1201FD     973       lcall add32
0A2C 85304F     974       mov  StoreThermocouple+0, x+0
0A2F 853150     975       mov  StoreThermocouple+1, x+1
0A32 853251     976       mov  StoreThermocouple+2, x+2
0A35 853352     977       mov  StoreThermocouple+3, x+3
0A38            978   
0A38            979       ; Delay between samples
0A38 AA4A       980       mov R2, TimePerSample
0A3A 12075F     981       lcall waitms
0A3D            982   
0A3D            983       ; Decrement measurement counter
0A3D 1546       984       dec MeasurementCounter+0
0A3F E546       985       mov a, MeasurementCounter+0
0A41 B4FF02     986       cjne a, #0xFF, CheckHigh
0A44 1547       987       dec MeasurementCounter+1
0A46            988   CheckHigh:
0A46 E546       989       mov a, MeasurementCounter+0
0A48 4547       990       orl a, MeasurementCounter+1
0A4A 6003       991       jz  DisplayValue
0A4C 020BB3     992       ljmp EndForever
0A4F            993   
0A4F            994   ;----------------------------------------------------------------------
0A4F            995   ; If enough measurements collected -> compute final temperature
0A4F            996   ;----------------------------------------------------------------------
0A4F            997   DisplayValue:
0A4F 753400     998            mov y+0, #low (0 % 0x10000) 
0A52 753500     998            mov y+1, #high(0 % 0x10000) 
0A55 753600     998            mov y+2, #low (0 / 0x10000) 
0A58 753700     998            mov y+3, #high(0 / 0x10000) 
0A5B            999       ; Combine for LM335 reading
0A5B 854030    1000       mov x+0, StoreMeasurements+0
0A5E 854131    1001       mov x+1, StoreMeasurements+1
0A61 854232    1002       mov x+2, StoreMeasurements+2
0A64 854333    1003       mov x+3, StoreMeasurements+3
0A67 E548      1004       mov a, SamplesPerDisplay+0
0A69 F534      1005       mov y+0, a
0A6B F546      1006       mov MeasurementCounter+0, a
0A6D E549      1007       mov a, SamplesPerDisplay+1
0A6F F535      1008       mov y+1, a
0A71 F547      1009       mov MeasurementCounter+1, a
0A73 12033F    1010       lcall div32
0A76           1011   
0A76           1012       ; Subtract 273.00 => Celsius reading
0A76 7534A4    1013            mov y+0, #low (27300 % 0x10000) 
0A79 75356A    1013            mov y+1, #high(27300 % 0x10000) 
0A7C 753600    1013            mov y+2, #low (27300 / 0x10000) 
0A7F 753700    1013            mov y+3, #high(27300 / 0x10000) 
0A82 12021E    1014       lcall sub32
0A85 853057    1015       mov FinalLM335+0, x+0
0A88 853158    1016       mov FinalLM335+1, x+1
0A8B 853259    1017       mov FinalLM335+2, x+2
0A8E 85335A    1018       mov FinalLM335+3, x+3
0A91           1019   
0A91           1020       ; Combine for thermocouple reading
0A91 753400    1021            mov y+0, #low (0 % 0x10000) 
0A94 753500    1021            mov y+1, #high(0 % 0x10000) 
0A97 753600    1021            mov y+2, #low (0 / 0x10000) 
0A9A 753700    1021            mov y+3, #high(0 / 0x10000) 
0A9D 854F30    1022       mov x+0, StoreThermocouple+0
0AA0 855031    1023       mov x+1, StoreThermocouple+1
0AA3 855132    1024       mov x+2, StoreThermocouple+2
0AA6 855233    1025       mov x+3, StoreThermocouple+3
0AA9 E548      1026       mov a, SamplesPerDisplay+0
0AAB F534      1027       mov y+0, a
0AAD E549      1028       mov a, SamplesPerDisplay+1
0AAF F535      1029       mov y+1, a
0AB1 12033F    1030       lcall div32
0AB4           1031   
0AB4           1032       ; Add thermocouple to LM335 reading => final in x
0AB4 753400    1033            mov y+0, #low (0 % 0x10000) 
0AB7 753500    1033            mov y+1, #high(0 % 0x10000) 
0ABA 753600    1033            mov y+2, #low (0 / 0x10000) 
0ABD 753700    1033            mov y+3, #high(0 / 0x10000) 
0AC0 855734    1034       mov y+0, FinalLM335+0
0AC3 855835    1035       mov y+1, FinalLM335+1
0AC6 855936    1036       mov y+2, FinalLM335+2
0AC9 855A37    1037       mov y+3, FinalLM335+3
0ACC 1201FD    1038       lcall add32
0ACF           1039   
0ACF 85305B    1040       mov FinalTemp+0, x+0
0AD2 85315C    1041       mov FinalTemp+1, x+1
0AD5 85325D    1042       mov FinalTemp+2, x+2
0AD8 85335E    1043       mov FinalTemp+3, x+3
0ADB           1044   
0ADB           1045       ; --------------------------------------------------------
0ADB           1046       ; Compare final temperature with soak/reflow setpoints
0ADB           1047       ; --------------------------------------------------------
0ADB C200      1048       clr mf
0ADD 753464    1049            mov y+0, #low (100 % 0x10000) 
0AE0 753500    1049            mov y+1, #high(100 % 0x10000) 
0AE3 753600    1049            mov y+2, #low (100 / 0x10000) 
0AE6 753700    1049            mov y+3, #high(100 / 0x10000) 
0AE9 856D30    1050       mov x+0, temp_soak
0AEC 753100    1051       mov x+1, #0
0AEF 753200    1052       mov x+2, #0
0AF2 753300    1053       mov x+3, #0
0AF5 1202B2    1054       lcall mul32
0AF8 855B34    1055       mov y+0, FinalTemp+0
0AFB 855C35    1056       mov y+1, FinalTemp+1
0AFE 855D36    1057       mov y+2, FinalTemp+2
0B01 855E37    1058       mov y+3, FinalTemp+3
0B04 1202A8    1059       lcall x_lteq_y ; mf = 1 if temp_soak<=FinalTemp
0B07 A200      1060       mov c, mf
0B09 9208      1061       mov temp_state1, c
0B0B           1062   
0B0B C200      1063       clr mf
0B0D 753464    1064            mov y+0, #low (100 % 0x10000) 
0B10 753500    1064            mov y+1, #high(100 % 0x10000) 
0B13 753600    1064            mov y+2, #low (100 / 0x10000) 
0B16 753700    1064            mov y+3, #high(100 / 0x10000) 
0B19 856F30    1065       mov x+0, temp_refl
0B1C 753100    1066       mov x+1, #0
0B1F 753200    1067       mov x+2, #0
0B22 753300    1068       mov x+3, #0
0B25 1202B2    1069       lcall mul32
0B28 855B34    1070       mov y+0, FinalTemp+0
0B2B 855C35    1071       mov y+1, FinalTemp+1
0B2E 855D36    1072       mov y+2, FinalTemp+2
0B31 855E37    1073       mov y+3, FinalTemp+3
0B34 1202A8    1074       lcall x_lteq_y ; mf = 1 if temp_refl<=FinalTemp
0B37 A200      1075       mov c, mf
0B39 9209      1076       mov temp_state3, c
0B3B           1077   
0B3B           1078       ; Check error states
0B3B 855B30    1079       mov x+0, FinalTemp+0
0B3E 855C31    1080       mov x+1, FinalTemp+1
0B41 855D32    1081       mov x+2, FinalTemp+2
0B44 855E33    1082       mov x+3, FinalTemp+3
0B47           1083   
0B47 C200      1084       clr mf
0B49 7534A8    1085            mov y+0, #low (25000 % 0x10000) 
0B4C 753561    1085            mov y+1, #high(25000 % 0x10000) 
0B4F 753600    1085            mov y+2, #low (25000 / 0x10000) 
0B52 753700    1085            mov y+3, #high(25000 / 0x10000) 
0B55 12029E    1086       lcall x_gteq_y ; mf = 1 if FinalTemp<=250
0B58 A200      1087       mov c, mf
0B5A 9204      1088       mov err_tmp_150, c
0B5C           1089   
0B5C C200      1090       clr mf
0B5E 753488    1091            mov y+0, #low (5000 % 0x10000) 
0B61 753513    1091            mov y+1, #high(5000 % 0x10000) 
0B64 753600    1091            mov y+2, #low (5000 / 0x10000) 
0B67 753700    1091            mov y+3, #high(5000 / 0x10000) 
0B6A 12029E    1092       lcall x_gteq_y ; mf = 1 if FinalTemp>=50
0B6D A200      1093       mov c, mf
0B6F 9203      1094       mov err_tmp, c
0B71           1095   
0B71 C200      1096       clr mf
0B73 7534B8    1097            mov y+0, #low (3000 % 0x10000) 
0B76 75350B    1097            mov y+1, #high(3000 % 0x10000) 
0B79 753600    1097            mov y+2, #low (3000 / 0x10000) 
0B7C 753700    1097            mov y+3, #high(3000 / 0x10000) 
0B7F 1202A8    1098       lcall x_lteq_y ; mf = 1 if FinalTemp<=60
0B82 A200      1099       mov c, mf
0B84 920A      1100       mov temp_state5, c
0B86           1101   
0B86           1102   
0B86           1103   
0B86           1104       ; Convert FinalTemp => BCD => display
0B86 120138    1105       lcall hex2bcd
0B89 120834    1106       lcall SendBCD
0B8C           1107       
0B8C           1108      ; jnb display_temp EndForever
0B8C 1207B2    1109       lcall Display_formated_BCD
0B8F           1110   
0B8F 754000    1111       mov StoreMeasurements+0, #0
0B92 754100    1112       mov StoreMeasurements+1, #0
0B95 754200    1113       mov StoreMeasurements+2, #0
0B98 754300    1114       mov StoreMeasurements+3, #0
0B9B           1115   
0B9B 754F00    1116       mov StoreThermocouple+0, #0
0B9E 755000    1117       mov StoreThermocouple+1, #0
0BA1 755100    1118       mov StoreThermocouple+2, #0
0BA4 755200    1119       mov StoreThermocouple+3, #0
0BA7           1120   
0BA7 755700    1121       mov FinalLM335+0, #0
0BAA 755801    1122       mov FinalLM335+1, #1
0BAD 755902    1123       mov FinalLM335+2, #2
0BB0 755A03    1124       mov FinalLM335+3, #3
0BB3           1125   
0BB3           1126   EndForever:
0BB3           1127       ; Always read the push buttons each pass
0BB3           1128       ;lcall LCD_PB
0BB3           1129       ; Reset accumulators
0BB3           1130   
0BB3 753000    1131       mov x+0, #0
0BB6 753100    1132       mov x+1, #0
0BB9 753200    1133       mov x+2, #0
0BBC 753300    1134       mov x+3, #0
0BBF 02096F    1135       ljmp Forever
0BC2           1136   
0BC2           1137   END
