0000              1   ;----------------------------------------------------------------------
0000              2   ; 76E003 ADC test program (reflow oven controller + push buttons)
0000              3   ; Reads channel 7 on P1.1, pin 14
0000              4   ; This version uses the LM4040 voltage reference connected to pin 6 (P1.7/AIN0)
0000              5   ; Incorporates push-button control to set up times/temperatures and start FSM.
0000              6   ;----------------------------------------------------------------------
0000              7   
                  9   $LIST
0000             11   
0000             12   ;  N76E003 pinout:
0000             13   ;                               -------
0000             14   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             15   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             16   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             17   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             18   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             19   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             20   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             21   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             22   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             23   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             24   ;                               -------
0000             25   ;
0000             26   
0000             27   ;----------------------------------------------------------------------
0000             28   ; System/Timer/Constants
0000             29   ;----------------------------------------------------------------------
0000             30   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             31   BAUD              EQU 115200   ; Baud rate of UART in bps
0000             32   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             33   
0000             34   TIMER2_RATE       EQU 100      ; 100 Hz -> 10ms tick
0000             35   TIMER2_RELOAD     EQU ((65536-(CLK/(16*TIMER2_RATE))))
0000             36   
0000             37   SAMPLES_PER_DISPLAY  EQU 300
0000             38   REFRESHES_PER_SECOND EQU 45
0000             39   TIMER0_DENOM         EQU (SAMPLES_PER_DISPLAY*REFRESHES_PER_SECOND)
0000             40   TIMER0_RELOAD        EQU (0x10000-(CLK/TIMER0_DENOM))
0000             41   
0000             42   ORG 0x0000
0000 02070D      43       ljmp main
0003             44   
002B             45   org 0x002B
002B 0203BF      46       ljmp Timer2_ISR
002E             47   
002E             48   ;----------------------------------------------------------------------
002E             49   ; Hardware Pin Definitions
002E             50   ;----------------------------------------------------------------------
002E             51   
002E             52   ; PUSH BUTTONS (single-pin read approach)
002E             53   PB_INPUT_PIN   EQU P1.5  ; The single pin used to read all 5 PBs
002E             54   MUX_CONTROL_0  EQU P1.3  
002E             55   MUX_CONTROL_1  EQU P0.0  
002E             56   MUX_CONTROL_2  EQU P0.1  
002E             57   MUX_CONTROL_3  EQU P0.2  
002E             58   MUX_CONTROL_4  EQU P0.3  
002E             59   
002E             60   ; LCD assignments
002E             61   LCD_RS  equ P1.3
002E             62   LCD_E   equ P1.4
002E             63   LCD_D4  equ P0.0
002E             64   LCD_D5  equ P0.1
002E             65   LCD_D6  equ P0.2
002E             66   LCD_D7  equ P0.3
002E             67   SSR_BOX equ P0.4
002E             68   
002E             69   ; Strings for LCD
002E 43757272    70   test_message:     db 'Current Temp.:', 0
     656E7420
     54656D70
     2E3A00
003D 4465672E    71   value_message:    db 'Deg. C', 0
     204300
0044             72   
0044 54656D70    73   temp_soak_string: db 'Temp Soak: ', 0
     20536F61
     6B3A2000
0050 54696D65    74   time_soak_string: db 'Time Soak: ', 0
     20536F61
     6B3A2000
005C 54696D65    75   temp_refl_string: db 'Time Reflow: ', 0
     20526566
     6C6F773A
     2000
006A 54696D65    76   time_refl_string: db 'Time Reflow: ', 0
     20526566
     6C6F773A
     2000
0078             77   
0078 204300      78   degree_label: db ' C', 0
007B 207300      79   seconds_label: db ' s', 0
007E             80   
007E             81   
007E             82   cseg
007E             83   
                 85   	$LIST
0132             87   
0132             88   ;----------------------------------------------------------------------
0132             89   ; 32-bit math placeholders
0132             90   ;----------------------------------------------------------------------
0030             91   DSEG at 30H
0030             92   x:   ds 4
0034             93   y:   ds 4
0038             94   bcd: ds 5
003D             95   VAL_LM4040: ds 2
003F             96   
003F             97   ; Variables
003F             98   state:              ds 1
0040             99   StoreMeasurements:  ds 4
0044            100   TempStore:          ds 2
0046            101   MeasurementCounter: ds 2
0048            102   SamplesPerDisplay:  ds 2
004A            103   TimePerSample:      ds 1
004B            104   LastMeasurement:    ds 4
004F            105   StoreThermocouple:  ds 4
0053            106   CurrentTemp:        ds 4
0057            107   FinalLM335:         ds 4
005B            108   FinalTemp:          ds 4
005F            109   selected_state:          ds 1
0060            110   
0060            111   Count1ms:      ds 2
0062            112   pwm_counter:   ds 1
0063            113   pwm:           ds 1
0064            114   
0064            115   ; Oven settings
0064            116   temp_soak: ds 1  ; For state 1
0065            117   time_soak: ds 1  ; For state 2
0066            118   temp_refl: ds 1  ; For state 3
0067            119   time_refl: ds 1  ; For state 4
0068            120   
0068            121   seconds: ds 1
0069            122   state_sec: ds 1
006A            123   
006A            124   ;----------------------------------------------------------------------
006A            125   ; Bit variables (BSEG)
006A            126   ;----------------------------------------------------------------------
0000            127   BSEG
0000            128   mf:            dbit 1
0001            129   m_flag:        dbit 1
0002            130   s_flag:        dbit 1
0003            131   err_tmp:       dbit 1
0004            132   err_tmp_150:   dbit 1
0005            133   
0005            134   start:         dbit 1  ; Start the FSM
0006            135   temp_state1:   dbit 1
0007            136   temp_state3:   dbit 1
0008            137   temp_state5:   dbit 1
0009            138   
0009            139   debug_bit:     dbit 1 ;Set to true to check which lines of code actually execute
000A            140   
000A            141   kill_flag:      dbit 1 ; kill switch
000B            142   
000B            143   ; For push buttons
000B            144   PB0: dbit 1  ; Start/Pause
000C            145   PB1: dbit 1  ; Toggle selected parameter
000D            146   PB2: dbit 1  ; Increment
000E            147   PB3: dbit 1  ; Decrement
000F            148   PB4: dbit 1  ; Unused or extra
0010            149   
0010            150   ;SETATS
0010            151   
0010            152   ; We include math32 at the end of initialization
                546   $LIST
                154   $LIST
03A2            156   
03A2            157   ;----------------------------------------------------------------------
03A2            158   ; Timer2 Initialization & ISR
03A2            159   ;----------------------------------------------------------------------
03A2            160   Timer2_Init:
03A2 75C800     161       mov T2CON, #0       ; Stop timer, mode = auto-reload
03A5 75CDD7     162       mov TH2, #high(TIMER2_RELOAD)
03A8 75CC79     163       mov TL2, #low(TIMER2_RELOAD)
03AB 43C9A0     164       orl T2MOD, #0b1010_0000    ; Enable auto-reload
03AE 75CBD7     165       mov RCMP2H, #high(TIMER2_RELOAD)
03B1 75CA79     166       mov RCMP2L, #low(TIMER2_RELOAD)
03B4 E4         167       clr  a
03B5 F560       168       mov  Count1ms+0, a
03B7 F561       169       mov  Count1ms+1, a
03B9 439B80     170       orl  EIE, #0x80     ; Enable timer2 interrupt (ET2=1)
03BC D2CA       171       setb TR2            ; Start Timer2
03BE 22         172       ret
03BF            173   
03BF            174   Timer2_ISR:
03BF C2CF       175       clr TF2 ; Must clear TF2 manually on N76
03C1 C0E0       176       push acc
03C3 C0D0       177       push psw
03C5            178   
03C5            179       ;---------------------------------
03C5            180       ; PWM for SSR control
03C5            181       ;---------------------------------
03C5 0562       182       inc pwm_counter ;Every 10ms, pwm_counter is incremented
03C7 C3         183       clr c
03C8 E563       184       mov a, pwm
03CA 9562       185       subb a, pwm_counter ; if pwm_counter <= pwm, c=1, so if pwm=20 for example, if 210ms has passed, c = 0, and the SSR box is always on
03CC B3         186       cpl c
03CD 9284       187       mov SSR_BOX, c
03CF            188   
03CF E562       189       mov a, pwm_counter
03D1 B46412     190       cjne a, #100, State_0 ; If 1 second has not passed, skip to State_0
03D4 756200     191       mov pwm_counter, #0 ; Reset pwm_counter
03D7 0568       192       inc seconds ; Increment seconds
03D9 0569       193       inc state_sec ; Will only increment in states 2 and 4, gets reset to 0 in all other states otherrwise
03DB E4         194       clr a
03DC E568       195       mov a, seconds
03DE B43C05     196       cjne a, #60, State_0 ;If exactly 60 seconds has not passed, skip to State_0, otherwise set m_flag to indicate a minute has passed
03E1 D201       197       setb m_flag
03E3 0203E6     198       ljmp State_0
03E6            199   
03E6            200   
03E6            201   State_0:
03E6 E53F       202       mov a, state
03E8 B40010     203            cjne a, #0, State_1
03EB E4         204       clr a
03EC 756900     205       mov state_sec, #0
03EF 756300     206            mov pwm, #0
03F2 300552     207            jnb start, jumpy 
03F5 753F01     208            mov state, #1
03F8 0204A7     209            ljmp Timer2_ISR_done
03FB            210            
03FB            211   State_1:
03FB 200A4C     212       jb kill_flag, jumpyError
03FE E53F       213            mov a, state
0400 B40128     214            cjne a, #1, State_2
0403 756364     215            mov pwm, #100                                   ; set pwm for relfow oven to 100%
0406 756900     216       mov state_sec, #0
0409            217   ;        jb m_flag, Cond_check
0409            218   ;        mov c, temp_state1
0409            219   ;        clr a                                                   ; clear the accumulator
0409            220   ;        mov acc.0, c
0409            221   ;        clr c                                                   ; clear the carry bit
0409 30063B     222            jnb temp_state1, jumpy          ; mf = 1 if oven temp <= set temp, jump out of ISR. mf = 0 if oven temp > set temp, thus move onto next state                   
040C E4         223            clr a                                           
040D 753F02     224            mov state, #2
0410 756900     225       mov state_sec, #0
0413 02042B     226            ljmp State_2
0416            227   
0416            228   Cond_check: ; cjne is not bit-addressable, therefore we must move bits into byte registers (i.e. accumulator and register b)
0416 A203       229            mov c, err_tmp
0418 E4         230            clr a 
0419 92E0       231            mov acc.0, c ; mov value in carry to the lowest bit of the accumulator
041B A201       232            mov c, m_flag
041D C201       233            clr m_flag ; clear minute flag
041F 75F000     234            mov b, #00h 
0422 92F0       235            mov b.0, c ; mov value in carry to the lowest bit of the B regrister
0424 C3         236            clr c
0425 B5F078     237            cjne a, b, State_error
0428 0203FB     238            ljmp State_1
042B            239   
042B            240   State_2: ;transition to state three if more than 60 seconds have passed
042B 200A72     241       jb kill_flag, State_error
042E E53F       242            mov a, state
0430 B4021A     243            cjne a, #2, State_3
0433 756314     244            mov pwm, #20
0436 200467     245            jb err_tmp_150, State_error
0439 E4         246       clr a        
043A E569       247       mov a, state_sec
043C C3         248       clr c
043D 9565       249       subb a, time_soak ; If state_sec - time_soak is negative (so not enough time has passed), then c = 1, 
043F 4066       250       jc Timer2_ISR_done
0441 753F03     251            mov state, #3
0444 756900     252       mov state_sec, #0
0447            253   
0447            254   jumpy:
0447 0204A7     255       ljmp Timer2_ISR_done
044A            256   jumpyError:
044A 0204A0     257       ljmp State_error
044D            258   
044D            259   State_3: 
044D 200A50     260       jb kill_flag, State_error
0450 E53F       261            mov a, state
0452 B40313     262            cjne a, #3, State_4 ; check if state = 3, if not, move to state_4
0455 756364     263            mov pwm, #100 ; set pwm to 100%
0458 756900     264       mov state_sec, #0
045B 200442     265            jb err_tmp_150, State_error
045E            266            ;mov c, temp_state3
045E            267            ;clr a                                                          ; clear the accumulator
045E            268            ;mov acc.0, c
045E            269            ;clr c                                                          ; clear the carry bit
045E            270            ;cjne a, #0, Timer2_ISR_done ;
045E 300746     271       jnb temp_state3, Timer2_ISR_done
0461 E4         272            clr a
0462 756900     273       mov state_sec, #0
0465 753F04     274            mov state, #4
0468            275   
0468            276   State_4:
0468 200A35     277       jb kill_flag, State_error
046B E53F       278            mov a, state
046D B40413     279            cjne a, #4, State_5
0470 756314     280            mov pwm, #20
0473 20042A     281            jb err_tmp_150, State_error
0476 E4         282       clr a
0477 E569       283       mov a, state_sec
0479 9567       284       subb a, time_refl
047B 402A       285       jc Timer2_ISR_Done    
047D 753F05     286            mov state, #5
0480 756900     287       mov state_sec, #0
0483            288   
0483            289   State_5:
0483 200A1A     290       jb kill_flag, State_error
0486 E53F       291            mov a, state
0488 B4051C     292            cjne a, #5, Timer2_ISR_done
048B 756300     293            mov pwm, #0
048E 756900     294       mov state_sec, #0
0491 20040C     295       jb err_tmp_150, State_error
0494 300810     296       jnb temp_state5, Timer2_ISR_done
0497 753F00     297            mov state, #0
049A 756900     298       mov state_sec, #0
049D 0204A7     299       ljmp Timer2_ISR_done
04A0            300   
04A0            301   State_error:
04A0 7400       302            mov a, #0
04A2 F53F       303            mov state, a
04A4 0204A7     304       ljmp Timer2_ISR_done
04A7            305            ; probably should put branch for warning message here
04A7            306   
04A7            307   Timer2_ISR_done:
04A7 D0D0       308       pop psw
04A9 D0E0       309       pop acc
04AB 32         310       reti
04AC            311   
04AC            312   ;----------------------------------------------------------------------
04AC            313   ; Initialization
04AC            314   ;----------------------------------------------------------------------
04AC            315   Init_All:
04AC            316       ; Configure all the pins for bidirectional I/O
04AC 75AC00     317       mov P3M1, #0x00
04AF 75AD00     318       mov P3M2, #0x00
04B2 75B300     319       mov P1M1, #0x00
04B5 75B400     320       mov P1M2, #0x00
04B8 75B100     321       mov P0M1, #0x00
04BB 75B200     322       mov P0M2, #0x00
04BE            323   
04BE 1203A2     324       lcall Timer2_Init
04C1            325   
04C1            326       ; Timer1 for UART
04C1 438E10     327       orl  CKCON, #0x10     ; Timer1 uses system clock
04C4 438780     328       orl  PCON,  #0x80     ; SMOD=1 -> double baud
04C7 759852     329       mov  SCON,  #0x52     ; UART mode 1, REN=1
04CA 53C4DF     330       anl  T3CON, #0b11011111
04CD 53890F     331       anl  TMOD,  #0x0F
04D0 438920     332       orl  TMOD,  #0x20     ; Timer1 Mode2 (8-bit auto-reload)
04D3 758DF7     333       mov  TH1, #TIMER1_RELOAD
04D6 D28E       334       setb TR1
04D8            335   
04D8            336       ; Timer0 for waitms
04D8 C28C       337       clr TR0
04DA 438E08     338       orl CKCON, #0x08
04DD 5389F0     339       anl TMOD,  #0xF0
04E0 438901     340       orl TMOD,  #0x01      ; 16-bit mode
04E3            341       ; ADC pins: P1.1 (AIN7), P1.7 (AIN0)
04E3 43B382     342       orl P1M1, #0b10000010 ; Set P1.1 & P1.7 as input
04E6 53B47D     343       anl P1M2, #0b01111101
04E9            344   
04E9            345       ; Initialize ADC
04E9 53E8F0     346       anl ADCCON0, #0xF0
04EC 43E807     347       orl ADCCON0, #0x07    ; default to channel 7
04EF 75F600     348       mov AINDIDS, #0x00    ; disable all digital inputs
04F2 43F681     349       orl AINDIDS, #0b10000001 ; activate AIN0 and AIN7
04F5 43E101     350       orl ADCCON1, #0x01    ; enable ADC
04F8 22         351       ret
04F9            352   
04F9            353   ;----------------------------------------------------------------------
04F9            354   ; Delay Routines
04F9            355   ;----------------------------------------------------------------------
04F9            356   wait_1ms:
04F9 C28C       357       clr TR0
04FB C28D       358       clr TF0
04FD 758CFB     359       mov TH0, #high(TIMER0_RELOAD)
0500 758A33     360       mov TL0, #low(TIMER0_RELOAD)
0503 D28C       361       setb TR0
0505 308DFD     362       jnb TF0, $
0508 22         363       ret
0509            364   
0509            365   ; Wait R2 milliseconds
0509            366   waitms:
0509 1204F9     367       lcall wait_1ms
050C DAFB       368       djnz R2, waitms
050E 22         369       ret
050F            370   
050F            371   ;----------------------------------------------------------------------
050F            372   ; LCD_PB: Read the 5 push buttons into PB0..PB4 bits
050F            373   ;----------------------------------------------------------------------
050F            374   LCD_PB:
050F            375       ; Default all PB bits to 1 (released)
050F D20B       376       setb PB0 
0511 D20C       377       setb PB1
0513 D20D       378       setb PB2
0515 D20E       379       setb PB3
0517 D20F       380       setb PB4
0519            381       ; The input pin is idle-high (pull-up)
0519 D295       382       setb PB_INPUT_PIN
051B            383   
051B            384       ; Set MUX lines to 0 first
051B C293       385       clr MUX_CONTROL_0
051D C280       386       clr MUX_CONTROL_1
051F C281       387       clr MUX_CONTROL_2
0521 C282       388       clr MUX_CONTROL_3
0523 C283       389       clr MUX_CONTROL_4
0525            390   
0525            391       ;---------------------------------
0525            392       ; Debouncing
0525            393       ;---------------------------------
0525 209537     394       jb  PB_INPUT_PIN, LCD_PB_Done 
0528 7A1E       395       mov R2, #30
052A 120509     396       lcall waitms
052D            397   
052D            398       ; Now set all MUX lines = 1 to read them individually
052D D293       399       setb MUX_CONTROL_0
052F D280       400       setb MUX_CONTROL_1
0531 D281       401       setb MUX_CONTROL_2
0533 D282       402       setb MUX_CONTROL_3
0535 D283       403       setb MUX_CONTROL_4
0537            404   
0537            405       ; Check PB4
0537 C283       406       clr MUX_CONTROL_4
0539 A295       407       mov c, PB_INPUT_PIN
053B 920F       408       mov PB4, c
053D D283       409       setb MUX_CONTROL_4
053F            410   
053F            411       ; Check PB3
053F C282       412       clr MUX_CONTROL_3
0541 A295       413       mov c, PB_INPUT_PIN
0543 920E       414       mov PB3, c
0545 D282       415       setb MUX_CONTROL_3
0547            416   
0547            417       ; Check PB2
0547 C281       418       clr MUX_CONTROL_2
0549 A295       419       mov c, PB_INPUT_PIN
054B 920D       420       mov PB2, c
054D D281       421       setb MUX_CONTROL_2
054F            422   
054F            423       ; Check PB1
054F C280       424       clr MUX_CONTROL_1
0551 A295       425       mov c, PB_INPUT_PIN
0553 920C       426       mov PB1, c
0555 D280       427       setb MUX_CONTROL_1
0557            428   
0557            429       ; Check PB0
0557 C293       430       clr MUX_CONTROL_0
0559 A295       431       mov c, PB_INPUT_PIN
055B 920B       432       mov PB0, c
055D D293       433       setb MUX_CONTROL_0
055F            434   
055F            435   LCD_PB_Done:
055F 22         436       ret
0560            437   
0560            438   ;----------------------------------------------------------------------
0560            439   ; Display_formated_BCD: Display the result with decimal
0560            440   ;----------------------------------------------------------------------
0560            441   Display_formated_BCD:
0560 C0E0       442            push acc
0562 7401       442            mov a, #1
0564 14         442            dec a
0565 120115     442            lcall ?Set_Cursor_2 ; Select column and row
0568 D0E0       442            pop acc
056A C000       443            push ar0
056C A83A       443            mov r0, bcd+2
056E 12011C     443            lcall ?Display_BCD
0571 D000       443            pop ar0
0573 C000       444            push ar0
0575 A839       444            mov r0, bcd+1
0577 12011C     444            lcall ?Display_BCD
057A D000       444            pop ar0
057C C0E0       445            push acc
057E 742E       445            mov a, #'.'
0580 1200CD     445            lcall ?WriteData
0583 D0E0       445            pop acc
0585 C000       446            push ar0
0587 A838       446            mov r0, bcd+0
0589 12011C     446            lcall ?Display_BCD
058C D000       446            pop ar0
058E C0E0       447            push acc
0590 74DF       447            mov a, #0xDF
0592 1200CD     447            lcall ?WriteData
0595 D0E0       447            pop acc    ; Degree symbol
0597 C0E0       448            push acc
0599 7443       448            mov a, #'C'
059B 1200CD     448            lcall ?WriteData
059E D0E0       448            pop acc
05A0 C0E0       449            push acc
05A2 7401       449            mov a, #1
05A4 14         449            dec a
05A5 120115     449            lcall ?Set_Cursor_2 ; Select column and row
05A8 D0E0       449            pop acc
05AA C0E0       450            push acc
05AC 7420       450            mov a, #' '
05AE 1200CD     450            lcall ?WriteData
05B1 D0E0       450            pop acc
05B3 22         451       ret
05B4            452   
05B4            453   ;----------------------------------------------------------------------
05B4            454   ; Read_ADC: reads current ADC channel into R0:R1 (12-bit)
05B4            455   ;----------------------------------------------------------------------
05B4            456   Read_ADC:
05B4 C2EF       457       clr  ADCF
05B6 D2EE       458       setb ADCS
05B8 30EFFD     459       jnb  ADCF, $          ; Wait conversion
05BB E5C2       460       mov  a, ADCRL
05BD 540F       461       anl  a, #0x0F
05BF F8         462       mov  R0, a
05C0 E5C3       463       mov  a, ADCRH
05C2 C4         464       swap a
05C3 C0E0       465       push acc
05C5 540F       466       anl  a, #0x0F
05C7 F9         467       mov  R1, a
05C8 D0E0       468       pop  acc
05CA 54F0       469       anl  a, #0xF0
05CC 48         470       orl  a, R0
05CD F8         471       mov  R0, a
05CE 22         472       ret
05CF            473   
05CF            474   ;----------------------------------------------------------------------
05CF            475   ; New code for push-button-based FSM parameter updates
05CF            476   ; We intercept button presses in SendSerial
05CF            477   ;----------------------------------------------------------------------
05CF            478   SendBCD:
05CF            479   
05CF E53A       480            mov a, bcd+2
05D1 540F       481            anl a, #0x0F ; Isolate ones place
05D3 2430       482            add a, #'0' ; Convert value to ASCII
05D5 120687     483            lcall SendSerial
05D8            484   
05D8 E539       485            mov a, bcd+1
05DA 54F0       486            anl a, #0xF0 ; Isolate tens place
05DC C4         487            swap a ; Put high nibble into lower nibble
05DD 2430       488            add a, #'0' ; Convert value to ASCII
05DF 120687     489            lcall SendSerial
05E2            490   
05E2 E539       491            mov a, bcd+1
05E4 540F       492            anl a, #0x0F ; Isolate ones place
05E6 2430       493            add a, #'0' ; Convert value to ASCII
05E8 120687     494            lcall SendSerial
05EB            495   
05EB 742E       496            mov a, #'.'
05ED 120687     497            lcall SendSerial
05F0            498   
05F0 E538       499            mov a, bcd+0
05F2 54F0       500            anl a, #0xF0 ; Isolate 0.1 place
05F4 C4         501            swap a ; Put high nibble into lower nibble
05F5 2430       502            add a, #'0' ; Convert value to ASCII
05F7 120687     503            lcall SendSerial
05FA            504   
05FA E538       505            mov a, bcd+0
05FC 540F       506            anl a, #0x0F ; Isolate 0.01 place
05FE 2430       507            add a, #'0' ; Convert value to ASCII
0600 120687     508            lcall SendSerial
0603            509   
0603 7420       510       mov a, #' '
0605 120687     511       lcall SendSerial
0608            512   
0608 7400       513       mov a, #0
060A A206       514       mov c, temp_state1
060C 92E0       515       mov acc.0, c
060E 2430       516       add a, #'0'
0610 120687     517       lcall SendSerial
0613            518       
0613 7420       519       mov a, #' '
0615 120687     520       lcall SendSerial
0618            521       
0618 E53F       522       mov a, state
061A 2430       523       add a, #'0'
061C 120687     524       lcall SendSerial
061F            525   
061F 7420       526       mov a, #' '
0621 120687     527       lcall SendSerial
0624            528   
0624 7400       529       mov a, #0
0626 A209       530       mov c, debug_bit
0628 92E0       531       mov acc.0, c
062A 2430       532       add a, #'0'
062C 120687     533       lcall SendSerial
062F            534   
062F 7420       535       mov a, #' '
0631 120687     536       lcall SendSerial
0634            537       
0634 E569       538       mov a, state_sec
0636 2430       539       add a, #'0'
0638 120687     540       lcall SendSerial
063B            541   
063B 7420       542       mov a, #' '
063D 120687     543       lcall SendSerial
0640            544       
0640 E568       545       mov a, seconds
0642 2430       546       add a, #'0'
0644 120687     547       lcall SendSerial
0647            548   
0647 7420       549       mov a, #' '
0649 120687     550       lcall SendSerial
064C            551   
064C 7400       552       mov a, #0
064E A284       553       mov c, SSR_BOX
0650 92E0       554       mov acc.0, c
0652 2430       555       add a, #'0'
0654 120687     556       lcall SendSerial
0657            557   
0657 7420       558       mov a, #' '
0659 120687     559       lcall SendSerial
065C 7420       560       mov a, #' '
065E 120687     561       lcall SendSerial
0661            562   
0661 7400       563       mov a, #0
0663 A20A       564       mov c, kill_flag
0665 92E0       565       mov acc.0, c
0667 2430       566       add a, #'0'
0669 120687     567       lcall SendSerial
066C            568   
066C 7420       569       mov a, #' '
066E 120687     570       lcall SendSerial
0671            571   
0671 7400       572       mov a, #0
0673 A205       573       mov c, start
0675 92E0       574       mov acc.0, c
0677 2430       575       add a, #'0'
0679 120687     576       lcall SendSerial
067C            577   
067C            578   
067C            579   
067C 740A       580            mov a, #'\n'
067E 120687     581            lcall SendSerial
0681            582   
0681 740D       583            mov a, #'\r'
0683 120687     584            lcall SendSerial
0686            585   
0686 22         586            ret
0687            587   
0687            588   
0687            589   SendSerial:
0687            590       ; Simulate sending 'a' to UART
0687 C299       591       clr  TI
0689 F599       592       mov  SBUF, a
068B            593       ; Wait for TX
068B            594   WaitTx:
068B 3099FD     595       jnb TI, WaitTx
068E C299       596       clr TI
0690            597   
0690            598       ; Now check buttons each time we "send":
0690            599       ; If button is pressed (bit=0), jump to its handler.
0690 300B0A     600       jnb PB0, start_oven
0693 300C20     601       jnb PB1, toggle_state
0696 300D2B     602       jnb PB2, inc_value
0699 300E4A     603       jnb PB3, dec_value
069C            604       ; PB4 is unused for now, do nothing if pressed.
069C            605   
069C 22         606       ret
069D            607   
069D            608   ; Start the FSM
069D            609   start_oven:
069D C3         610            clr c
069E A205       611       mov c, start
06A0 E4         612       clr a
06A1 92E0       613       mov acc.0, c
06A3 F4         614       cpl a                                ; set the flag to 1, indicating that the FSM should begin
06A4 A2E0       615       mov c, acc.0
06A6 9205       616       mov start, c
06A8 E4         617       clr a
06A9 C3         618       clr c
06AA A20A       619       mov c, kill_flag
06AC 92E0       620       mov acc.0, c
06AE F4         621       cpl a                    ; compliment kill
06AF A2E0       622       mov c, acc.0 
06B1 920A       623       mov kill_flag, c
06B3            624       
06B3            625       ;mov start, # 1                                ; return to main or update display as needed
06B3 02070C     626       ljmp end_button_logic           ; jump to exit logic
06B6            627   
06B6            628   ; Toggle which parameter is selected (1..4)
06B6            629   toggle_state:
06B6 E55F       630       mov a, selected_state           ; load the selected state to the accumulator
06B8 2401       631       add a, #1                       ; icnrement the selection
06BA B40502     632       cjne a, #5, noWrap              ; if not greater than 4, jump to noWrap
06BD 7401       633       mov a, #1                       ; if (selected_state == 5), reset the selected state, i.e. selected_state == 1
06BF            634   noWrap:
06BF F55F       635       mov selected_state, a           ; store the updated selected_state
06C1 02070C     636       ljmp end_button_logic           ; jump to exit logic
06C4            637   
06C4            638   ; Increment whichever parameter is selected
06C4            639   ; ** DOUBLE CHECK THIS LOGIC IM NOT TOO SURE **
06C4            640   inc_value:
06C4 E55F       641       mov a, selected_state           ; load the selected state into the accumulator
06C6 B40105     642       cjne a, #1, checkState2         ; if selected_state != temp_soak, check the next selected state
06C9 0564       643       inc temp_soak                   ; increment temp_soak if above condition not true
06CB 02070C     644       ljmp end_button_logic           ; jump to exit logic
06CE            645   
06CE            646   checkState2:                    
06CE B40205     647       cjne a, #2, checkState3         ; if not time_soak, check the next parameter
06D1 0565       648       inc time_soak                   ; increment time_soak
06D3 02070C     649       ljmp end_button_logic           ; jump to exit logic
06D6            650   
06D6            651   checkState3:
06D6 B40305     652       cjne a, #3, checkState4         ; if not temp_refl, check next parameter
06D9 0566       653       inc temp_refl                   ; increment temp_refl
06DB 02070C     654       ljmp end_button_logic           ; jump to exit logic
06DE            655   
06DE            656   checkState4:                        
06DE B4042B     657       cjne a, #4, end_button_logic    ; if not time_refl, exit 
06E1 0567       658       inc time_refl                   ; inc time_refl
06E3 02070C     659       ljmp end_button_logic           ; jump to exit logic
06E6            660   
06E6            661   ; Decrement whichever parameter is selected
06E6            662   ; ** SAME IDEA BUT CHECK THE LOGIC PLEASE ** 
06E6            663   dec_value:
06E6 E55F       664       mov a, selected_state
06E8 B40106     665       cjne a, #1, dcheckState2
06EB D5641E     666       djnz temp_soak, end_button_logic
06EE 02070C     667       ljmp end_button_logic
06F1            668   
06F1            669   dcheckState2:
06F1 B40206     670       cjne a, #2, dcheckState3
06F4 D56515     671       djnz time_soak, end_button_logic
06F7 02070C     672       ljmp end_button_logic
06FA            673   
06FA            674   dcheckState3:
06FA B40306     675       cjne a, #3, dcheckState4
06FD D5660C     676       djnz temp_refl, end_button_logic
0700 02070C     677       ljmp end_button_logic
0703            678   
0703            679   dcheckState4:
0703 B40406     680       cjne a, #4, end_button_logic
0706 D56703     681       djnz time_refl, end_button_logic
0709 02070C     682       ljmp end_button_logic
070C            683   
070C            684   end_button_logic:
070C 22         685       ret
070D            686   
070D            687   ;----------------------------------------------------------------------
070D            688   ; main
070D            689   ;----------------------------------------------------------------------
070D            690   main:
070D 75817F     691       mov sp, #0x7F
0710 1204AC     692       lcall Init_All
0713 1200D7     693       lcall LCD_4BIT
0716 1203A2     694       lcall Timer2_Init ; initialize interupts 
0719 D2AF       695       setb EA
071B            696   
071B 754601     697       mov MeasurementCounter+0, #1
071E 754700     698       mov MeasurementCounter+1, #0
0721 754A01     699       mov TimePerSample, #1
0724            700   
0724 75482C     701       mov SamplesPerDisplay+0, #low(SAMPLES_PER_DISPLAY)
0727 754901     702       mov SamplesPerDisplay+1, #high(SAMPLES_PER_DISPLAY)
072A            703   
072A            704       ; We start with "state=0" (idle)
072A 753F00     705       mov state, #0
072D C205       706       clr start ; compliment in start_oven
072F C201       707       clr m_flag
0731 D20A       708       setb kill_flag
0733            709   
0733            710       ; Default setpoints
0733 75641C     711       mov temp_soak, #28
0736 756505     712       mov time_soak, #5
0739 75661E     713       mov temp_refl, #30
073C 756705     714       mov time_refl, #5
073F            715   
073F            716       ; Which parameter we are currently adjusting: 1=temp_soak,2=time_soak,3=temp_refl,4=time_refl
073F 755F01     717       mov selected_state, #1
0742            718   
0742 754B00     719       mov LastMeasurement+0, #0
0745 754C00     720       mov LastMeasurement+1, #0
0748 754D00     721       mov LastMeasurement+2, #0
074B 754E00     722       mov LastMeasurement+3, #0
074E            723       
074E C206       724       clr temp_state1
0750 C207       725       clr temp_state3
0752 C209       726       clr debug_bit
0754 C203       727       clr err_tmp
0756 C204       728       clr err_tmp_150
0758 756800     729       mov seconds, #0
075B 756900     730       mov state_sec, #0
075E 756200     731       mov pwm_counter, #0
0761 756300     732       mov pwm, #0
0764            733   
0764            734       ; Show initial LCD message
0764 C0E0       735            push acc
0766 7401       735            mov a, #1
0768 14         735            dec a
0769 120117     735            lcall ?Set_Cursor_1 ; Select column and row
076C D0E0       735            pop acc
076E C083       736            push dph
0770 C082       736            push dpl
0772 C0E0       736            push acc
0774 90002E     736            mov dptr, #test_message
0777 12010A     736            lcall ?Send_Constant_String
077A D0E0       736            pop acc
077C D082       736            pop dpl
077E D083       736            pop dph
0780            737   
0780            738   Forever:
0780            739       ; Example read reference (AIN0)
0780 53E8F0     740       anl  ADCCON0, #0xF0
0783 43E800     741       orl  ADCCON0, #0x00 ; Channel0
0786 1205B4     742       lcall Read_ADC
0789 883D       743       mov  VAL_LM4040+0, R0
078B 893E       744       mov  VAL_LM4040+1, R1
078D            745   
078D            746       ; Read LM335 on AIN7
078D 53E8F0     747       anl  ADCCON0, #0xF0
0790 43E807     748       orl  ADCCON0, #0x07
0793 1205B4     749       lcall Read_ADC
0796            750   
0796            751       ; Convert to "voltage" in x
0796 8830       752       mov  x+0, R0
0798 8931       753       mov  x+1, R1
079A 753200     754       mov  x+2, #0
079D 753300     755       mov  x+3, #0
07A0 7534FF     756            mov y+0, #low (40959 % 0x10000) 
07A3 75359F     756            mov y+1, #high(40959 % 0x10000) 
07A6 753600     756            mov y+2, #low (40959 / 0x10000) 
07A9 753700     756            mov y+3, #high(40959 / 0x10000)        ; e.g. 4.0959 => times 10000 in math
07AC 1202AC     757       lcall mul32
07AF 853D34     758       mov  y+0, VAL_LM4040+0
07B2 853E35     759       mov  y+1, VAL_LM4040+1
07B5 753600     760       mov  y+2, #0
07B8 753700     761       mov  y+3, #0
07BB 120339     762       lcall div32
07BE            763   
07BE            764       ; Add partial result to StoreMeasurements
07BE 854034     765       mov  y+0, StoreMeasurements+0
07C1 854135     766       mov  y+1, StoreMeasurements+1
07C4 854236     767       mov  y+2, StoreMeasurements+2
07C7 854337     768       mov  y+3, StoreMeasurements+3
07CA 1201F7     769       lcall add32
07CD 853040     770       mov  StoreMeasurements+0, x+0
07D0 853141     771       mov  StoreMeasurements+1, x+1
07D3 853242     772       mov  StoreMeasurements+2, x+2
07D6 853343     773       mov  StoreMeasurements+3, x+3
07D9            774   
07D9            775       ; Read thermocouple on AIN4
07D9 53E8F0     776       anl  ADCCON0, #0xF0
07DC 43E804     777       orl  ADCCON0, #0x04
07DF 1205B4     778       lcall Read_ADC
07E2            779   
07E2 8830       780       mov  x+0, R0
07E4 8931       781       mov  x+1, R1
07E6 753200     782       mov  x+2, #0
07E9 753300     783       mov  x+3, #0
07EC 7534FF     784            mov y+0, #low (40959 % 0x10000) 
07EF 75359F     784            mov y+1, #high(40959 % 0x10000) 
07F2 753600     784            mov y+2, #low (40959 / 0x10000) 
07F5 753700     784            mov y+3, #high(40959 / 0x10000) 
07F8 1202AC     785       lcall mul32
07FB 853D34     786       mov  y+0, VAL_LM4040+0
07FE 853E35     787       mov  y+1, VAL_LM4040+1
0801 753600     788       mov  y+2, #0
0804 753700     789       mov  y+3, #0
0807 120339     790       lcall div32
080A            791   
080A            792       ; Add partial result to StoreThermocouple
080A 854F34     793       mov  y+0, StoreThermocouple+0
080D 855035     794       mov  y+1, StoreThermocouple+1
0810 855136     795       mov  y+2, StoreThermocouple+2
0813 855237     796       mov  y+3, StoreThermocouple+3
0816 1201F7     797       lcall add32
0819 85304F     798       mov  StoreThermocouple+0, x+0
081C 853150     799       mov  StoreThermocouple+1, x+1
081F 853251     800       mov  StoreThermocouple+2, x+2
0822 853352     801       mov  StoreThermocouple+3, x+3
0825            802   
0825            803       ; Delay between samples
0825 AA4A       804       mov R2, TimePerSample
0827 120509     805       lcall waitms
082A            806   
082A            807       ; Decrement measurement counter
082A 1546       808       dec MeasurementCounter+0
082C E546       809       mov a, MeasurementCounter+0
082E B4FF02     810       cjne a, #0xFF, CheckHigh
0831 1547       811       dec MeasurementCounter+1
0833            812   CheckHigh:
0833 E546       813       mov a, MeasurementCounter+0
0835 4547       814       orl a, MeasurementCounter+1
0837 6003       815       jz  DisplayValue
0839 0209A0     816       ljmp EndForever
083C            817   
083C            818   ;----------------------------------------------------------------------
083C            819   ; If enough measurements collected -> compute final temperature
083C            820   ;----------------------------------------------------------------------
083C            821   DisplayValue:
083C 753400     822            mov y+0, #low (0 % 0x10000) 
083F 753500     822            mov y+1, #high(0 % 0x10000) 
0842 753600     822            mov y+2, #low (0 / 0x10000) 
0845 753700     822            mov y+3, #high(0 / 0x10000) 
0848            823       ; Combine for LM335 reading
0848 854030     824       mov x+0, StoreMeasurements+0
084B 854131     825       mov x+1, StoreMeasurements+1
084E 854232     826       mov x+2, StoreMeasurements+2
0851 854333     827       mov x+3, StoreMeasurements+3
0854 E548       828       mov a, SamplesPerDisplay+0
0856 F534       829       mov y+0, a
0858 F546       830       mov MeasurementCounter+0, a
085A E549       831       mov a, SamplesPerDisplay+1
085C F535       832       mov y+1, a
085E F547       833       mov MeasurementCounter+1, a
0860 120339     834       lcall div32
0863            835   
0863            836       ; Subtract 273.00 => Celsius reading
0863 7534A4     837            mov y+0, #low (27300 % 0x10000) 
0866 75356A     837            mov y+1, #high(27300 % 0x10000) 
0869 753600     837            mov y+2, #low (27300 / 0x10000) 
086C 753700     837            mov y+3, #high(27300 / 0x10000) 
086F 120218     838       lcall sub32
0872 853057     839       mov FinalLM335+0, x+0
0875 853158     840       mov FinalLM335+1, x+1
0878 853259     841       mov FinalLM335+2, x+2
087B 85335A     842       mov FinalLM335+3, x+3
087E            843   
087E            844       ; Combine for thermocouple reading
087E 753400     845            mov y+0, #low (0 % 0x10000) 
0881 753500     845            mov y+1, #high(0 % 0x10000) 
0884 753600     845            mov y+2, #low (0 / 0x10000) 
0887 753700     845            mov y+3, #high(0 / 0x10000) 
088A 854F30     846       mov x+0, StoreThermocouple+0
088D 855031     847       mov x+1, StoreThermocouple+1
0890 855132     848       mov x+2, StoreThermocouple+2
0893 855233     849       mov x+3, StoreThermocouple+3
0896 E548       850       mov a, SamplesPerDisplay+0
0898 F534       851       mov y+0, a
089A E549       852       mov a, SamplesPerDisplay+1
089C F535       853       mov y+1, a
089E 120339     854       lcall div32
08A1            855   
08A1            856       ; Add thermocouple to LM335 reading => final in x
08A1 753400     857            mov y+0, #low (0 % 0x10000) 
08A4 753500     857            mov y+1, #high(0 % 0x10000) 
08A7 753600     857            mov y+2, #low (0 / 0x10000) 
08AA 753700     857            mov y+3, #high(0 / 0x10000) 
08AD 855734     858       mov y+0, FinalLM335+0
08B0 855835     859       mov y+1, FinalLM335+1
08B3 855936     860       mov y+2, FinalLM335+2
08B6 855A37     861       mov y+3, FinalLM335+3
08B9 1201F7     862       lcall add32
08BC            863   
08BC 85305B     864       mov FinalTemp+0, x+0
08BF 85315C     865       mov FinalTemp+1, x+1
08C2 85325D     866       mov FinalTemp+2, x+2
08C5 85335E     867       mov FinalTemp+3, x+3
08C8            868   
08C8            869       ; --------------------------------------------------------
08C8            870       ; Compare final temperature with soak/reflow setpoints
08C8            871       ; --------------------------------------------------------
08C8 C200       872       clr mf
08CA 753464     873            mov y+0, #low (100 % 0x10000) 
08CD 753500     873            mov y+1, #high(100 % 0x10000) 
08D0 753600     873            mov y+2, #low (100 / 0x10000) 
08D3 753700     873            mov y+3, #high(100 / 0x10000) 
08D6 856430     874       mov x+0, temp_soak
08D9 753100     875       mov x+1, #0
08DC 753200     876       mov x+2, #0
08DF 753300     877       mov x+3, #0
08E2 1202AC     878       lcall mul32
08E5 855B34     879       mov y+0, FinalTemp+0
08E8 855C35     880       mov y+1, FinalTemp+1
08EB 855D36     881       mov y+2, FinalTemp+2
08EE 855E37     882       mov y+3, FinalTemp+3
08F1 1202A2     883       lcall x_lteq_y ; mf = 1 if temp_soak<=FinalTemp
08F4 A200       884       mov c, mf
08F6 9206       885       mov temp_state1, c
08F8            886   
08F8 C200       887       clr mf
08FA 753464     888            mov y+0, #low (100 % 0x10000) 
08FD 753500     888            mov y+1, #high(100 % 0x10000) 
0900 753600     888            mov y+2, #low (100 / 0x10000) 
0903 753700     888            mov y+3, #high(100 / 0x10000) 
0906 856630     889       mov x+0, temp_refl
0909 753100     890       mov x+1, #0
090C 753200     891       mov x+2, #0
090F 753300     892       mov x+3, #0
0912 1202AC     893       lcall mul32
0915 855B34     894       mov y+0, FinalTemp+0
0918 855C35     895       mov y+1, FinalTemp+1
091B 855D36     896       mov y+2, FinalTemp+2
091E 855E37     897       mov y+3, FinalTemp+3
0921 1202A2     898       lcall x_lteq_y ; mf = 1 if temp_refl<=FinalTemp
0924 A200       899       mov c, mf
0926 9207       900       mov temp_state3, c
0928            901   
0928            902       ; Check error states
0928 855B30     903       mov x+0, FinalTemp+0
092B 855C31     904       mov x+1, FinalTemp+1
092E 855D32     905       mov x+2, FinalTemp+2
0931 855E33     906       mov x+3, FinalTemp+3
0934            907   
0934 C200       908       clr mf
0936 7534A8     909            mov y+0, #low (25000 % 0x10000) 
0939 753561     909            mov y+1, #high(25000 % 0x10000) 
093C 753600     909            mov y+2, #low (25000 / 0x10000) 
093F 753700     909            mov y+3, #high(25000 / 0x10000) 
0942 120298     910       lcall x_gteq_y ; mf = 1 if FinalTemp<=250
0945 A200       911       mov c, mf
0947 9204       912       mov err_tmp_150, c
0949            913   
0949 C200       914       clr mf
094B 753488     915            mov y+0, #low (5000 % 0x10000) 
094E 753513     915            mov y+1, #high(5000 % 0x10000) 
0951 753600     915            mov y+2, #low (5000 / 0x10000) 
0954 753700     915            mov y+3, #high(5000 / 0x10000) 
0957 120298     916       lcall x_gteq_y ; mf = 1 if FinalTemp>=50
095A A200       917       mov c, mf
095C 9203       918       mov err_tmp, c
095E            919   
095E C200       920       clr mf
0960 7534B8     921            mov y+0, #low (3000 % 0x10000) 
0963 75350B     921            mov y+1, #high(3000 % 0x10000) 
0966 753600     921            mov y+2, #low (3000 / 0x10000) 
0969 753700     921            mov y+3, #high(3000 / 0x10000) 
096C 1202A2     922       lcall x_lteq_y ; mf = 1 if FinalTemp<=60
096F A200       923       mov c, mf
0971 9208       924       mov temp_state5, c
0973            925   
0973            926   
0973            927   
0973            928       ; Convert FinalTemp => BCD => display
0973 120132     929       lcall hex2bcd
0976 120560     930       lcall Display_formated_BCD
0979 1205CF     931       lcall SendBCD
097C            932   
097C            933       ; Reset accumulators
097C 754000     934       mov StoreMeasurements+0, #0
097F 754100     935       mov StoreMeasurements+1, #0
0982 754200     936       mov StoreMeasurements+2, #0
0985 754300     937       mov StoreMeasurements+3, #0
0988 754F00     938       mov StoreThermocouple+0, #0
098B 755000     939       mov StoreThermocouple+1, #0
098E 755100     940       mov StoreThermocouple+2, #0
0991 755200     941       mov StoreThermocouple+3, #0
0994 755700     942       mov FinalLM335+0, #0
0997 755801     943       mov FinalLM335+1, #1
099A 755902     944       mov FinalLM335+2, #2
099D 755A03     945       mov FinalLM335+3, #3
09A0            946   
09A0            947   EndForever:
09A0            948       ; Always read the push buttons each pass
09A0 12050F     949       lcall LCD_PB
09A3            950   
09A3            951   
09A3 753000     952       mov x+0, #0
09A6 753100     953       mov x+1, #0
09A9 753200     954       mov x+2, #0
09AC 753300     955       mov x+3, #0
09AF 020780     956       ljmp Forever
09B2            957   
09B2            958   END
