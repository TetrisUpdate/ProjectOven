0000              1   ;----------------------------------------------------------------------
0000              2   ; 76E003 ADC test program (reflow oven controller + push buttons)
0000              3   ; Reads channel 7 on P1.1, pin 14
0000              4   ; This version uses the LM4040 voltage reference connected to pin 6 (P1.7/AIN0)
0000              5   ; Incorporates push-button control to set up times/temperatures and start FSM.
0000              6   ;----------------------------------------------------------------------
0000              7   
                  9   $LIST
0000             11   
0000             12   ;  N76E003 pinout:
0000             13   ;                               -------
0000             14   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             15   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             16   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             17   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             18   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             19   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             20   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             21   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             22   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             23   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             24   ;                               -------
0000             25   ;
0000             26   
0000             27   ;----------------------------------------------------------------------
0000             28   ; System/Timer/Constants
0000             29   ;----------------------------------------------------------------------
0000             30   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             31   BAUD              EQU 115200   ; Baud rate of UART in bps
0000             32   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             33   
0000             34   TIMER2_RATE       EQU 100      ; 100 Hz -> 10ms tick
0000             35   TIMER2_RELOAD     EQU ((65536-(CLK/(16*TIMER2_RATE))))
0000             36   
0000             37   SAMPLES_PER_DISPLAY  EQU 300
0000             38   REFRESHES_PER_SECOND EQU 45
0000             39   TIMER0_DENOM         EQU (SAMPLES_PER_DISPLAY*REFRESHES_PER_SECOND)
0000             40   TIMER0_RELOAD        EQU (0x10000-(CLK/TIMER0_DENOM))
0000             41   
0000             42   ORG 0x0000
0000 0206C7      43       ljmp main
0003             44   
002B             45   org 0x002B
002B 020385      46       ljmp Timer2_ISR
002E             47   
002E             48   ;----------------------------------------------------------------------
002E             49   ; Hardware Pin Definitions
002E             50   ;----------------------------------------------------------------------
002E             51   
002E             52   ; PUSH BUTTONS (single-pin read approach)
002E             53   PB_INPUT_PIN   EQU P1.5  ; The single pin used to read all 5 PBs
002E             54   MUX_CONTROL_0  EQU P1.3  
002E             55   MUX_CONTROL_1  EQU P0.0  
002E             56   MUX_CONTROL_2  EQU P0.1  
002E             57   MUX_CONTROL_3  EQU P0.2  
002E             58   MUX_CONTROL_4  EQU P0.3  
002E             59   
002E             60   ; LCD assignments
002E             61   LCD_RS  equ P1.3
002E             62   LCD_E   equ P1.4
002E             63   LCD_D4  equ P0.0
002E             64   LCD_D5  equ P0.1
002E             65   LCD_D6  equ P0.2
002E             66   LCD_D7  equ P0.3
002E             67   SSR_BOX equ P0.4
002E             68   
002E             69   ; Strings for LCD
002E 43757272    70   test_message:     db 'Current Temp.:', 0
     656E7420
     54656D70
     2E3A00
003D 4465672E    71   value_message:    db 'Deg. C', 0
     204300
0044             72   
0044             73   cseg
0044             74   
                 76   	$LIST
00F8             78   
00F8             79   ;----------------------------------------------------------------------
00F8             80   ; 32-bit math placeholders
00F8             81   ;----------------------------------------------------------------------
0030             82   DSEG at 30H
0030             83   x:   ds 4
0034             84   y:   ds 4
0038             85   bcd: ds 5
003D             86   VAL_LM4040: ds 2
003F             87   
003F             88   ; Variables
003F             89   state:              ds 1
0040             90   StoreMeasurements:  ds 4
0044             91   TempStore:          ds 2
0046             92   MeasurementCounter: ds 2
0048             93   SamplesPerDisplay:  ds 2
004A             94   TimePerSample:      ds 1
004B             95   LastMeasurement:    ds 4
004F             96   StoreThermocouple:  ds 4
0053             97   CurrentTemp:        ds 4
0057             98   FinalLM335:         ds 4
005B             99   FinalTemp:          ds 4
005F            100   selected_state:          ds 1
0060            101   
0060            102   Count1ms:      ds 2
0062            103   pwm_counter:   ds 1
0063            104   pwm:           ds 1
0064            105   
0064            106   ; Oven settings
0064            107   temp_soak: ds 1  ; For state 1
0065            108   time_soak: ds 1  ; For state 2
0066            109   temp_refl: ds 1  ; For state 3
0067            110   time_refl: ds 1  ; For state 4
0068            111   
0068            112   seconds: ds 1
0069            113   state_sec: ds 1
006A            114   
006A            115   ;----------------------------------------------------------------------
006A            116   ; Bit variables (BSEG)
006A            117   ;----------------------------------------------------------------------
0000            118   BSEG
0000            119   mf:            dbit 1
0001            120   m_flag:        dbit 1
0002            121   s_flag:        dbit 1
0003            122   err_tmp:       dbit 1
0004            123   err_tmp_150:   dbit 1
0005            124   
0005            125   start:         dbit 1  ; Start the FSM
0006            126   temp_state1:   dbit 1
0007            127   temp_state3:   dbit 1
0008            128   temp_state5:   dbit 1
0009            129   
0009            130   debug_bit:     dbit 1 ;Set to true to check which lines of code actually execute
000A            131   
000A            132   kill_flag:      dbit 1 ; kill switch
000B            133   
000B            134   ; For push buttons
000B            135   PB0: dbit 1  ; Start/Pause
000C            136   PB1: dbit 1  ; Toggle selected parameter
000D            137   PB2: dbit 1  ; Increment
000E            138   PB3: dbit 1  ; Decrement
000F            139   PB4: dbit 1  ; Unused or extra
0010            140   
0010            141   ;SETATS
0010            142   
0010            143   ; We include math32 at the end of initialization
                546   $LIST
                145   $LIST
0368            147   
0368            148   ;----------------------------------------------------------------------
0368            149   ; Timer2 Initialization & ISR
0368            150   ;----------------------------------------------------------------------
0368            151   Timer2_Init:
0368 75C800     152       mov T2CON, #0       ; Stop timer, mode = auto-reload
036B 75CDD7     153       mov TH2, #high(TIMER2_RELOAD)
036E 75CC79     154       mov TL2, #low(TIMER2_RELOAD)
0371 43C9A0     155       orl T2MOD, #0b1010_0000    ; Enable auto-reload
0374 75CBD7     156       mov RCMP2H, #high(TIMER2_RELOAD)
0377 75CA79     157       mov RCMP2L, #low(TIMER2_RELOAD)
037A E4         158       clr  a
037B F560       159       mov  Count1ms+0, a
037D F561       160       mov  Count1ms+1, a
037F 439B80     161       orl  EIE, #0x80     ; Enable timer2 interrupt (ET2=1)
0382 D2CA       162       setb TR2            ; Start Timer2
0384 22         163       ret
0385            164   
0385            165   Timer2_ISR:
0385 C2CF       166       clr TF2 ; Must clear TF2 manually on N76
0387 C0E0       167       push acc
0389 C0D0       168       push psw
038B            169   
038B            170       ;---------------------------------
038B            171       ; PWM for SSR control
038B            172       ;---------------------------------
038B 0562       173       inc pwm_counter ;Every 10ms, pwm_counter is incremented
038D C3         174       clr c
038E E563       175       mov a, pwm
0390 9562       176       subb a, pwm_counter ; if pwm_counter <= pwm, c=1, so if pwm=20 for example, if 210ms has passed, c = 0, and the SSR box is always on
0392 B3         177       cpl c
0393 9284       178       mov SSR_BOX, c
0395            179   
0395 E562       180       mov a, pwm_counter
0397 B46412     181       cjne a, #100, State_0 ; If 1 second has not passed, skip to State_0
039A 756200     182       mov pwm_counter, #0 ; Reset pwm_counter
039D 0568       183       inc seconds ; Increment seconds
039F 0569       184       inc state_sec ; Will only increment in states 2 and 4, gets reset to 0 in all other states otherrwise
03A1 E4         185       clr a
03A2 E568       186       mov a, seconds
03A4 B43C05     187       cjne a, #60, State_0 ;If exactly 60 seconds has not passed, skip to State_0, otherwise set m_flag to indicate a minute has passed
03A7 D201       188       setb m_flag
03A9 0203AC     189       ljmp State_0
03AC            190   
03AC            191   
03AC            192   State_0:
03AC E53F       193       mov a, state
03AE B40010     194            cjne a, #0, State_1
03B1 E4         195       clr a
03B2 756900     196       mov state_sec, #0
03B5 756300     197            mov pwm, #0
03B8 300552     198            jnb start, jumpy 
03BB 753F01     199            mov state, #1
03BE 020467     200            ljmp Timer2_ISR_done
03C1            201            
03C1            202   State_1:
03C1 200AE8     203       jb kill_flag, State_0
03C4 E53F       204            mov a, state
03C6 B40128     205            cjne a, #1, State_2
03C9 756364     206            mov pwm, #100                                   ; set pwm for relfow oven to 100%
03CC 756900     207       mov state_sec, #0
03CF            208   ;        jb m_flag, Cond_check
03CF            209   ;        mov c, temp_state1
03CF            210   ;        clr a                                                   ; clear the accumulator
03CF            211   ;        mov acc.0, c
03CF            212   ;        clr c                                                   ; clear the carry bit
03CF 30063B     213            jnb temp_state1, jumpy          ; mf = 1 if oven temp <= set temp, jump out of ISR. mf = 0 if oven temp > set temp, thus move onto next state                   
03D2 E4         214            clr a                                           
03D3 753F02     215            mov state, #2
03D6 756900     216       mov state_sec, #0
03D9 0203F1     217            ljmp State_2
03DC            218   
03DC            219   Cond_check: ; cjne is not bit-addressable, therefore we must move bits into byte registers (i.e. accumulator and register b)
03DC A203       220            mov c, err_tmp
03DE E4         221            clr a 
03DF 92E0       222            mov acc.0, c ; mov value in carry to the lowest bit of the accumulator
03E1 A201       223            mov c, m_flag
03E3 C201       224            clr m_flag ; clear minute flag
03E5 75F000     225            mov b, #00h 
03E8 92F0       226            mov b.0, c ; mov value in carry to the lowest bit of the B regrister
03EA C3         227            clr c
03EB B5F075     228            cjne a, b, State_error
03EE 0203C1     229            ljmp State_1
03F1            230   
03F1            231   State_2: ;transition to state three if more than 60 seconds have passed
03F1 200AB8     232       jb kill_flag, State_0
03F4 E53F       233            mov a, state
03F6 B40217     234            cjne a, #2, State_3
03F9 756314     235            mov pwm, #20
03FC 200464     236            jb err_tmp_150, State_error
03FF E4         237       clr a        
0400 E569       238       mov a, state_sec
0402 C3         239       clr c
0403 9565       240       subb a, time_soak ; If state_sec - time_soak is negative (so not enough time has passed), then c = 1, 
0405 4060       241       jc Timer2_ISR_done
0407 753F03     242            mov state, #3
040A 756900     243       mov state_sec, #0
040D            244   
040D            245   jumpy:
040D 020467     246       ljmp Timer2_ISR_done
0410            247   
0410            248   State_3: 
0410 200A99     249       jb kill_flag, State_0
0413 E53F       250            mov a, state
0415 B40313     251            cjne a, #3, State_4 ; check if state = 3, if not, move to state_4
0418 756364     252            mov pwm, #100 ; set pwm to 100%
041B 756900     253       mov state_sec, #0
041E 200442     254            jb err_tmp_150, State_error
0421            255            ;mov c, temp_state3
0421            256            ;clr a                                                          ; clear the accumulator
0421            257            ;mov acc.0, c
0421            258            ;clr c                                                          ; clear the carry bit
0421            259            ;cjne a, #0, Timer2_ISR_done ;
0421 300743     260       jnb temp_state3, Timer2_ISR_done
0424 E4         261            clr a
0425 756900     262       mov state_sec, #0
0428 753F04     263            mov state, #4
042B            264   
042B            265   State_4:
042B 200A35     266       jb kill_flag, State_error
042E E53F       267            mov a, state
0430 B40413     268            cjne a, #4, State_5
0433 756314     269            mov pwm, #20
0436 20042A     270            jb err_tmp_150, State_error
0439 E4         271       clr a
043A E569       272       mov a, state_sec
043C 9567       273       subb a, time_refl
043E 4027       274       jc Timer2_ISR_Done    
0440 753F05     275            mov state, #5
0443 756900     276       mov state_sec, #0
0446            277   
0446            278   State_5:
0446 200A1A     279       jb kill_flag, State_error
0449 E53F       280            mov a, state
044B B40519     281            cjne a, #5, Timer2_ISR_done
044E 756300     282            mov pwm, #0
0451 756900     283       mov state_sec, #0
0454 20040C     284       jb err_tmp_150, State_error
0457 30080D     285       jnb temp_state5, Timer2_ISR_done
045A 753F00     286            mov state, #0
045D 756900     287       mov state_sec, #0
0460 020467     288       ljmp Timer2_ISR_done
0463            289   
0463            290   State_error:
0463 7400       291            mov a, #0
0465 F53F       292            mov state, a
0467            293            ; probably should put branch for warning message here
0467            294   
0467            295   Timer2_ISR_done:
0467 D0D0       296       pop psw
0469 D0E0       297       pop acc
046B 32         298       reti
046C            299   
046C            300   ;----------------------------------------------------------------------
046C            301   ; Initialization
046C            302   ;----------------------------------------------------------------------
046C            303   Init_All:
046C            304       ; Configure all the pins for bidirectional I/O
046C 75AC00     305       mov P3M1, #0x00
046F 75AD00     306       mov P3M2, #0x00
0472 75B300     307       mov P1M1, #0x00
0475 75B400     308       mov P1M2, #0x00
0478 75B100     309       mov P0M1, #0x00
047B 75B200     310       mov P0M2, #0x00
047E            311   
047E 120368     312       lcall Timer2_Init
0481            313   
0481            314       ; Timer1 for UART
0481 438E10     315       orl  CKCON, #0x10     ; Timer1 uses system clock
0484 438780     316       orl  PCON,  #0x80     ; SMOD=1 -> double baud
0487 759852     317       mov  SCON,  #0x52     ; UART mode 1, REN=1
048A 53C4DF     318       anl  T3CON, #0b11011111
048D 53890F     319       anl  TMOD,  #0x0F
0490 438920     320       orl  TMOD,  #0x20     ; Timer1 Mode2 (8-bit auto-reload)
0493 758DF7     321       mov  TH1, #TIMER1_RELOAD
0496 D28E       322       setb TR1
0498            323   
0498            324       ; Timer0 for waitms
0498 C28C       325       clr TR0
049A 438E08     326       orl CKCON, #0x08
049D 5389F0     327       anl TMOD,  #0xF0
04A0 438901     328       orl TMOD,  #0x01      ; 16-bit mode
04A3            329       ; ADC pins: P1.1 (AIN7), P1.7 (AIN0)
04A3 43B382     330       orl P1M1, #0b10000010 ; Set P1.1 & P1.7 as input
04A6 53B47D     331       anl P1M2, #0b01111101
04A9            332   
04A9            333       ; Initialize ADC
04A9 53E8F0     334       anl ADCCON0, #0xF0
04AC 43E807     335       orl ADCCON0, #0x07    ; default to channel 7
04AF 75F600     336       mov AINDIDS, #0x00    ; disable all digital inputs
04B2 43F681     337       orl AINDIDS, #0b10000001 ; activate AIN0 and AIN7
04B5 43E101     338       orl ADCCON1, #0x01    ; enable ADC
04B8 22         339       ret
04B9            340   
04B9            341   ;----------------------------------------------------------------------
04B9            342   ; Delay Routines
04B9            343   ;----------------------------------------------------------------------
04B9            344   wait_1ms:
04B9 C28C       345       clr TR0
04BB C28D       346       clr TF0
04BD 758CFB     347       mov TH0, #high(TIMER0_RELOAD)
04C0 758A33     348       mov TL0, #low(TIMER0_RELOAD)
04C3 D28C       349       setb TR0
04C5 308DFD     350       jnb TF0, $
04C8 22         351       ret
04C9            352   
04C9            353   ; Wait R2 milliseconds
04C9            354   waitms:
04C9 1204B9     355       lcall wait_1ms
04CC DAFB       356       djnz R2, waitms
04CE 22         357       ret
04CF            358   
04CF            359   ;----------------------------------------------------------------------
04CF            360   ; LCD_PB: Read the 5 push buttons into PB0..PB4 bits
04CF            361   ;----------------------------------------------------------------------
04CF            362   LCD_PB:
04CF            363       ; Default all PB bits to 1 (released)
04CF D20B       364       setb PB0 
04D1 D20C       365       setb PB1
04D3 D20D       366       setb PB2
04D5 D20E       367       setb PB3
04D7 D20F       368       setb PB4
04D9            369       ; The input pin is idle-high (pull-up)
04D9 D295       370       setb PB_INPUT_PIN
04DB            371   
04DB            372       ; Set MUX lines to 0 first
04DB C293       373       clr MUX_CONTROL_0
04DD C280       374       clr MUX_CONTROL_1
04DF C281       375       clr MUX_CONTROL_2
04E1 C282       376       clr MUX_CONTROL_3
04E3 C283       377       clr MUX_CONTROL_4
04E5            378   
04E5            379       ;---------------------------------
04E5            380       ; Debouncing
04E5            381       ;---------------------------------
04E5 20953A     382       jb  PB_INPUT_PIN, LCD_PB_Done 
04E8 7A32       383       mov R2, #50
04EA 1204C9     384       lcall waitms
04ED            385       
04ED 209532     386       jb  PB_INPUT_PIN, LCD_PB_Done
04F0            387   
04F0            388       ; Now set all MUX lines = 1 to read them individually
04F0 D293       389       setb MUX_CONTROL_0
04F2 D280       390       setb MUX_CONTROL_1
04F4 D281       391       setb MUX_CONTROL_2
04F6 D282       392       setb MUX_CONTROL_3
04F8 D283       393       setb MUX_CONTROL_4
04FA            394   
04FA            395       ; Check PB4
04FA C283       396       clr MUX_CONTROL_4
04FC A295       397       mov c, PB_INPUT_PIN
04FE 920F       398       mov PB4, c
0500 D283       399       setb MUX_CONTROL_4
0502            400   
0502            401       ; Check PB3
0502 C282       402       clr MUX_CONTROL_3
0504 A295       403       mov c, PB_INPUT_PIN
0506 920E       404       mov PB3, c
0508 D282       405       setb MUX_CONTROL_3
050A            406   
050A            407       ; Check PB2
050A C281       408       clr MUX_CONTROL_2
050C A295       409       mov c, PB_INPUT_PIN
050E 920D       410       mov PB2, c
0510 D281       411       setb MUX_CONTROL_2
0512            412   
0512            413       ; Check PB1
0512 C280       414       clr MUX_CONTROL_1
0514 A295       415       mov c, PB_INPUT_PIN
0516 920C       416       mov PB1, c
0518 D280       417       setb MUX_CONTROL_1
051A            418   
051A            419       ; Check PB0
051A C293       420       clr MUX_CONTROL_0
051C A295       421       mov c, PB_INPUT_PIN
051E 920B       422       mov PB0, c
0520 D293       423       setb MUX_CONTROL_0
0522            424   
0522            425   LCD_PB_Done:
0522 22         426       ret
0523            427   
0523            428   ;----------------------------------------------------------------------
0523            429   ; Display_formated_BCD: Display the result with decimal
0523            430   ;----------------------------------------------------------------------
0523            431   Display_formated_BCD:
0523 C0E0       432            push acc
0525 7401       432            mov a, #1
0527 14         432            dec a
0528 1200DB     432            lcall ?Set_Cursor_2 ; Select column and row
052B D0E0       432            pop acc
052D C000       433            push ar0
052F A83A       433            mov r0, bcd+2
0531 1200E2     433            lcall ?Display_BCD
0534 D000       433            pop ar0
0536 C000       434            push ar0
0538 A839       434            mov r0, bcd+1
053A 1200E2     434            lcall ?Display_BCD
053D D000       434            pop ar0
053F C0E0       435            push acc
0541 742E       435            mov a, #'.'
0543 120093     435            lcall ?WriteData
0546 D0E0       435            pop acc
0548 C000       436            push ar0
054A A838       436            mov r0, bcd+0
054C 1200E2     436            lcall ?Display_BCD
054F D000       436            pop ar0
0551 C0E0       437            push acc
0553 74DF       437            mov a, #0xDF
0555 120093     437            lcall ?WriteData
0558 D0E0       437            pop acc    ; Degree symbol
055A C0E0       438            push acc
055C 7443       438            mov a, #'C'
055E 120093     438            lcall ?WriteData
0561 D0E0       438            pop acc
0563 C0E0       439            push acc
0565 7401       439            mov a, #1
0567 14         439            dec a
0568 1200DB     439            lcall ?Set_Cursor_2 ; Select column and row
056B D0E0       439            pop acc
056D C0E0       440            push acc
056F 7420       440            mov a, #' '
0571 120093     440            lcall ?WriteData
0574 D0E0       440            pop acc
0576 22         441       ret
0577            442   
0577            443   ;----------------------------------------------------------------------
0577            444   ; Read_ADC: reads current ADC channel into R0:R1 (12-bit)
0577            445   ;----------------------------------------------------------------------
0577            446   Read_ADC:
0577 C2EF       447       clr  ADCF
0579 D2EE       448       setb ADCS
057B 30EFFD     449       jnb  ADCF, $          ; Wait conversion
057E E5C2       450       mov  a, ADCRL
0580 540F       451       anl  a, #0x0F
0582 F8         452       mov  R0, a
0583 E5C3       453       mov  a, ADCRH
0585 C4         454       swap a
0586 C0E0       455       push acc
0588 540F       456       anl  a, #0x0F
058A F9         457       mov  R1, a
058B D0E0       458       pop  acc
058D 54F0       459       anl  a, #0xF0
058F 48         460       orl  a, R0
0590 F8         461       mov  R0, a
0591 22         462       ret
0592            463   
0592            464   ;----------------------------------------------------------------------
0592            465   ; New code for push-button-based FSM parameter updates
0592            466   ; We intercept button presses in SendSerial
0592            467   ;----------------------------------------------------------------------
0592            468   SendBCD:
0592            469   
0592 E53A       470            mov a, bcd+2
0594 540F       471            anl a, #0x0F ; Isolate ones place
0596 2430       472            add a, #'0' ; Convert value to ASCII
0598 120645     473            lcall SendSerial
059B            474   
059B E539       475            mov a, bcd+1
059D 54F0       476            anl a, #0xF0 ; Isolate tens place
059F C4         477            swap a ; Put high nibble into lower nibble
05A0 2430       478            add a, #'0' ; Convert value to ASCII
05A2 120645     479            lcall SendSerial
05A5            480   
05A5 E539       481            mov a, bcd+1
05A7 540F       482            anl a, #0x0F ; Isolate ones place
05A9 2430       483            add a, #'0' ; Convert value to ASCII
05AB 120645     484            lcall SendSerial
05AE            485   
05AE 742E       486            mov a, #'.'
05B0 120645     487            lcall SendSerial
05B3            488   
05B3 E538       489            mov a, bcd+0
05B5 54F0       490            anl a, #0xF0 ; Isolate 0.1 place
05B7 C4         491            swap a ; Put high nibble into lower nibble
05B8 2430       492            add a, #'0' ; Convert value to ASCII
05BA 120645     493            lcall SendSerial
05BD            494   
05BD E538       495            mov a, bcd+0
05BF 540F       496            anl a, #0x0F ; Isolate 0.01 place
05C1 2430       497            add a, #'0' ; Convert value to ASCII
05C3 120645     498            lcall SendSerial
05C6            499   
05C6 7420       500       mov a, #' '
05C8 120645     501       lcall SendSerial
05CB            502   
05CB 7400       503       mov a, #0
05CD A206       504       mov c, temp_state1
05CF 92E0       505       mov acc.0, c
05D1 2430       506       add a, #'0'
05D3 120645     507       lcall SendSerial
05D6            508       
05D6 7420       509       mov a, #' '
05D8 120645     510       lcall SendSerial
05DB            511       
05DB E53F       512       mov a, state
05DD 2430       513       add a, #'0'
05DF 120645     514       lcall SendSerial
05E2            515   
05E2 7420       516       mov a, #' '
05E4 120645     517       lcall SendSerial
05E7            518   
05E7 7400       519       mov a, #0
05E9 A209       520       mov c, debug_bit
05EB 92E0       521       mov acc.0, c
05ED 2430       522       add a, #'0'
05EF 120645     523       lcall SendSerial
05F2            524   
05F2 7420       525       mov a, #' '
05F4 120645     526       lcall SendSerial
05F7            527       
05F7 E569       528       mov a, state_sec
05F9 2430       529       add a, #'0'
05FB 120645     530       lcall SendSerial
05FE            531   
05FE 7420       532       mov a, #' '
0600 120645     533       lcall SendSerial
0603            534       
0603 E568       535       mov a, seconds
0605 2430       536       add a, #'0'
0607 120645     537       lcall SendSerial
060A            538   
060A 7420       539       mov a, #' '
060C 120645     540       lcall SendSerial
060F            541   
060F 7420       542       mov a, #' '
0611 120645     543       lcall SendSerial
0614            544   
0614 7400       545       mov a, #0
0616 A20A       546       mov c, kill_flag
0618 92E0       547       mov acc.0, c
061A 2430       548       add a, #'0'
061C 120645     549       lcall SendSerial
061F            550   
061F 7420       551       mov a, #' '
0621 120645     552       lcall SendSerial
0624            553   
0624 7400       554       mov a, #0
0626 A205       555       mov c, start
0628 92E0       556       mov acc.0, c
062A 2430       557       add a, #'0'
062C 120645     558       lcall SendSerial
062F            559   
062F 7400       560       mov a, #0
0631 A284       561       mov c, SSR_BOX
0633 92E0       562       mov acc.0, c
0635 2430       563       add a, #'0'
0637 120645     564       lcall SendSerial
063A            565   
063A 740A       566            mov a, #'\n'
063C 120645     567            lcall SendSerial
063F            568   
063F 740D       569            mov a, #'\r'
0641 120645     570            lcall SendSerial
0644            571   
0644 22         572            ret
0645            573   
0645            574   
0645            575   SendSerial:
0645            576       ; Simulate sending 'a' to UART
0645 C299       577       clr  TI
0647 F599       578       mov  SBUF, a
0649            579       ; Wait for TX
0649            580   WaitTx:
0649 3099FD     581       jnb TI, WaitTx
064C C299       582       clr TI
064E            583   
064E            584       ; Now check buttons each time we "send":
064E            585       ; If button is pressed (bit=0), jump to its handler.
064E 300B0A     586       jnb PB0, start_oven
0651 300C1C     587       jnb PB1, toggle_state
0654 300D27     588       jnb PB2, inc_value
0657 300E46     589       jnb PB3, dec_value
065A            590       ; PB4 is unused for now, do nothing if pressed.
065A            591   
065A 22         592       ret
065B            593   
065B            594   ; Start the FSM
065B            595   start_oven:
065B C3         596            clr c
065C A205       597       mov c, start
065E E4         598       clr a
065F 92E0       599       mov acc.0, c
0661 F4         600       cpl a                                ; set the flag to 1, indicating that the FSM should begin
0662 F505       601       mov start, a
0664 E4         602       clr a
0665 C3         603       clr c
0666 A20A       604       mov c, kill_flag
0668 92E0       605       mov acc.0, c
066A F4         606       cpl a                    ; compliment kill 
066B F50A       607       mov kill_flag, a
066D            608       
066D            609       ;mov start, # 1                                ; return to main or update display as needed
066D 0206C6     610       ljmp end_button_logic           ; jump to exit logic
0670            611   
0670            612   ; Toggle which parameter is selected (1..4)
0670            613   toggle_state:
0670 E55F       614       mov a, selected_state           ; load the selected state to the accumulator
0672 2401       615       add a, #1                       ; icnrement the selection
0674 B40502     616       cjne a, #5, noWrap              ; if not greater than 4, jump to noWrap
0677 7401       617       mov a, #1                       ; if (selected_state == 5), reset the selected state, i.e. selected_state == 1
0679            618   noWrap:
0679 F55F       619       mov selected_state, a           ; store the updated selected_state
067B 0206C6     620       ljmp end_button_logic           ; jump to exit logic
067E            621   
067E            622   ; Increment whichever parameter is selected
067E            623   ; ** DOUBLE CHECK THIS LOGIC IM NOT TOO SURE **
067E            624   inc_value:
067E E55F       625       mov a, selected_state           ; load the selected state into the accumulator
0680 B40105     626       cjne a, #1, checkState2         ; if selected_state != temp_soak, check the next selected state
0683 0564       627       inc temp_soak                   ; increment temp_soak if above condition not true
0685 0206C6     628       ljmp end_button_logic           ; jump to exit logic
0688            629   
0688            630   checkState2:                    
0688 B40205     631       cjne a, #2, checkState3         ; if not time_soak, check the next parameter
068B 0565       632       inc time_soak                   ; increment time_soak
068D 0206C6     633       ljmp end_button_logic           ; jump to exit logic
0690            634   
0690            635   checkState3:
0690 B40305     636       cjne a, #3, checkState4         ; if not temp_refl, check next parameter
0693 0566       637       inc temp_refl                   ; increment temp_refl
0695 0206C6     638       ljmp end_button_logic           ; jump to exit logic
0698            639   
0698            640   checkState4:                        
0698 B4042B     641       cjne a, #4, end_button_logic    ; if not time_refl, exit 
069B 0567       642       inc time_refl                   ; inc time_refl
069D 0206C6     643       ljmp end_button_logic           ; jump to exit logic
06A0            644   
06A0            645   ; Decrement whichever parameter is selected
06A0            646   ; ** SAME IDEA BUT CHECK THE LOGIC PLEASE ** 
06A0            647   dec_value:
06A0 E55F       648       mov a, selected_state
06A2 B40106     649       cjne a, #1, dcheckState2
06A5 D5641E     650       djnz temp_soak, end_button_logic
06A8 0206C6     651       ljmp end_button_logic
06AB            652   
06AB            653   dcheckState2:
06AB B40206     654       cjne a, #2, dcheckState3
06AE D56515     655       djnz time_soak, end_button_logic
06B1 0206C6     656       ljmp end_button_logic
06B4            657   
06B4            658   dcheckState3:
06B4 B40306     659       cjne a, #3, dcheckState4
06B7 D5660C     660       djnz temp_refl, end_button_logic
06BA 0206C6     661       ljmp end_button_logic
06BD            662   
06BD            663   dcheckState4:
06BD B40406     664       cjne a, #4, end_button_logic
06C0 D56703     665       djnz time_refl, end_button_logic
06C3 0206C6     666       ljmp end_button_logic
06C6            667   
06C6            668   end_button_logic:
06C6 22         669       ret
06C7            670   
06C7            671   ;----------------------------------------------------------------------
06C7            672   ; main
06C7            673   ;----------------------------------------------------------------------
06C7            674   main:
06C7 75817F     675       mov sp, #0x7F
06CA 12046C     676       lcall Init_All
06CD 12009D     677       lcall LCD_4BIT
06D0 120368     678       lcall Timer2_Init ; initialize interupts 
06D3 D2AF       679       setb EA
06D5            680   
06D5 754601     681       mov MeasurementCounter+0, #1
06D8 754700     682       mov MeasurementCounter+1, #0
06DB 754A01     683       mov TimePerSample, #1
06DE            684   
06DE 75482C     685       mov SamplesPerDisplay+0, #low(SAMPLES_PER_DISPLAY)
06E1 754901     686       mov SamplesPerDisplay+1, #high(SAMPLES_PER_DISPLAY)
06E4            687   
06E4            688       ; We start with "state=0" (idle)
06E4 753F00     689       mov state, #0
06E7 C205       690       clr start ; compliment in start_oven
06E9 C201       691       clr m_flag
06EB D20A       692       setb kill_flag
06ED            693   
06ED            694       ; Default setpoints
06ED 75641C     695       mov temp_soak, #28
06F0 756505     696       mov time_soak, #5
06F3 75661E     697       mov temp_refl, #30
06F6 756705     698       mov time_refl, #5
06F9            699   
06F9            700       ; Which parameter we are currently adjusting: 1=temp_soak,2=time_soak,3=temp_refl,4=time_refl
06F9 755F01     701       mov selected_state, #1
06FC            702   
06FC 754B00     703       mov LastMeasurement+0, #0
06FF 754C00     704       mov LastMeasurement+1, #0
0702 754D00     705       mov LastMeasurement+2, #0
0705 754E00     706       mov LastMeasurement+3, #0
0708            707       
0708 C206       708       clr temp_state1
070A C207       709       clr temp_state3
070C C209       710       clr debug_bit
070E C203       711       clr err_tmp
0710 C204       712       clr err_tmp_150
0712 756800     713       mov seconds, #0
0715 756900     714       mov state_sec, #0
0718 756200     715       mov pwm_counter, #0
071B 756300     716       mov pwm, #0
071E            717   
071E            718       ; Show initial LCD message
071E C0E0       719            push acc
0720 7401       719            mov a, #1
0722 14         719            dec a
0723 1200DD     719            lcall ?Set_Cursor_1 ; Select column and row
0726 D0E0       719            pop acc
0728 C083       720            push dph
072A C082       720            push dpl
072C C0E0       720            push acc
072E 90002E     720            mov dptr, #test_message
0731 1200D0     720            lcall ?Send_Constant_String
0734 D0E0       720            pop acc
0736 D082       720            pop dpl
0738 D083       720            pop dph
073A            721   
073A            722   Forever:
073A            723       ; Example read reference (AIN0)
073A 53E8F0     724       anl  ADCCON0, #0xF0
073D 43E800     725       orl  ADCCON0, #0x00 ; Channel0
0740 120577     726       lcall Read_ADC
0743 883D       727       mov  VAL_LM4040+0, R0
0745 893E       728       mov  VAL_LM4040+1, R1
0747            729   
0747            730       ; Read LM335 on AIN7
0747 53E8F0     731       anl  ADCCON0, #0xF0
074A 43E807     732       orl  ADCCON0, #0x07
074D 120577     733       lcall Read_ADC
0750            734   
0750            735       ; Convert to "voltage" in x
0750 8830       736       mov  x+0, R0
0752 8931       737       mov  x+1, R1
0754 753200     738       mov  x+2, #0
0757 753300     739       mov  x+3, #0
075A 7534FF     740            mov y+0, #low (40959 % 0x10000) 
075D 75359F     740            mov y+1, #high(40959 % 0x10000) 
0760 753600     740            mov y+2, #low (40959 / 0x10000) 
0763 753700     740            mov y+3, #high(40959 / 0x10000)        ; e.g. 4.0959 => times 10000 in math
0766 120272     741       lcall mul32
0769 853D34     742       mov  y+0, VAL_LM4040+0
076C 853E35     743       mov  y+1, VAL_LM4040+1
076F 753600     744       mov  y+2, #0
0772 753700     745       mov  y+3, #0
0775 1202FF     746       lcall div32
0778            747   
0778            748       ; Add partial result to StoreMeasurements
0778 854034     749       mov  y+0, StoreMeasurements+0
077B 854135     750       mov  y+1, StoreMeasurements+1
077E 854236     751       mov  y+2, StoreMeasurements+2
0781 854337     752       mov  y+3, StoreMeasurements+3
0784 1201BD     753       lcall add32
0787 853040     754       mov  StoreMeasurements+0, x+0
078A 853141     755       mov  StoreMeasurements+1, x+1
078D 853242     756       mov  StoreMeasurements+2, x+2
0790 853343     757       mov  StoreMeasurements+3, x+3
0793            758   
0793            759       ; Read thermocouple on AIN4
0793 53E8F0     760       anl  ADCCON0, #0xF0
0796 43E804     761       orl  ADCCON0, #0x04
0799 120577     762       lcall Read_ADC
079C            763   
079C 8830       764       mov  x+0, R0
079E 8931       765       mov  x+1, R1
07A0 753200     766       mov  x+2, #0
07A3 753300     767       mov  x+3, #0
07A6 7534FF     768            mov y+0, #low (40959 % 0x10000) 
07A9 75359F     768            mov y+1, #high(40959 % 0x10000) 
07AC 753600     768            mov y+2, #low (40959 / 0x10000) 
07AF 753700     768            mov y+3, #high(40959 / 0x10000) 
07B2 120272     769       lcall mul32
07B5 853D34     770       mov  y+0, VAL_LM4040+0
07B8 853E35     771       mov  y+1, VAL_LM4040+1
07BB 753600     772       mov  y+2, #0
07BE 753700     773       mov  y+3, #0
07C1 1202FF     774       lcall div32
07C4            775   
07C4            776       ; Add partial result to StoreThermocouple
07C4 854F34     777       mov  y+0, StoreThermocouple+0
07C7 855035     778       mov  y+1, StoreThermocouple+1
07CA 855136     779       mov  y+2, StoreThermocouple+2
07CD 855237     780       mov  y+3, StoreThermocouple+3
07D0 1201BD     781       lcall add32
07D3 85304F     782       mov  StoreThermocouple+0, x+0
07D6 853150     783       mov  StoreThermocouple+1, x+1
07D9 853251     784       mov  StoreThermocouple+2, x+2
07DC 853352     785       mov  StoreThermocouple+3, x+3
07DF            786   
07DF            787       ; Delay between samples
07DF AA4A       788       mov R2, TimePerSample
07E1 1204C9     789       lcall waitms
07E4            790   
07E4            791       ; Decrement measurement counter
07E4 1546       792       dec MeasurementCounter+0
07E6 E546       793       mov a, MeasurementCounter+0
07E8 B4FF02     794       cjne a, #0xFF, CheckHigh
07EB 1547       795       dec MeasurementCounter+1
07ED            796   CheckHigh:
07ED E546       797       mov a, MeasurementCounter+0
07EF 4547       798       orl a, MeasurementCounter+1
07F1 6003       799       jz  DisplayValue
07F3 02095A     800       ljmp EndForever
07F6            801   
07F6            802   ;----------------------------------------------------------------------
07F6            803   ; If enough measurements collected -> compute final temperature
07F6            804   ;----------------------------------------------------------------------
07F6            805   DisplayValue:
07F6 753400     806            mov y+0, #low (0 % 0x10000) 
07F9 753500     806            mov y+1, #high(0 % 0x10000) 
07FC 753600     806            mov y+2, #low (0 / 0x10000) 
07FF 753700     806            mov y+3, #high(0 / 0x10000) 
0802            807       ; Combine for LM335 reading
0802 854030     808       mov x+0, StoreMeasurements+0
0805 854131     809       mov x+1, StoreMeasurements+1
0808 854232     810       mov x+2, StoreMeasurements+2
080B 854333     811       mov x+3, StoreMeasurements+3
080E E548       812       mov a, SamplesPerDisplay+0
0810 F534       813       mov y+0, a
0812 F546       814       mov MeasurementCounter+0, a
0814 E549       815       mov a, SamplesPerDisplay+1
0816 F535       816       mov y+1, a
0818 F547       817       mov MeasurementCounter+1, a
081A 1202FF     818       lcall div32
081D            819   
081D            820       ; Subtract 273.00 => Celsius reading
081D 7534A4     821            mov y+0, #low (27300 % 0x10000) 
0820 75356A     821            mov y+1, #high(27300 % 0x10000) 
0823 753600     821            mov y+2, #low (27300 / 0x10000) 
0826 753700     821            mov y+3, #high(27300 / 0x10000) 
0829 1201DE     822       lcall sub32
082C 853057     823       mov FinalLM335+0, x+0
082F 853158     824       mov FinalLM335+1, x+1
0832 853259     825       mov FinalLM335+2, x+2
0835 85335A     826       mov FinalLM335+3, x+3
0838            827   
0838            828       ; Combine for thermocouple reading
0838 753400     829            mov y+0, #low (0 % 0x10000) 
083B 753500     829            mov y+1, #high(0 % 0x10000) 
083E 753600     829            mov y+2, #low (0 / 0x10000) 
0841 753700     829            mov y+3, #high(0 / 0x10000) 
0844 854F30     830       mov x+0, StoreThermocouple+0
0847 855031     831       mov x+1, StoreThermocouple+1
084A 855132     832       mov x+2, StoreThermocouple+2
084D 855233     833       mov x+3, StoreThermocouple+3
0850 E548       834       mov a, SamplesPerDisplay+0
0852 F534       835       mov y+0, a
0854 E549       836       mov a, SamplesPerDisplay+1
0856 F535       837       mov y+1, a
0858 1202FF     838       lcall div32
085B            839   
085B            840       ; Add thermocouple to LM335 reading => final in x
085B 753400     841            mov y+0, #low (0 % 0x10000) 
085E 753500     841            mov y+1, #high(0 % 0x10000) 
0861 753600     841            mov y+2, #low (0 / 0x10000) 
0864 753700     841            mov y+3, #high(0 / 0x10000) 
0867 855734     842       mov y+0, FinalLM335+0
086A 855835     843       mov y+1, FinalLM335+1
086D 855936     844       mov y+2, FinalLM335+2
0870 855A37     845       mov y+3, FinalLM335+3
0873 1201BD     846       lcall add32
0876            847   
0876 85305B     848       mov FinalTemp+0, x+0
0879 85315C     849       mov FinalTemp+1, x+1
087C 85325D     850       mov FinalTemp+2, x+2
087F 85335E     851       mov FinalTemp+3, x+3
0882            852   
0882            853       ; --------------------------------------------------------
0882            854       ; Compare final temperature with soak/reflow setpoints
0882            855       ; --------------------------------------------------------
0882 C200       856       clr mf
0884 753464     857            mov y+0, #low (100 % 0x10000) 
0887 753500     857            mov y+1, #high(100 % 0x10000) 
088A 753600     857            mov y+2, #low (100 / 0x10000) 
088D 753700     857            mov y+3, #high(100 / 0x10000) 
0890 856430     858       mov x+0, temp_soak
0893 753100     859       mov x+1, #0
0896 753200     860       mov x+2, #0
0899 753300     861       mov x+3, #0
089C 120272     862       lcall mul32
089F 855B34     863       mov y+0, FinalTemp+0
08A2 855C35     864       mov y+1, FinalTemp+1
08A5 855D36     865       mov y+2, FinalTemp+2
08A8 855E37     866       mov y+3, FinalTemp+3
08AB 120268     867       lcall x_lteq_y ; mf = 1 if temp_soak<=FinalTemp
08AE A200       868       mov c, mf
08B0 9206       869       mov temp_state1, c
08B2            870   
08B2 C200       871       clr mf
08B4 753464     872            mov y+0, #low (100 % 0x10000) 
08B7 753500     872            mov y+1, #high(100 % 0x10000) 
08BA 753600     872            mov y+2, #low (100 / 0x10000) 
08BD 753700     872            mov y+3, #high(100 / 0x10000) 
08C0 856630     873       mov x+0, temp_refl
08C3 753100     874       mov x+1, #0
08C6 753200     875       mov x+2, #0
08C9 753300     876       mov x+3, #0
08CC 120272     877       lcall mul32
08CF 855B34     878       mov y+0, FinalTemp+0
08D2 855C35     879       mov y+1, FinalTemp+1
08D5 855D36     880       mov y+2, FinalTemp+2
08D8 855E37     881       mov y+3, FinalTemp+3
08DB 120268     882       lcall x_lteq_y ; mf = 1 if temp_refl<=FinalTemp
08DE A200       883       mov c, mf
08E0 9207       884       mov temp_state3, c
08E2            885   
08E2            886       ; Check error states
08E2 855B30     887       mov x+0, FinalTemp+0
08E5 855C31     888       mov x+1, FinalTemp+1
08E8 855D32     889       mov x+2, FinalTemp+2
08EB 855E33     890       mov x+3, FinalTemp+3
08EE            891   
08EE C200       892       clr mf
08F0 7534A8     893            mov y+0, #low (25000 % 0x10000) 
08F3 753561     893            mov y+1, #high(25000 % 0x10000) 
08F6 753600     893            mov y+2, #low (25000 / 0x10000) 
08F9 753700     893            mov y+3, #high(25000 / 0x10000) 
08FC 12025E     894       lcall x_gteq_y ; mf = 1 if FinalTemp<=250
08FF A200       895       mov c, mf
0901 9204       896       mov err_tmp_150, c
0903            897   
0903 C200       898       clr mf
0905 753488     899            mov y+0, #low (5000 % 0x10000) 
0908 753513     899            mov y+1, #high(5000 % 0x10000) 
090B 753600     899            mov y+2, #low (5000 / 0x10000) 
090E 753700     899            mov y+3, #high(5000 / 0x10000) 
0911 12025E     900       lcall x_gteq_y ; mf = 1 if FinalTemp>=50
0914 A200       901       mov c, mf
0916 9203       902       mov err_tmp, c
0918            903   
0918 C200       904       clr mf
091A 7534B8     905            mov y+0, #low (3000 % 0x10000) 
091D 75350B     905            mov y+1, #high(3000 % 0x10000) 
0920 753600     905            mov y+2, #low (3000 / 0x10000) 
0923 753700     905            mov y+3, #high(3000 / 0x10000) 
0926 120268     906       lcall x_lteq_y ; mf = 1 if FinalTemp<=60
0929 A200       907       mov c, mf
092B 9208       908       mov temp_state5, c
092D            909   
092D            910   
092D            911   
092D            912       ; Convert FinalTemp => BCD => display
092D 1200F8     913       lcall hex2bcd
0930 120523     914       lcall Display_formated_BCD
0933 120592     915       lcall SendBCD
0936            916   
0936            917       ; Reset accumulators
0936 754000     918       mov StoreMeasurements+0, #0
0939 754100     919       mov StoreMeasurements+1, #0
093C 754200     920       mov StoreMeasurements+2, #0
093F 754300     921       mov StoreMeasurements+3, #0
0942 754F00     922       mov StoreThermocouple+0, #0
0945 755000     923       mov StoreThermocouple+1, #0
0948 755100     924       mov StoreThermocouple+2, #0
094B 755200     925       mov StoreThermocouple+3, #0
094E 755700     926       mov FinalLM335+0, #0
0951 755801     927       mov FinalLM335+1, #1
0954 755902     928       mov FinalLM335+2, #2
0957 755A03     929       mov FinalLM335+3, #3
095A            930   
095A            931   EndForever:
095A            932       ; Always read the push buttons each pass
095A 1204CF     933       lcall LCD_PB
095D            934   
095D            935   
095D 753000     936       mov x+0, #0
0960 753100     937       mov x+1, #0
0963 753200     938       mov x+2, #0
0966 753300     939       mov x+3, #0
0969 02073A     940       ljmp Forever
096C            941   
096C            942   END
