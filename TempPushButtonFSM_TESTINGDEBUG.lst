0000              1   ;----------------------------------------------------------------------
0000              2   ; 76E003 ADC test program (reflow oven controller + push buttons)
0000              3   ; Reads channel 7 on P1.1, pin 14
0000              4   ; This version uses the LM4040 voltage reference connected to pin 6 (P1.7/AIN0)
0000              5   ; Incorporates push-button control to set up times/temperatures and start FSM.
0000              6   ;----------------------------------------------------------------------
0000              7   
                  9   $LIST
0000             11   
0000             12   ;  N76E003 pinout:
0000             13   ;                               -------
0000             14   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             15   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             16   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             17   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             18   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             19   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             20   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             21   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             22   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             23   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             24   ;                               -------
0000             25   ;
0000             26   
0000             27   ;----------------------------------------------------------------------
0000             28   ; System/Timer/Constants
0000             29   ;----------------------------------------------------------------------
0000             30   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             31   BAUD              EQU 115200   ; Baud rate of UART in bps
0000             32   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             33   
0000             34   TIMER2_RATE       EQU 100      ; 100 Hz -> 10ms tick
0000             35   TIMER2_RELOAD     EQU ((65536-(CLK/(16*TIMER2_RATE))))
0000             36   
0000             37   SAMPLES_PER_DISPLAY  EQU 300
0000             38   REFRESHES_PER_SECOND EQU 45
0000             39   TIMER0_DENOM         EQU (SAMPLES_PER_DISPLAY*REFRESHES_PER_SECOND)
0000             40   TIMER0_RELOAD        EQU (0x10000-(CLK/TIMER0_DENOM))
0000             41   
0000             42   ORG 0x0000
0000 020723      43       ljmp main
0003             44   
002B             45   org 0x002B
002B 0203BF      46       ljmp Timer2_ISR
002E             47   
002E             48   ;----------------------------------------------------------------------
002E             49   ; Hardware Pin Definitions
002E             50   ;----------------------------------------------------------------------
002E             51   
002E             52   ; PUSH BUTTONS (single-pin read approach)
002E             53   PB_INPUT_PIN   EQU P1.5  ; The single pin used to read all 5 PBs
002E             54   MUX_CONTROL_0  EQU P1.3  
002E             55   MUX_CONTROL_1  EQU P0.0  
002E             56   MUX_CONTROL_2  EQU P0.1  
002E             57   MUX_CONTROL_3  EQU P0.2  
002E             58   MUX_CONTROL_4  EQU P0.3  
002E             59   
002E             60   ; LCD assignments
002E             61   LCD_RS  equ P1.3
002E             62   LCD_E   equ P1.4
002E             63   LCD_D4  equ P0.0
002E             64   LCD_D5  equ P0.1
002E             65   LCD_D6  equ P0.2
002E             66   LCD_D7  equ P0.3
002E             67   SSR_BOX equ P0.4
002E             68   
002E             69   ; Strings for LCD
002E 43757272    70   test_message:     db 'Current Temp.:', 0
     656E7420
     54656D70
     2E3A00
003D 4465672E    71   value_message:    db 'Deg. C', 0
     204300
0044             72   
0044 54656D70    73   temp_soak_string: db 'Temp Soak: ', 0
     20536F61
     6B3A2000
0050 54696D65    74   time_soak_string: db 'Time Soak: ', 0
     20536F61
     6B3A2000
005C 54696D65    75   temp_refl_string: db 'Time Reflow: ', 0
     20526566
     6C6F773A
     2000
006A 54696D65    76   time_refl_string: db 'Time Reflow: ', 0
     20526566
     6C6F773A
     2000
0078             77   
0078 204300      78   degree_label: db ' C', 0
007B 207300      79   seconds_label: db ' s', 0
007E             80   
007E             81   
007E             82   cseg
007E             83   
                 85   	$LIST
0132             87   
0132             88   ;----------------------------------------------------------------------
0132             89   ; 32-bit math placeholders
0132             90   ;----------------------------------------------------------------------
0030             91   DSEG at 30H
0030             92   x:   ds 4
0034             93   y:   ds 4
0038             94   bcd: ds 5
003D             95   VAL_LM4040: ds 2
003F             96   
003F             97   ; Variables
003F             98   state:              ds 1
0040             99   StoreMeasurements:  ds 4
0044            100   TempStore:          ds 2
0046            101   MeasurementCounter: ds 2
0048            102   SamplesPerDisplay:  ds 2
004A            103   TimePerSample:      ds 1
004B            104   LastMeasurement:    ds 4
004F            105   StoreThermocouple:  ds 4
0053            106   CurrentTemp:        ds 4
0057            107   FinalLM335:         ds 4
005B            108   FinalTemp:          ds 4
005F            109   selected_state:          ds 1
0060            110   
0060            111   Count1ms:      ds 2
0062            112   pwm_counter:   ds 1
0063            113   pwm:           ds 1
0064            114   
0064            115   ; Oven settings
0064            116   temp_soak: ds 1  ; For state 1
0065            117   time_soak: ds 1  ; For state 2
0066            118   temp_refl: ds 1  ; For state 3
0067            119   time_refl: ds 1  ; For state 4
0068            120   
0068            121   seconds: ds 1
0069            122   state_sec: ds 1
006A            123   
006A            124   ;----------------------------------------------------------------------
006A            125   ; Bit variables (BSEG)
006A            126   ;----------------------------------------------------------------------
0000            127   BSEG
0000            128   mf:            dbit 1
0001            129   m_flag:        dbit 1
0002            130   s_flag:        dbit 1
0003            131   err_tmp:       dbit 1
0004            132   err_tmp_150:   dbit 1
0005            133   
0005            134   start:         dbit 1  ; Start the FSM
0006            135   temp_state1:   dbit 1
0007            136   temp_state3:   dbit 1
0008            137   temp_state5:   dbit 1
0009            138   
0009            139   debug_bit:     dbit 1 ;Set to true to check which lines of code actually execute
000A            140   
000A            141   kill_flag:      dbit 1 ; kill switch
000B            142   
000B            143   ; For push buttons
000B            144   PB0: dbit 1  ; Start/Pause
000C            145   PB1: dbit 1  ; Toggle selected parameter
000D            146   PB2: dbit 1  ; Increment
000E            147   PB3: dbit 1  ; Decrement
000F            148   PB4: dbit 1  ; Unused or extra
0010            149   
0010            150   ;SETATS
0010            151   
0010            152   ; We include math32 at the end of initialization
                546   $LIST
                154   $LIST
03A2            156   
03A2            157   ;----------------------------------------------------------------------
03A2            158   ; Timer2 Initialization & ISR
03A2            159   ;----------------------------------------------------------------------
03A2            160   Timer2_Init:
03A2 75C800     161       mov T2CON, #0       ; Stop timer, mode = auto-reload
03A5 75CDD7     162       mov TH2, #high(TIMER2_RELOAD)
03A8 75CC79     163       mov TL2, #low(TIMER2_RELOAD)
03AB 43C9A0     164       orl T2MOD, #0b1010_0000    ; Enable auto-reload
03AE 75CBD7     165       mov RCMP2H, #high(TIMER2_RELOAD)
03B1 75CA79     166       mov RCMP2L, #low(TIMER2_RELOAD)
03B4 E4         167       clr  a
03B5 F560       168       mov  Count1ms+0, a
03B7 F561       169       mov  Count1ms+1, a
03B9 439B80     170       orl  EIE, #0x80     ; Enable timer2 interrupt (ET2=1)
03BC D2CA       171       setb TR2            ; Start Timer2
03BE 22         172       ret
03BF            173   
03BF            174   Timer2_ISR:
03BF C2CF       175       clr TF2 ; Must clear TF2 manually on N76
03C1 C0E0       176       push acc
03C3 C0D0       177       push psw
03C5            178   
03C5            179       ;---------------------------------
03C5            180       ; PWM for SSR control
03C5            181       ;---------------------------------
03C5 0562       182       inc pwm_counter ;Every 10ms, pwm_counter is incremented
03C7 C3         183       clr c
03C8 E563       184       mov a, pwm
03CA 9562       185       subb a, pwm_counter ; if pwm_counter <= pwm, c=1, so if pwm=20 for example, if 210ms has passed, c = 0, and the SSR box is always on
03CC B3         186       cpl c
03CD 9284       187       mov SSR_BOX, c
03CF            188   
03CF E562       189       mov a, pwm_counter
03D1 B46412     190       cjne a, #100, State_0 ; If 1 second has not passed, skip to State_0
03D4 756200     191       mov pwm_counter, #0 ; Reset pwm_counter
03D7 0568       192       inc seconds ; Increment seconds
03D9 0569       193       inc state_sec ; Will only increment in states 2 and 4, gets reset to 0 in all other states otherrwise
03DB E4         194       clr a
03DC E568       195       mov a, seconds
03DE B43C05     196       cjne a, #60, State_0 ;If exactly 60 seconds has not passed, skip to State_0, otherwise set m_flag to indicate a minute has passed
03E1 D201       197       setb m_flag
03E3 0203E6     198       ljmp State_0
03E6            199   
03E6            200   
03E6            201   State_0:
03E6 E53F       202       mov a, state
03E8 B40010     203            cjne a, #0, State_1
03EB E4         204       clr a
03EC 756900     205       mov state_sec, #0
03EF 756300     206            mov pwm, #0
03F2 300552     207            jnb start, jumpy 
03F5 753F01     208            mov state, #1
03F8 0204BD     209            ljmp Timer2_ISR_done
03FB            210            
03FB            211   State_1:
03FB 200A4C     212       jb kill_flag, jumpyError
03FE E53F       213            mov a, state
0400 B40128     214            cjne a, #1, State_2
0403 756364     215            mov pwm, #100                                   ; set pwm for relfow oven to 100%
0406 756900     216       mov state_sec, #0
0409            217   ;        jb m_flag, Cond_check
0409            218   ;        mov c, temp_state1
0409            219   ;        clr a                                                   ; clear the accumulator
0409            220   ;        mov acc.0, c
0409            221   ;        clr c                                                   ; clear the carry bit
0409 30063B     222            jnb temp_state1, jumpy          ; mf = 1 if oven temp <= set temp, jump out of ISR. mf = 0 if oven temp > set temp, thus move onto next state                   
040C E4         223            clr a                                           
040D 753F02     224            mov state, #2
0410 756900     225       mov state_sec, #0
0413 02042B     226            ljmp State_2
0416            227   
0416            228   Cond_check: ; cjne is not bit-addressable, therefore we must move bits into byte registers (i.e. accumulator and register b)
0416 A203       229            mov c, err_tmp
0418 E4         230            clr a 
0419 92E0       231            mov acc.0, c ; mov value in carry to the lowest bit of the accumulator
041B A201       232            mov c, m_flag
041D C201       233            clr m_flag ; clear minute flag
041F 75F000     234            mov b, #00h 
0422 92F0       235            mov b.0, c ; mov value in carry to the lowest bit of the B regrister
0424 C3         236            clr c
0425 B5F022     237            cjne a, b, jumpyError
0428 0203FB     238            ljmp State_1
042B            239   
042B            240   State_2: ;transition to state three if more than 60 seconds have passed
042B 200A1C     241       jb kill_flag, jumpyError
042E E53F       242            mov a, state
0430 B4021A     243            cjne a, #2, State_3
0433 756314     244            mov pwm, #20
0436 20047D     245            jb err_tmp_150, State_error
0439 E4         246       clr a        
043A E569       247       mov a, state_sec
043C C3         248       clr c
043D 9565       249       subb a, time_soak ; If state_sec - time_soak is negative (so not enough time has passed), then c = 1, 
043F 407C       250       jc Timer2_ISR_done
0441 753F03     251            mov state, #3
0444 756900     252       mov state_sec, #0
0447            253   
0447            254   jumpy:
0447 0204BD     255       ljmp Timer2_ISR_done
044A            256   jumpyError:
044A 0204B6     257       ljmp State_error
044D            258   
044D            259   State_3: 
044D 200A66     260       jb kill_flag, State_error
0450 E53F       261            mov a, state
0452 B40313     262            cjne a, #3, State_4 ; check if state = 3, if not, move to state_4
0455 756364     263            mov pwm, #100 ; set pwm to 100%
0458 756900     264       mov state_sec, #0
045B 200458     265            jb err_tmp_150, State_error
045E            266            ;mov c, temp_state3
045E            267            ;clr a                                                          ; clear the accumulator
045E            268            ;mov acc.0, c
045E            269            ;clr c                                                          ; clear the carry bit
045E            270            ;cjne a, #0, Timer2_ISR_done ;
045E 30075C     271       jnb temp_state3, Timer2_ISR_done
0461 E4         272            clr a
0462 756900     273       mov state_sec, #0
0465 753F04     274            mov state, #4
0468            275   
0468            276   State_4:
0468 200A4B     277       jb kill_flag, State_error
046B E53F       278            mov a, state
046D B40413     279            cjne a, #4, State_5
0470 756314     280            mov pwm, #20
0473 200440     281            jb err_tmp_150, State_error
0476 E4         282       clr a
0477 E569       283       mov a, state_sec
0479 9567       284       subb a, time_refl
047B 4040       285       jc Timer2_ISR_Done    
047D 753F05     286            mov state, #5
0480 756900     287       mov state_sec, #0
0483            288   
0483            289   State_5:
0483 200A30     290       jb kill_flag, State_error
0486 E53F       291            mov a, state
0488 B40532     292            cjne a, #5, Timer2_ISR_done
048B 756300     293            mov pwm, #0
048E 756900     294       mov state_sec, #0
0491 C3         295       clr c
0492 A205       296       mov c, start
0494 E4         297       clr a
0495 92E0       298       mov acc.0, c
0497 F4         299       cpl a                                ; set the flag to 1, indicating that the FSM should begin
0498 A2E0       300       mov c, acc.0
049A 9205       301       mov start, c
049C E4         302       clr a
049D C3         303       clr c
049E A20A       304       mov c, kill_flag
04A0 92E0       305       mov acc.0, c
04A2 F4         306       cpl a                    ; compliment kill
04A3 A2E0       307       mov c, acc.0 
04A5 920A       308       mov kill_flag, c
04A7 20040C     309       jb err_tmp_150, State_error
04AA 300810     310       jnb temp_state5, Timer2_ISR_done
04AD 753F00     311            mov state, #0
04B0 756900     312       mov state_sec, #0
04B3            313       
04B3 0204BD     314       ljmp Timer2_ISR_done
04B6            315   
04B6            316   State_error:
04B6 7400       317            mov a, #0
04B8 F53F       318            mov state, a
04BA 0204BD     319       ljmp Timer2_ISR_done
04BD            320            ; probably should put branch for warning message here
04BD            321   
04BD            322   Timer2_ISR_done:
04BD D0D0       323       pop psw
04BF D0E0       324       pop acc
04C1 32         325       reti
04C2            326   
04C2            327   ;----------------------------------------------------------------------
04C2            328   ; Initialization
04C2            329   ;----------------------------------------------------------------------
04C2            330   Init_All:
04C2            331       ; Configure all the pins for bidirectional I/O
04C2 75AC00     332       mov P3M1, #0x00
04C5 75AD00     333       mov P3M2, #0x00
04C8 75B300     334       mov P1M1, #0x00
04CB 75B400     335       mov P1M2, #0x00
04CE 75B100     336       mov P0M1, #0x00
04D1 75B200     337       mov P0M2, #0x00
04D4            338   
04D4 1203A2     339       lcall Timer2_Init
04D7            340   
04D7            341       ; Timer1 for UART
04D7 438E10     342       orl  CKCON, #0x10     ; Timer1 uses system clock
04DA 438780     343       orl  PCON,  #0x80     ; SMOD=1 -> double baud
04DD 759852     344       mov  SCON,  #0x52     ; UART mode 1, REN=1
04E0 53C4DF     345       anl  T3CON, #0b11011111
04E3 53890F     346       anl  TMOD,  #0x0F
04E6 438920     347       orl  TMOD,  #0x20     ; Timer1 Mode2 (8-bit auto-reload)
04E9 758DF7     348       mov  TH1, #TIMER1_RELOAD
04EC D28E       349       setb TR1
04EE            350   
04EE            351       ; Timer0 for waitms
04EE C28C       352       clr TR0
04F0 438E08     353       orl CKCON, #0x08
04F3 5389F0     354       anl TMOD,  #0xF0
04F6 438901     355       orl TMOD,  #0x01      ; 16-bit mode
04F9            356       ; ADC pins: P1.1 (AIN7), P1.7 (AIN0)
04F9 43B382     357       orl P1M1, #0b10000010 ; Set P1.1 & P1.7 as input
04FC 53B47D     358       anl P1M2, #0b01111101
04FF            359   
04FF            360       ; Initialize ADC
04FF 53E8F0     361       anl ADCCON0, #0xF0
0502 43E807     362       orl ADCCON0, #0x07    ; default to channel 7
0505 75F600     363       mov AINDIDS, #0x00    ; disable all digital inputs
0508 43F681     364       orl AINDIDS, #0b10000001 ; activate AIN0 and AIN7
050B 43E101     365       orl ADCCON1, #0x01    ; enable ADC
050E 22         366       ret
050F            367   
050F            368   ;----------------------------------------------------------------------
050F            369   ; Delay Routines
050F            370   ;----------------------------------------------------------------------
050F            371   wait_1ms:
050F C28C       372       clr TR0
0511 C28D       373       clr TF0
0513 758CFB     374       mov TH0, #high(TIMER0_RELOAD)
0516 758A33     375       mov TL0, #low(TIMER0_RELOAD)
0519 D28C       376       setb TR0
051B 308DFD     377       jnb TF0, $
051E 22         378       ret
051F            379   
051F            380   ; Wait R2 milliseconds
051F            381   waitms:
051F 12050F     382       lcall wait_1ms
0522 DAFB       383       djnz R2, waitms
0524 22         384       ret
0525            385   
0525            386   ;----------------------------------------------------------------------
0525            387   ; LCD_PB: Read the 5 push buttons into PB0..PB4 bits
0525            388   ;----------------------------------------------------------------------
0525            389   LCD_PB:
0525            390       ; Default all PB bits to 1 (released)
0525 D20B       391       setb PB0 
0527 D20C       392       setb PB1
0529 D20D       393       setb PB2
052B D20E       394       setb PB3
052D D20F       395       setb PB4
052F            396       ; The input pin is idle-high (pull-up)
052F D295       397       setb PB_INPUT_PIN
0531            398   
0531            399       ; Set MUX lines to 0 first
0531 C293       400       clr MUX_CONTROL_0
0533 C280       401       clr MUX_CONTROL_1
0535 C281       402       clr MUX_CONTROL_2
0537 C282       403       clr MUX_CONTROL_3
0539 C283       404       clr MUX_CONTROL_4
053B            405   
053B            406       ;---------------------------------
053B            407       ; Debouncing
053B            408       ;---------------------------------
053B 209537     409       jb  PB_INPUT_PIN, LCD_PB_Done 
053E 7A1E       410       mov R2, #30
0540 12051F     411       lcall waitms
0543            412   
0543            413       ; Now set all MUX lines = 1 to read them individually
0543 D293       414       setb MUX_CONTROL_0
0545 D280       415       setb MUX_CONTROL_1
0547 D281       416       setb MUX_CONTROL_2
0549 D282       417       setb MUX_CONTROL_3
054B D283       418       setb MUX_CONTROL_4
054D            419   
054D            420       ; Check PB4
054D C283       421       clr MUX_CONTROL_4
054F A295       422       mov c, PB_INPUT_PIN
0551 920F       423       mov PB4, c
0553 D283       424       setb MUX_CONTROL_4
0555            425   
0555            426       ; Check PB3
0555 C282       427       clr MUX_CONTROL_3
0557 A295       428       mov c, PB_INPUT_PIN
0559 920E       429       mov PB3, c
055B D282       430       setb MUX_CONTROL_3
055D            431   
055D            432       ; Check PB2
055D C281       433       clr MUX_CONTROL_2
055F A295       434       mov c, PB_INPUT_PIN
0561 920D       435       mov PB2, c
0563 D281       436       setb MUX_CONTROL_2
0565            437   
0565            438       ; Check PB1
0565 C280       439       clr MUX_CONTROL_1
0567 A295       440       mov c, PB_INPUT_PIN
0569 920C       441       mov PB1, c
056B D280       442       setb MUX_CONTROL_1
056D            443   
056D            444       ; Check PB0
056D C293       445       clr MUX_CONTROL_0
056F A295       446       mov c, PB_INPUT_PIN
0571 920B       447       mov PB0, c
0573 D293       448       setb MUX_CONTROL_0
0575            449   
0575            450   LCD_PB_Done:
0575 22         451       ret
0576            452   
0576            453   ;----------------------------------------------------------------------
0576            454   ; Display_formated_BCD: Display the result with decimal
0576            455   ;----------------------------------------------------------------------
0576            456   Display_formated_BCD:
0576 C0E0       457            push acc
0578 7401       457            mov a, #1
057A 14         457            dec a
057B 120115     457            lcall ?Set_Cursor_2 ; Select column and row
057E D0E0       457            pop acc
0580 C000       458            push ar0
0582 A83A       458            mov r0, bcd+2
0584 12011C     458            lcall ?Display_BCD
0587 D000       458            pop ar0
0589 C000       459            push ar0
058B A839       459            mov r0, bcd+1
058D 12011C     459            lcall ?Display_BCD
0590 D000       459            pop ar0
0592 C0E0       460            push acc
0594 742E       460            mov a, #'.'
0596 1200CD     460            lcall ?WriteData
0599 D0E0       460            pop acc
059B C000       461            push ar0
059D A838       461            mov r0, bcd+0
059F 12011C     461            lcall ?Display_BCD
05A2 D000       461            pop ar0
05A4 C0E0       462            push acc
05A6 74DF       462            mov a, #0xDF
05A8 1200CD     462            lcall ?WriteData
05AB D0E0       462            pop acc    ; Degree symbol
05AD C0E0       463            push acc
05AF 7443       463            mov a, #'C'
05B1 1200CD     463            lcall ?WriteData
05B4 D0E0       463            pop acc
05B6 C0E0       464            push acc
05B8 7401       464            mov a, #1
05BA 14         464            dec a
05BB 120115     464            lcall ?Set_Cursor_2 ; Select column and row
05BE D0E0       464            pop acc
05C0 C0E0       465            push acc
05C2 7420       465            mov a, #' '
05C4 1200CD     465            lcall ?WriteData
05C7 D0E0       465            pop acc
05C9 22         466       ret
05CA            467   
05CA            468   ;----------------------------------------------------------------------
05CA            469   ; Read_ADC: reads current ADC channel into R0:R1 (12-bit)
05CA            470   ;----------------------------------------------------------------------
05CA            471   Read_ADC:
05CA C2EF       472       clr  ADCF
05CC D2EE       473       setb ADCS
05CE 30EFFD     474       jnb  ADCF, $          ; Wait conversion
05D1 E5C2       475       mov  a, ADCRL
05D3 540F       476       anl  a, #0x0F
05D5 F8         477       mov  R0, a
05D6 E5C3       478       mov  a, ADCRH
05D8 C4         479       swap a
05D9 C0E0       480       push acc
05DB 540F       481       anl  a, #0x0F
05DD F9         482       mov  R1, a
05DE D0E0       483       pop  acc
05E0 54F0       484       anl  a, #0xF0
05E2 48         485       orl  a, R0
05E3 F8         486       mov  R0, a
05E4 22         487       ret
05E5            488   
05E5            489   ;----------------------------------------------------------------------
05E5            490   ; New code for push-button-based FSM parameter updates
05E5            491   ; We intercept button presses in SendSerial
05E5            492   ;----------------------------------------------------------------------
05E5            493   SendBCD:
05E5            494   
05E5 E53A       495            mov a, bcd+2
05E7 540F       496            anl a, #0x0F ; Isolate ones place
05E9 2430       497            add a, #'0' ; Convert value to ASCII
05EB 12069D     498            lcall SendSerial
05EE            499   
05EE E539       500            mov a, bcd+1
05F0 54F0       501            anl a, #0xF0 ; Isolate tens place
05F2 C4         502            swap a ; Put high nibble into lower nibble
05F3 2430       503            add a, #'0' ; Convert value to ASCII
05F5 12069D     504            lcall SendSerial
05F8            505   
05F8 E539       506            mov a, bcd+1
05FA 540F       507            anl a, #0x0F ; Isolate ones place
05FC 2430       508            add a, #'0' ; Convert value to ASCII
05FE 12069D     509            lcall SendSerial
0601            510   
0601 742E       511            mov a, #'.'
0603 12069D     512            lcall SendSerial
0606            513   
0606 E538       514            mov a, bcd+0
0608 54F0       515            anl a, #0xF0 ; Isolate 0.1 place
060A C4         516            swap a ; Put high nibble into lower nibble
060B 2430       517            add a, #'0' ; Convert value to ASCII
060D 12069D     518            lcall SendSerial
0610            519   
0610 E538       520            mov a, bcd+0
0612 540F       521            anl a, #0x0F ; Isolate 0.01 place
0614 2430       522            add a, #'0' ; Convert value to ASCII
0616 12069D     523            lcall SendSerial
0619            524   
0619 7420       525       mov a, #' '
061B 12069D     526       lcall SendSerial
061E            527   
061E 7400       528       mov a, #0
0620 A206       529       mov c, temp_state1
0622 92E0       530       mov acc.0, c
0624 2430       531       add a, #'0'
0626 12069D     532       lcall SendSerial
0629            533       
0629 7420       534       mov a, #' '
062B 12069D     535       lcall SendSerial
062E            536       
062E E53F       537       mov a, state
0630 2430       538       add a, #'0'
0632 12069D     539       lcall SendSerial
0635            540   
0635 7420       541       mov a, #' '
0637 12069D     542       lcall SendSerial
063A            543   
063A 7400       544       mov a, #0
063C A209       545       mov c, debug_bit
063E 92E0       546       mov acc.0, c
0640 2430       547       add a, #'0'
0642 12069D     548       lcall SendSerial
0645            549   
0645 7420       550       mov a, #' '
0647 12069D     551       lcall SendSerial
064A            552       
064A E569       553       mov a, state_sec
064C 2430       554       add a, #'0'
064E 12069D     555       lcall SendSerial
0651            556   
0651 7420       557       mov a, #' '
0653 12069D     558       lcall SendSerial
0656            559       
0656 E568       560       mov a, seconds
0658 2430       561       add a, #'0'
065A 12069D     562       lcall SendSerial
065D            563   
065D 7420       564       mov a, #' '
065F 12069D     565       lcall SendSerial
0662            566   
0662 7400       567       mov a, #0
0664 A284       568       mov c, SSR_BOX
0666 92E0       569       mov acc.0, c
0668 2430       570       add a, #'0'
066A 12069D     571       lcall SendSerial
066D            572   
066D 7420       573       mov a, #' '
066F 12069D     574       lcall SendSerial
0672 7420       575       mov a, #' '
0674 12069D     576       lcall SendSerial
0677            577   
0677 7400       578       mov a, #0
0679 A20A       579       mov c, kill_flag
067B 92E0       580       mov acc.0, c
067D 2430       581       add a, #'0'
067F 12069D     582       lcall SendSerial
0682            583   
0682 7420       584       mov a, #' '
0684 12069D     585       lcall SendSerial
0687            586   
0687 7400       587       mov a, #0
0689 A205       588       mov c, start
068B 92E0       589       mov acc.0, c
068D 2430       590       add a, #'0'
068F 12069D     591       lcall SendSerial
0692            592   
0692            593   
0692            594   
0692 740A       595            mov a, #'\n'
0694 12069D     596            lcall SendSerial
0697            597   
0697 740D       598            mov a, #'\r'
0699 12069D     599            lcall SendSerial
069C            600   
069C 22         601            ret
069D            602   
069D            603   
069D            604   SendSerial:
069D            605       ; Simulate sending 'a' to UART
069D C299       606       clr  TI
069F F599       607       mov  SBUF, a
06A1            608       ; Wait for TX
06A1            609   WaitTx:
06A1 3099FD     610       jnb TI, WaitTx
06A4 C299       611       clr TI
06A6            612   
06A6            613       ; Now check buttons each time we "send":
06A6            614       ; If button is pressed (bit=0), jump to its handler.
06A6 300B0A     615       jnb PB0, start_oven
06A9 300C20     616       jnb PB1, toggle_state
06AC 300D2B     617       jnb PB2, inc_value
06AF 300E4A     618       jnb PB3, dec_value
06B2            619       ; PB4 is unused for now, do nothing if pressed.
06B2            620   
06B2 22         621       ret
06B3            622   
06B3            623   ; Start the FSM
06B3            624   start_oven:
06B3 C3         625            clr c
06B4 A205       626       mov c, start
06B6 E4         627       clr a
06B7 92E0       628       mov acc.0, c
06B9 F4         629       cpl a                                ; set the flag to 1, indicating that the FSM should begin
06BA A2E0       630       mov c, acc.0
06BC 9205       631       mov start, c
06BE E4         632       clr a
06BF C3         633       clr c
06C0 A20A       634       mov c, kill_flag
06C2 92E0       635       mov acc.0, c
06C4 F4         636       cpl a                    ; compliment kill
06C5 A2E0       637       mov c, acc.0 
06C7 920A       638       mov kill_flag, c
06C9            639       ;mov start, # 1                                ; return to main or update display as needed
06C9 020722     640       ljmp end_button_logic           ; jump to exit logic
06CC            641   
06CC            642   ; Toggle which parameter is selected (1..4)
06CC            643   toggle_state:
06CC E55F       644       mov a, selected_state           ; load the selected state to the accumulator
06CE 2401       645       add a, #1                       ; icnrement the selection
06D0 B40502     646       cjne a, #5, noWrap              ; if not greater than 4, jump to noWrap
06D3 7401       647       mov a, #1                       ; if (selected_state == 5), reset the selected state, i.e. selected_state == 1
06D5            648   noWrap:
06D5 F55F       649       mov selected_state, a           ; store the updated selected_state
06D7 020722     650       ljmp end_button_logic           ; jump to exit logic
06DA            651   
06DA            652   ; Increment whichever parameter is selected
06DA            653   ; ** DOUBLE CHECK THIS LOGIC IM NOT TOO SURE **
06DA            654   inc_value:
06DA E55F       655       mov a, selected_state           ; load the selected state into the accumulator
06DC B40105     656       cjne a, #1, checkState2         ; if selected_state != temp_soak, check the next selected state
06DF 0564       657       inc temp_soak                   ; increment temp_soak if above condition not true
06E1 020722     658       ljmp end_button_logic           ; jump to exit logic
06E4            659   
06E4            660   checkState2:                    
06E4 B40205     661       cjne a, #2, checkState3         ; if not time_soak, check the next parameter
06E7 0565       662       inc time_soak                   ; increment time_soak
06E9 020722     663       ljmp end_button_logic           ; jump to exit logic
06EC            664   
06EC            665   checkState3:
06EC B40305     666       cjne a, #3, checkState4         ; if not temp_refl, check next parameter
06EF 0566       667       inc temp_refl                   ; increment temp_refl
06F1 020722     668       ljmp end_button_logic           ; jump to exit logic
06F4            669   
06F4            670   checkState4:                        
06F4 B4042B     671       cjne a, #4, end_button_logic    ; if not time_refl, exit 
06F7 0567       672       inc time_refl                   ; inc time_refl
06F9 020722     673       ljmp end_button_logic           ; jump to exit logic
06FC            674   
06FC            675   ; Decrement whichever parameter is selected
06FC            676   ; ** SAME IDEA BUT CHECK THE LOGIC PLEASE ** 
06FC            677   dec_value:
06FC E55F       678       mov a, selected_state
06FE B40106     679       cjne a, #1, dcheckState2
0701 D5641E     680       djnz temp_soak, end_button_logic
0704 020722     681       ljmp end_button_logic
0707            682   
0707            683   dcheckState2:
0707 B40206     684       cjne a, #2, dcheckState3
070A D56515     685       djnz time_soak, end_button_logic
070D 020722     686       ljmp end_button_logic
0710            687   
0710            688   dcheckState3:
0710 B40306     689       cjne a, #3, dcheckState4
0713 D5660C     690       djnz temp_refl, end_button_logic
0716 020722     691       ljmp end_button_logic
0719            692   
0719            693   dcheckState4:
0719 B40406     694       cjne a, #4, end_button_logic
071C D56703     695       djnz time_refl, end_button_logic
071F 020722     696       ljmp end_button_logic
0722            697   
0722            698   end_button_logic:
0722 22         699       ret
0723            700   
0723            701   ;----------------------------------------------------------------------
0723            702   ; main
0723            703   ;----------------------------------------------------------------------
0723            704   main:
0723 75817F     705       mov sp, #0x7F
0726 1204C2     706       lcall Init_All
0729 1200D7     707       lcall LCD_4BIT
072C 1203A2     708       lcall Timer2_Init ; initialize interupts 
072F D2AF       709       setb EA
0731            710   
0731 754601     711       mov MeasurementCounter+0, #1
0734 754700     712       mov MeasurementCounter+1, #0
0737 754A01     713       mov TimePerSample, #1
073A            714   
073A 75482C     715       mov SamplesPerDisplay+0, #low(SAMPLES_PER_DISPLAY)
073D 754901     716       mov SamplesPerDisplay+1, #high(SAMPLES_PER_DISPLAY)
0740            717   
0740            718       ; We start with "state=0" (idle)
0740 753F00     719       mov state, #0
0743 C205       720       clr start ; compliment in start_oven
0745 C201       721       clr m_flag
0747 D20A       722       setb kill_flag
0749            723   
0749            724       ; Default setpoints
0749 75641C     725       mov temp_soak, #28
074C 756505     726       mov time_soak, #5
074F 75661E     727       mov temp_refl, #30
0752 756705     728       mov time_refl, #5
0755            729   
0755            730       ; Which parameter we are currently adjusting: 1=temp_soak,2=time_soak,3=temp_refl,4=time_refl
0755 755F01     731       mov selected_state, #1
0758            732   
0758 754B00     733       mov LastMeasurement+0, #0
075B 754C00     734       mov LastMeasurement+1, #0
075E 754D00     735       mov LastMeasurement+2, #0
0761 754E00     736       mov LastMeasurement+3, #0
0764            737       
0764 C206       738       clr temp_state1
0766 C207       739       clr temp_state3
0768 C209       740       clr debug_bit
076A C203       741       clr err_tmp
076C C204       742       clr err_tmp_150
076E 756800     743       mov seconds, #0
0771 756900     744       mov state_sec, #0
0774 756200     745       mov pwm_counter, #0
0777 756300     746       mov pwm, #0
077A            747   
077A            748       ; Show initial LCD message
077A C0E0       749            push acc
077C 7401       749            mov a, #1
077E 14         749            dec a
077F 120117     749            lcall ?Set_Cursor_1 ; Select column and row
0782 D0E0       749            pop acc
0784 C083       750            push dph
0786 C082       750            push dpl
0788 C0E0       750            push acc
078A 90002E     750            mov dptr, #test_message
078D 12010A     750            lcall ?Send_Constant_String
0790 D0E0       750            pop acc
0792 D082       750            pop dpl
0794 D083       750            pop dph
0796            751   
0796            752   Forever:
0796            753       ; Example read reference (AIN0)
0796 53E8F0     754       anl  ADCCON0, #0xF0
0799 43E800     755       orl  ADCCON0, #0x00 ; Channel0
079C 1205CA     756       lcall Read_ADC
079F 883D       757       mov  VAL_LM4040+0, R0
07A1 893E       758       mov  VAL_LM4040+1, R1
07A3            759   
07A3            760       ; Read LM335 on AIN7
07A3 53E8F0     761       anl  ADCCON0, #0xF0
07A6 43E807     762       orl  ADCCON0, #0x07
07A9 1205CA     763       lcall Read_ADC
07AC            764   
07AC            765       ; Convert to "voltage" in x
07AC 8830       766       mov  x+0, R0
07AE 8931       767       mov  x+1, R1
07B0 753200     768       mov  x+2, #0
07B3 753300     769       mov  x+3, #0
07B6 7534FF     770            mov y+0, #low (40959 % 0x10000) 
07B9 75359F     770            mov y+1, #high(40959 % 0x10000) 
07BC 753600     770            mov y+2, #low (40959 / 0x10000) 
07BF 753700     770            mov y+3, #high(40959 / 0x10000)        ; e.g. 4.0959 => times 10000 in math
07C2 1202AC     771       lcall mul32
07C5 853D34     772       mov  y+0, VAL_LM4040+0
07C8 853E35     773       mov  y+1, VAL_LM4040+1
07CB 753600     774       mov  y+2, #0
07CE 753700     775       mov  y+3, #0
07D1 120339     776       lcall div32
07D4            777   
07D4            778       ; Add partial result to StoreMeasurements
07D4 854034     779       mov  y+0, StoreMeasurements+0
07D7 854135     780       mov  y+1, StoreMeasurements+1
07DA 854236     781       mov  y+2, StoreMeasurements+2
07DD 854337     782       mov  y+3, StoreMeasurements+3
07E0 1201F7     783       lcall add32
07E3 853040     784       mov  StoreMeasurements+0, x+0
07E6 853141     785       mov  StoreMeasurements+1, x+1
07E9 853242     786       mov  StoreMeasurements+2, x+2
07EC 853343     787       mov  StoreMeasurements+3, x+3
07EF            788   
07EF            789       ; Read thermocouple on AIN4
07EF 53E8F0     790       anl  ADCCON0, #0xF0
07F2 43E804     791       orl  ADCCON0, #0x04
07F5 1205CA     792       lcall Read_ADC
07F8            793   
07F8 8830       794       mov  x+0, R0
07FA 8931       795       mov  x+1, R1
07FC 753200     796       mov  x+2, #0
07FF 753300     797       mov  x+3, #0
0802 7534FF     798            mov y+0, #low (40959 % 0x10000) 
0805 75359F     798            mov y+1, #high(40959 % 0x10000) 
0808 753600     798            mov y+2, #low (40959 / 0x10000) 
080B 753700     798            mov y+3, #high(40959 / 0x10000) 
080E 1202AC     799       lcall mul32
0811 853D34     800       mov  y+0, VAL_LM4040+0
0814 853E35     801       mov  y+1, VAL_LM4040+1
0817 753600     802       mov  y+2, #0
081A 753700     803       mov  y+3, #0
081D 120339     804       lcall div32
0820            805   
0820            806       ; Add partial result to StoreThermocouple
0820 854F34     807       mov  y+0, StoreThermocouple+0
0823 855035     808       mov  y+1, StoreThermocouple+1
0826 855136     809       mov  y+2, StoreThermocouple+2
0829 855237     810       mov  y+3, StoreThermocouple+3
082C 1201F7     811       lcall add32
082F 85304F     812       mov  StoreThermocouple+0, x+0
0832 853150     813       mov  StoreThermocouple+1, x+1
0835 853251     814       mov  StoreThermocouple+2, x+2
0838 853352     815       mov  StoreThermocouple+3, x+3
083B            816   
083B            817       ; Delay between samples
083B AA4A       818       mov R2, TimePerSample
083D 12051F     819       lcall waitms
0840            820   
0840            821       ; Decrement measurement counter
0840 1546       822       dec MeasurementCounter+0
0842 E546       823       mov a, MeasurementCounter+0
0844 B4FF02     824       cjne a, #0xFF, CheckHigh
0847 1547       825       dec MeasurementCounter+1
0849            826   CheckHigh:
0849 E546       827       mov a, MeasurementCounter+0
084B 4547       828       orl a, MeasurementCounter+1
084D 6003       829       jz  DisplayValue
084F 0209B6     830       ljmp EndForever
0852            831   
0852            832   ;----------------------------------------------------------------------
0852            833   ; If enough measurements collected -> compute final temperature
0852            834   ;----------------------------------------------------------------------
0852            835   DisplayValue:
0852 753400     836            mov y+0, #low (0 % 0x10000) 
0855 753500     836            mov y+1, #high(0 % 0x10000) 
0858 753600     836            mov y+2, #low (0 / 0x10000) 
085B 753700     836            mov y+3, #high(0 / 0x10000) 
085E            837       ; Combine for LM335 reading
085E 854030     838       mov x+0, StoreMeasurements+0
0861 854131     839       mov x+1, StoreMeasurements+1
0864 854232     840       mov x+2, StoreMeasurements+2
0867 854333     841       mov x+3, StoreMeasurements+3
086A E548       842       mov a, SamplesPerDisplay+0
086C F534       843       mov y+0, a
086E F546       844       mov MeasurementCounter+0, a
0870 E549       845       mov a, SamplesPerDisplay+1
0872 F535       846       mov y+1, a
0874 F547       847       mov MeasurementCounter+1, a
0876 120339     848       lcall div32
0879            849   
0879            850       ; Subtract 273.00 => Celsius reading
0879 7534A4     851            mov y+0, #low (27300 % 0x10000) 
087C 75356A     851            mov y+1, #high(27300 % 0x10000) 
087F 753600     851            mov y+2, #low (27300 / 0x10000) 
0882 753700     851            mov y+3, #high(27300 / 0x10000) 
0885 120218     852       lcall sub32
0888 853057     853       mov FinalLM335+0, x+0
088B 853158     854       mov FinalLM335+1, x+1
088E 853259     855       mov FinalLM335+2, x+2
0891 85335A     856       mov FinalLM335+3, x+3
0894            857   
0894            858       ; Combine for thermocouple reading
0894 753400     859            mov y+0, #low (0 % 0x10000) 
0897 753500     859            mov y+1, #high(0 % 0x10000) 
089A 753600     859            mov y+2, #low (0 / 0x10000) 
089D 753700     859            mov y+3, #high(0 / 0x10000) 
08A0 854F30     860       mov x+0, StoreThermocouple+0
08A3 855031     861       mov x+1, StoreThermocouple+1
08A6 855132     862       mov x+2, StoreThermocouple+2
08A9 855233     863       mov x+3, StoreThermocouple+3
08AC E548       864       mov a, SamplesPerDisplay+0
08AE F534       865       mov y+0, a
08B0 E549       866       mov a, SamplesPerDisplay+1
08B2 F535       867       mov y+1, a
08B4 120339     868       lcall div32
08B7            869   
08B7            870       ; Add thermocouple to LM335 reading => final in x
08B7 753400     871            mov y+0, #low (0 % 0x10000) 
08BA 753500     871            mov y+1, #high(0 % 0x10000) 
08BD 753600     871            mov y+2, #low (0 / 0x10000) 
08C0 753700     871            mov y+3, #high(0 / 0x10000) 
08C3 855734     872       mov y+0, FinalLM335+0
08C6 855835     873       mov y+1, FinalLM335+1
08C9 855936     874       mov y+2, FinalLM335+2
08CC 855A37     875       mov y+3, FinalLM335+3
08CF 1201F7     876       lcall add32
08D2            877   
08D2 85305B     878       mov FinalTemp+0, x+0
08D5 85315C     879       mov FinalTemp+1, x+1
08D8 85325D     880       mov FinalTemp+2, x+2
08DB 85335E     881       mov FinalTemp+3, x+3
08DE            882   
08DE            883       ; --------------------------------------------------------
08DE            884       ; Compare final temperature with soak/reflow setpoints
08DE            885       ; --------------------------------------------------------
08DE C200       886       clr mf
08E0 753464     887            mov y+0, #low (100 % 0x10000) 
08E3 753500     887            mov y+1, #high(100 % 0x10000) 
08E6 753600     887            mov y+2, #low (100 / 0x10000) 
08E9 753700     887            mov y+3, #high(100 / 0x10000) 
08EC 856430     888       mov x+0, temp_soak
08EF 753100     889       mov x+1, #0
08F2 753200     890       mov x+2, #0
08F5 753300     891       mov x+3, #0
08F8 1202AC     892       lcall mul32
08FB 855B34     893       mov y+0, FinalTemp+0
08FE 855C35     894       mov y+1, FinalTemp+1
0901 855D36     895       mov y+2, FinalTemp+2
0904 855E37     896       mov y+3, FinalTemp+3
0907 1202A2     897       lcall x_lteq_y ; mf = 1 if temp_soak<=FinalTemp
090A A200       898       mov c, mf
090C 9206       899       mov temp_state1, c
090E            900   
090E C200       901       clr mf
0910 753464     902            mov y+0, #low (100 % 0x10000) 
0913 753500     902            mov y+1, #high(100 % 0x10000) 
0916 753600     902            mov y+2, #low (100 / 0x10000) 
0919 753700     902            mov y+3, #high(100 / 0x10000) 
091C 856630     903       mov x+0, temp_refl
091F 753100     904       mov x+1, #0
0922 753200     905       mov x+2, #0
0925 753300     906       mov x+3, #0
0928 1202AC     907       lcall mul32
092B 855B34     908       mov y+0, FinalTemp+0
092E 855C35     909       mov y+1, FinalTemp+1
0931 855D36     910       mov y+2, FinalTemp+2
0934 855E37     911       mov y+3, FinalTemp+3
0937 1202A2     912       lcall x_lteq_y ; mf = 1 if temp_refl<=FinalTemp
093A A200       913       mov c, mf
093C 9207       914       mov temp_state3, c
093E            915   
093E            916       ; Check error states
093E 855B30     917       mov x+0, FinalTemp+0
0941 855C31     918       mov x+1, FinalTemp+1
0944 855D32     919       mov x+2, FinalTemp+2
0947 855E33     920       mov x+3, FinalTemp+3
094A            921   
094A C200       922       clr mf
094C 7534A8     923            mov y+0, #low (25000 % 0x10000) 
094F 753561     923            mov y+1, #high(25000 % 0x10000) 
0952 753600     923            mov y+2, #low (25000 / 0x10000) 
0955 753700     923            mov y+3, #high(25000 / 0x10000) 
0958 120298     924       lcall x_gteq_y ; mf = 1 if FinalTemp<=250
095B A200       925       mov c, mf
095D 9204       926       mov err_tmp_150, c
095F            927   
095F C200       928       clr mf
0961 753488     929            mov y+0, #low (5000 % 0x10000) 
0964 753513     929            mov y+1, #high(5000 % 0x10000) 
0967 753600     929            mov y+2, #low (5000 / 0x10000) 
096A 753700     929            mov y+3, #high(5000 / 0x10000) 
096D 120298     930       lcall x_gteq_y ; mf = 1 if FinalTemp>=50
0970 A200       931       mov c, mf
0972 9203       932       mov err_tmp, c
0974            933   
0974 C200       934       clr mf
0976 7534B8     935            mov y+0, #low (3000 % 0x10000) 
0979 75350B     935            mov y+1, #high(3000 % 0x10000) 
097C 753600     935            mov y+2, #low (3000 / 0x10000) 
097F 753700     935            mov y+3, #high(3000 / 0x10000) 
0982 1202A2     936       lcall x_lteq_y ; mf = 1 if FinalTemp<=60
0985 A200       937       mov c, mf
0987 9208       938       mov temp_state5, c
0989            939   
0989            940   
0989            941   
0989            942       ; Convert FinalTemp => BCD => display
0989 120132     943       lcall hex2bcd
098C 120576     944       lcall Display_formated_BCD
098F 1205E5     945       lcall SendBCD
0992            946   
0992            947       ; Reset accumulators
0992 754000     948       mov StoreMeasurements+0, #0
0995 754100     949       mov StoreMeasurements+1, #0
0998 754200     950       mov StoreMeasurements+2, #0
099B 754300     951       mov StoreMeasurements+3, #0
099E 754F00     952       mov StoreThermocouple+0, #0
09A1 755000     953       mov StoreThermocouple+1, #0
09A4 755100     954       mov StoreThermocouple+2, #0
09A7 755200     955       mov StoreThermocouple+3, #0
09AA 755700     956       mov FinalLM335+0, #0
09AD 755801     957       mov FinalLM335+1, #1
09B0 755902     958       mov FinalLM335+2, #2
09B3 755A03     959       mov FinalLM335+3, #3
09B6            960   
09B6            961   EndForever:
09B6            962       ; Always read the push buttons each pass
09B6 120525     963       lcall LCD_PB
09B9            964   
09B9            965   
09B9 753000     966       mov x+0, #0
09BC 753100     967       mov x+1, #0
09BF 753200     968       mov x+2, #0
09C2 753300     969       mov x+3, #0
09C5 020796     970       ljmp Forever
09C8            971   
09C8            972   END
