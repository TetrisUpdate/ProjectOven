0000              1   ;----------------------------------------------------------------------
0000              2   ; 76E003 ADC test program (reflow oven controller + push buttons)
0000              3   ; Reads channel 7 on P1.1, pin 14
0000              4   ; This version uses the LM4040 voltage reference connected to pin 6 (P1.7/AIN0)
0000              5   ; Incorporates push-button control to set up times/temperatures and start FSM.
0000              6   ;----------------------------------------------------------------------
0000              7   
                  9   $LIST
0000             11   
0000             12   ;  N76E003 pinout:
0000             13   ;                               -------
0000             14   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             15   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             16   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             17   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             18   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             19   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             20   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             21   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             22   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             23   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             24   ;                               -------
0000             25   ;
0000             26   
0000             27   ;----------------------------------------------------------------------
0000             28   ; System/Timer/Constants
0000             29   ;----------------------------------------------------------------------
0000             30   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             31   BAUD              EQU 115200   ; Baud rate of UART in bps
0000             32   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             33   
0000             34   TIMER2_RATE       EQU 100      ; 100 Hz -> 10ms tick
0000             35   TIMER2_RELOAD     EQU ((65536-(CLK/(16*TIMER2_RATE))))
0000             36   
0000             37   TIMER0_RATE          EQU 2250
0000             38   TIMER0_RELOAD        EQU (0x10000-(CLK/TIMER0_RATE))
0000             39   
0000             40   SAMPLES_PER_DISPLAY EQU 150
0000             41   REFRESHES_PER_SECOND EQU 15
0000             42   
0000             43   ORG 0x0000
0000 0208EF      44       ljmp main
0003             45   
0003             46   ; Timer/Counter 0 overflow interrupt vector
000B             47   org 0x000B
000B 0203A8      48            ljmp Timer0_ISR
000E             49   
000E             50   ; Timer/Counter 2 overflow interrupt vector
002B             51   org 0x002B
002B 0203DB      52       ljmp Timer2_ISR
002E             53   
002E             54   ;----------------------------------------------------------------------
002E             55   ; Hardware Pin Definitions
002E             56   ;----------------------------------------------------------------------
002E             57   
002E             58   ; PUSH BUTTONS (single-pin read approach)
002E             59   PB_INPUT_PIN   EQU P1.5  ; The single pin used to read all 5 PBs
002E             60   MUX_CONTROL_0  EQU P1.3  
002E             61   MUX_CONTROL_1  EQU P0.0  
002E             62   MUX_CONTROL_2  EQU P0.1  
002E             63   MUX_CONTROL_3  EQU P0.2  
002E             64   MUX_CONTROL_4  EQU P0.3  
002E             65   SOUND_OUT      EQU P3.0
002E             66   
002E             67   ; LCD assignments
002E             68   LCD_RS  equ P1.3
002E             69   LCD_E   equ P1.4
002E             70   LCD_D4  equ P0.0
002E             71   LCD_D5  equ P0.1
002E             72   LCD_D6  equ P0.2
002E             73   LCD_D7  equ P0.3
002E             74   SSR_BOX equ P0.4
002E             75   
002E             76   ; Strings for LCD
002E 43757272    77   test_message:     db 'Current Temp.:', 0
     656E7420
     54656D70
     2E3A00
003D 4465672E    78   value_message:    db 'Deg. C', 0
     204300
0044             79   
0044 54656D70    80   temp_soak_string: db 'Temp Soak:    ', 0
     20536F61
     6B3A2020
     202000
0053 54696D65    81   time_soak_string: db 'Time Soak:    ', 0
     20536F61
     6B3A2020
     202000
0062 54656D70    82   temp_refl_string: db 'Temp Reflow: ', 0
     20526566
     6C6F773A
     2000
0070 54696D65    83   time_refl_string: db 'Time Reflow: ', 0
     20526566
     6C6F773A
     2000
007E             84   
007E 204300      85   degree_label: db ' C', 0
0081 207300      86   seconds_label: db ' s', 0
0084             87   
0084             88   
0084             89   cseg
0084             90   
                 92   	$LIST
0138             94   
0138             95   ;----------------------------------------------------------------------
0138             96   ; 32-bit math placeholders
0138             97   ;----------------------------------------------------------------------
0030             98   DSEG at 30H
0030             99   x:   ds 4
0034            100   y:   ds 4
0038            101   bcd: ds 5
003D            102   VAL_LM4040: ds 2
003F            103   
003F            104   ; Variables
003F            105   state:              ds 1
0040            106   StoreMeasurements:  ds 4
0044            107   Store:          ds 2
0046            108   MeasurementCounter: ds 2
0048            109   SamplesPerDisplay:  ds 2
004A            110   TimePerSample:      ds 1
004B            111   LastMeasurement:    ds 4
004F            112   StoreThermocouple:  ds 4
0053            113   CurrentTemp:        ds 4
0057            114   FinalLM335:         ds 4
005B            115   FinalTemp:          ds 4
005F            116   selected_state:          ds 1
0060            117   
0060            118   save_x:             ds 4
0064            119   
0064            120   Count1ms:      ds 2
0066            121   pwm_counter:   ds 1
0067            122   pwm:           ds 1
0068            123   
0068            124   debounce_count_0 :ds 1
0069            125   debounce_count_1 :ds 1
006A            126   debounce_count_2 :ds 1
006B            127   debounce_count_3 :ds 1
006C            128   debounce_count_4 :ds 1
006D            129   
006D            130   ; Oven settings
006D            131   temp_soak: ds 1  ; For state 1
006E            132   time_soak: ds 1  ; For state 2
006F            133   temp_refl: ds 1  ; For state 3
0070            134   time_refl: ds 1  ; For state 4
0071            135   
0071            136   seconds: ds 1
0072            137   state_sec: ds 1
0073            138   
0073            139   ;----------------------------------------------------------------------
0073            140   ; Bit variables (BSEG)
0073            141   ;----------------------------------------------------------------------
0000            142   BSEG
0000            143   mf:            dbit 1
0001            144   m_flag:        dbit 1
0002            145   s_flag:        dbit 1
0003            146   err_tmp:       dbit 1
0004            147   err_tmp_150:   dbit 1
0005            148   display_flag:  dbit 1
0006            149   
0006            150   inc_lock:      dbit 1
0007            151   
0007            152   start:         dbit 1  ; Start the FSM
0008            153   temp_state1:   dbit 1
0009            154   temp_state3:   dbit 1
000A            155   temp_state5:   dbit 1
000B            156   
000B            157   debug_bit:     dbit 1 ;Set to true to check which lines of code actually execute
000C            158   debug_bit1:    dbit 1
000D            159   kill_flag:      dbit 1 ; kill switch
000E            160   
000E            161   ; For push buttons
000E            162   PB0: dbit 1  ; Start/Pause
000F            163   PB1: dbit 1  ; Toggle selected parameter
0010            164   PB2: dbit 1  ; Increment
0011            165   PB3: dbit 1  ; Decrement
0012            166   PB4: dbit 1  ; Unused or extra
0013            167   
0013            168   PB0_db: dbit 1
0014            169   PB1_db: dbit 1
0015            170   PB2_db: dbit 1
0016            171   PB3_db: dbit 1
0017            172   PB4_db: dbit 1
0018            173   
0018            174   sound_flag: dbit 1
0019            175   
0019            176   ;SETATS
0019            177   
0019            178   ; We include math32 at the end of initialization
                546   $LIST
                180   $LIST
03A8            182   
03A8            183   ;----------------------------------------------------------------------
03A8            184   ; Timer2 Initialization & ISR
03A8            185   ;----------------------------------------------------------------------
03A8            186   
03A8            187   
03A8            188   
03A8            189   
03A8            190   
03A8            191   
03A8            192   Timer0_ISR:
03A8            193            ;clr TF0  ; According to the data sheet this is done for us already.
03A8            194            ; Timer 0 doesn't have 16-bit auto-reload, so
03A8 C28C       195            clr TR0
03AA 758CE3     196            mov TH0, #high(TIMER0_RELOAD) ;TH0 and TL0 are only 8 bits, so we need to load each half individually
03AD 758A2F     197            mov TL0, #low(TIMER0_RELOAD) ; For 0xF830 for example, #high gives 0xF8, #low gives #0x30
03B0 D28C       198            setb TR0 ; Start timer 0
03B2 201804     199            jb sound_flag, Timer0_ISR_Sound
03B5 C2B0       200            clr SOUND_OUT
03B7 8004       201            sjmp Timer0_ISR_Done
03B9            202   Timer0_ISR_Sound:
03B9 B2B0       203            cpl SOUND_OUT
03BB 8000       204            sjmp Timer0_ISR_Done
03BD            205   Timer0_ISR_Done:
03BD 32         206            reti
03BE            207   
03BE            208   
03BE            209   Timer2_Init:
03BE 75C800     210       mov T2CON, #0       ; Stop timer, mode = auto-reload
03C1 75CDD7     211       mov TH2, #high(TIMER2_RELOAD)
03C4 75CC79     212       mov TL2, #low(TIMER2_RELOAD)
03C7 43C9A0     213       orl T2MOD, #0b1010_0000    ; Enable auto-reload
03CA 75CBD7     214       mov RCMP2H, #high(TIMER2_RELOAD)
03CD 75CA79     215       mov RCMP2L, #low(TIMER2_RELOAD)
03D0 E4         216       clr  a
03D1 F564       217       mov  Count1ms+0, a
03D3 F565       218       mov  Count1ms+1, a
03D5 439B80     219       orl  EIE, #0x80     ; Enable timer2 interrupt (ET2=1)
03D8 D2CA       220       setb TR2            ; Start Timer2
03DA 22         221       ret
03DB            222   
03DB            223   Timer2_ISR:
03DB C2CF       224       clr TF2 ; Must clear TF2 manually on N76
03DD C0E0       225       push acc
03DF C0D0       226       push psw
03E1 853060     227       mov save_x+0, x+0
03E4 853161     228       mov save_x+1, x+1
03E7 853262     229       mov save_x+2, x+2
03EA 853363     230       mov save_x+3, x+3
03ED            231   
03ED            232       ;---------------------------------
03ED            233       ; PWM for SSR control
03ED            234       ;---------------------------------
03ED 0566       235       inc pwm_counter ;Every 10ms, pwm_counter is incremented
03EF C3         236       clr c
03F0 E567       237       mov a, pwm
03F2 9566       238       subb a, pwm_counter ; if pwm_counter <= pwm, c=1, so if pwm=20 for example, if 210ms has passed, c = 0, and the SSR box is always on
03F4            239       ;cpl c
03F4 9284       240       mov SSR_BOX, c
03F6            241       
03F6            242   CheckButton0:
03F6 200E0D     243       jb PB0, CheckButton1 ;Skip to CheckPWM if a button is not pushed
03F9 0568       244       inc debounce_count_0
03FB E568       245       mov a, debounce_count_0
03FD B40F06     246       cjne a, #15, CheckButton1
0400 C213       247            clr PB0_db
0402 756800     248       mov debounce_count_0, #0
0405 E4         249       clr a
0406            250   
0406            251   CheckButton1:
0406 200F0D     252       jb PB1, CheckButton2 ;Skip to CheckPWM if a button is not pushed
0409 0569       253       inc debounce_count_1
040B E569       254       mov a, debounce_count_1
040D B40F06     255       cjne a, #15, CheckButton2
0410 C214       256            clr PB1_db
0412 756900     257       mov debounce_count_1, #0
0415 E4         258       clr a
0416            259   
0416            260   CheckButton2:
0416 20100D     261       jb PB2, CheckButton3 ;Skip to CheckPWM if a button is not pushed
0419 056A       262       inc debounce_count_2
041B E56A       263       mov a, debounce_count_2
041D B40F06     264       cjne a, #15, CheckButton3
0420 C215       265            clr PB2_db
0422 756A00     266       mov debounce_count_2, #0
0425 E4         267       clr a
0426            268   
0426            269   CheckButton3:
0426 20110D     270       jb PB3, CheckButton4 ;Skip to CheckPWM if a button is not pushed
0429 056B       271       inc debounce_count_3
042B E56B       272       mov a, debounce_count_3
042D B40F06     273       cjne a, #15, CheckButton4
0430 C216       274            clr PB3_db
0432 756B00     275       mov debounce_count_3, #0
0435 E4         276       clr a
0436            277   
0436            278   CheckButton4:
0436 20120D     279       jb PB4, CheckPWM ;Skip to CheckPWM if a button is not pushed
0439 056C       280       inc debounce_count_4
043B E56C       281       mov a, debounce_count_4
043D B40F06     282       cjne a, #15, CheckPWM
0440 C217       283            clr PB4_db
0442 756C00     284       mov debounce_count_4, #0
0445 E4         285       clr a
0446            286   
0446            287   
0446            288   CheckPWM:
0446 E566       289       mov a, pwm_counter
0448 B4641F     290       cjne a, #100, State_0 ; If 1 second has not passed, skip to State_0
044B 756600     291       mov pwm_counter, #0 ; Reset pwm_counter
044E E53F       292       mov a, state
0450 B40003     293       cjne a, #0, SecondsLogic
0453 02046A     294       ljmp State_0
0456            295   
0456            296   
0456            297   SecondsLogic:
0456 0571       298       inc seconds ; Increment seconds
0458 0572       299       inc state_sec ; Will only increment in states 2 and 4, gets reset to 0 in all other states otherrwise
045A E4         300       clr a
045B E53F       301       mov a, state
045D B4010A     302       cjne a, #1, State_0
0460 E571       303       mov a, seconds
0462 B43C05     304       cjne a, #60, State_0 ;If exactly 60 seconds has not passed, skip to State_0, otherwise set m_flag to indicate a minute has passed
0465 D201       305       setb m_flag
0467 02046A     306       ljmp State_0
046A            307   
046A            308   
046A            309   State_0:
046A E53F       310       mov a, state
046C B40010     311            cjne a, #0, State_1
046F E4         312       clr a
0470 757200     313       mov state_sec, #0
0473 756700     314            mov pwm, #0
0476 30074C     315            jnb start, jumpy 
0479 753F01     316            mov state, #1
047C 020554     317            ljmp Display_1
047F            318            
047F            319   State_1:
047F 200D46     320       jb kill_flag, jumpyError
0482 E53F       321            mov a, state
0484 B40122     322            cjne a, #1, State_2
0487 757200     323            mov state_sec, #0
048A 756764     324            mov pwm, #100                                   ; set pwm for relfow oven to 100%
048D 20010F     325            jb m_flag, Cond_check
0490 D20C       326       setb debug_bit1
0492 300830     327            jnb temp_state1, jumpy          ; mf = 1 if oven temp <= set temp, jump out of ISR. mf = 0 if oven temp > set temp, thus move onto next state                   
0495 E4         328            clr a                                           
0496 753F02     329            mov state, #2
0499 757200     330       mov state_sec, #0
049C 0204A9     331            ljmp State_2
049F            332   
049F            333   Cond_check: ; cjne is not bit-addressable, therefore we must move bits into byte registers (i.e. accumulator and register b)
049F D20B       334            setb debug_bit
04A1 300327     335       jnb err_tmp, jumpyErrorKill
04A4 C201       336       clr m_flag
04A6 0204C5     337            ljmp jumpy
04A9            338   
04A9            339   
04A9            340   State_2: ;transition to state three if more than 60 seconds have passed
04A9 200D1C     341       jb kill_flag, jumpyError
04AC E53F       342            mov a, state
04AE B4021D     343            cjne a, #2, State_3
04B1 756714     344            mov pwm, #20
04B4 200414     345            jb err_tmp_150, jumpyErrorKill
04B7 E4         346       clr a        
04B8            347   
04B8            348       
04B8 E572       349       mov a, state_sec
04BA C3         350       clr c
04BB 956E       351       subb a, time_soak ; If state_sec - time_soak is negative (so not enough time has passed), then c = 1, 
04BD 4006       352       jc jumpy
04BF 753F03     353            mov state, #3
04C2 757200     354       mov state_sec, #0
04C5            355   
04C5            356   jumpy:
04C5 020549     357       ljmp Display_0
04C8            358   jumpyError:
04C8 020526     359       ljmp State_error
04CB            360   jumpyErrorkill:
04CB 020520     361       ljmp State_error_kill
04CE            362   
04CE            363   
04CE            364   State_3: 
04CE 200D55     365       jb kill_flag, State_error
04D1 E53F       366            mov a, state
04D3 B40313     367            cjne a, #3, State_4 ; check if state = 3, if not, move to state_4
04D6 756764     368            mov pwm, #100 ; set pwm to 100%
04D9 757200     369       mov state_sec, #0
04DC 200441     370            jb err_tmp_150, State_error_kill
04DF            371            ;mov c, temp_state3
04DF            372            ;clr a                                                          ; clear the accumulator
04DF            373            ;mov acc.0, c
04DF            374            ;clr c                                                          ; clear the carry bit
04DF            375            ;cjne a, #0, Timer2_ISR_done ;
04DF 3009E3     376       jnb temp_state3, jumpy
04E2 E4         377            clr a
04E3 757200     378       mov state_sec, #0
04E6 753F04     379            mov state, #4
04E9            380   
04E9            381   State_4:
04E9 200D3A     382       jb kill_flag, State_error
04EC E53F       383            mov a, state
04EE B40413     384            cjne a, #4, State_5
04F1 756714     385            mov pwm, #20
04F4 200429     386            jb err_tmp_150, State_error_kill
04F7 E4         387       clr a
04F8 E572       388       mov a, state_sec
04FA 9570       389       subb a, time_refl
04FC 40C7       390       jc jumpy    
04FE 753F05     391            mov state, #5
0501 757200     392       mov state_sec, #0
0504            393   
0504            394   State_5:
0504 200D1F     395       jb kill_flag, State_error
0507 E53F       396            mov a, state
0509 B405B9     397            cjne a, #5, jumpy
050C 756700     398            mov pwm, #0
050F 757200     399       mov state_sec, #0
0512 20040B     400       jb err_tmp_150, State_error_kill
0515 300AAD     401       jnb temp_state5, jumpy
0518 753F00     402            mov state, #0
051B 757200     403       mov state_sec, #0
051E 800C       404       sjmp State_end
0520            405   
0520            406   
0520            407   State_error_kill:
0520 7400       408            mov a, #0
0522 F53F       409            mov state, a
0524 8006       410       sjmp State_end
0526            411       
0526            412   State_error:
0526 7400       413            mov a, #0
0528 F53F       414            mov state, a
052A 801D       415       sjmp Display_0
052C            416   
052C            417   State_end:
052C C3         418       clr c
052D A207       419       mov c, start
052F E4         420       clr a
0530 92E0       421       mov acc.0, c
0532 F4         422       cpl a                                ; set the flag to 1, indicating that the FSM should begin
0533 A2E0       423       mov c, acc.0
0535 9207       424       mov start, c
0537 E4         425       clr a
0538 C3         426       clr c
0539 A20D       427       mov c, kill_flag
053B 92E0       428       mov acc.0, c
053D F4         429       cpl a                    ; compliment kill
053E A2E0       430       mov c, acc.0 
0540 920D       431       mov kill_flag, c
0542 C201       432       clr m_flag
0544 757100     433       mov seconds, #0
0547 8000       434       sjmp Display_0
0549            435   
0549            436            ; probably should put branch for warning message here
0549            437   
0549            438   ; Second FSM for displaying values for each state
0549            439   
0549            440   Display_0: ; Displays state 0 - Oven On
0549 020554     441       ljmp Display_1 ;Temporary, test until we set up Display_0
054C E55F       442       mov a, selected_state
054E B40003     443       cjne a, #0, Display_1
0551 0206E3     444       ljmp Timer2_ISR_done
0554            445   
0554            446   Display_1: ; Displays state 1 - Soak Temp.
0554 E55F       447       mov a, selected_state
0556 B40161     448       cjne a, #1, Display_2
0559 30055B     449       jnb display_flag, jumpyEnd
055C C0E0       450            push acc
055E 7401       450            mov a, #1
0560 14         450            dec a
0561 12011D     450            lcall ?Set_Cursor_1 ; Select column and row
0564 D0E0       450            pop acc
0566 C083       451            push dph
0568 C082       451            push dpl
056A C0E0       451            push acc
056C 900044     451            mov dptr, #temp_soak_string
056F 120110     451            lcall ?Send_Constant_String
0572 D0E0       451            pop acc
0574 D082       451            pop dpl
0576 D083       451            pop dph
0578 C205       452       clr display_flag
057A 753000     453            mov x+0, #low (0 % 0x10000) 
057D 753100     453            mov x+1, #high(0 % 0x10000) 
0580 753200     453            mov x+2, #low (0 / 0x10000) 
0583 753300     453            mov x+3, #high(0 / 0x10000) 
0586 856D30     454       mov x+0, temp_soak
0589 120138     455       lcall hex2bcd
058C C0E0       456            push acc
058E 7401       456            mov a, #1
0590 14         456            dec a
0591 12011B     456            lcall ?Set_Cursor_2 ; Select column and row
0594 D0E0       456            pop acc
0596 C000       457            push ar0
0598 A839       457            mov r0, bcd+1
059A 120122     457            lcall ?Display_BCD
059D D000       457            pop ar0
059F C000       458            push ar0
05A1 A838       458            mov r0, bcd+0
05A3 120122     458            lcall ?Display_BCD
05A6 D000       458            pop ar0
05A8 753000     459            mov x+0, #low (0 % 0x10000) 
05AB 753100     459            mov x+1, #high(0 % 0x10000) 
05AE 753200     459            mov x+2, #low (0 / 0x10000) 
05B1 753300     459            mov x+3, #high(0 / 0x10000)  
05B4 0206E3     460       ljmp Timer2_ISR_done
05B7            461   
05B7            462   jumpyEnd:
05B7 0206E3     463       ljmp Timer2_ISR_done
05BA            464   
05BA            465   Display_2: ; Displays state 2 - Soak Time
05BA E55F       466       mov a, selected_state
05BC B4025E     467       cjne a, #2, Display_3
05BF 3005F5     468       jnb display_flag, jumpyEnd
05C2 C0E0       469            push acc
05C4 7401       469            mov a, #1
05C6 14         469            dec a
05C7 12011D     469            lcall ?Set_Cursor_1 ; Select column and row
05CA D0E0       469            pop acc
05CC C083       470            push dph
05CE C082       470            push dpl
05D0 C0E0       470            push acc
05D2 900053     470            mov dptr, #time_soak_string
05D5 120110     470            lcall ?Send_Constant_String
05D8 D0E0       470            pop acc
05DA D082       470            pop dpl
05DC D083       470            pop dph
05DE C205       471       clr display_flag
05E0 753000     472            mov x+0, #low (0 % 0x10000) 
05E3 753100     472            mov x+1, #high(0 % 0x10000) 
05E6 753200     472            mov x+2, #low (0 / 0x10000) 
05E9 753300     472            mov x+3, #high(0 / 0x10000) 
05EC 856E30     473       mov x+0, time_soak
05EF 120138     474       lcall hex2bcd
05F2 C0E0       475            push acc
05F4 7401       475            mov a, #1
05F6 14         475            dec a
05F7 12011B     475            lcall ?Set_Cursor_2 ; Select column and row
05FA D0E0       475            pop acc
05FC C000       476            push ar0
05FE A839       476            mov r0, bcd+1
0600 120122     476            lcall ?Display_BCD
0603 D000       476            pop ar0            ; x is 8 bits, we represent in hex as 0xFF, therefore FF is displayed
0605 C000       477            push ar0
0607 A838       477            mov r0, bcd+0
0609 120122     477            lcall ?Display_BCD
060C D000       477            pop ar0
060E 753000     478            mov x+0, #low (0 % 0x10000) 
0611 753100     478            mov x+1, #high(0 % 0x10000) 
0614 753200     478            mov x+2, #low (0 / 0x10000) 
0617 753300     478            mov x+3, #high(0 / 0x10000)  
061A 0206E3     479       ljmp Timer2_ISR_done
061D            480   
061D            481   
061D            482   
061D            483   Display_3: ; Displays state 3 - Reflow Temp.
061D E55F       484       mov a, selected_state
061F B4035E     485       cjne a, #3, Display_4
0622 300592     486       jnb display_flag, jumpyEnd
0625 C0E0       487            push acc
0627 7401       487            mov a, #1
0629 14         487            dec a
062A 12011D     487            lcall ?Set_Cursor_1 ; Select column and row
062D D0E0       487            pop acc
062F C083       488            push dph
0631 C082       488            push dpl
0633 C0E0       488            push acc
0635 900062     488            mov dptr, #temp_refl_string
0638 120110     488            lcall ?Send_Constant_String
063B D0E0       488            pop acc
063D D082       488            pop dpl
063F D083       488            pop dph
0641 C205       489       clr display_flag
0643 753000     490            mov x+0, #low (0 % 0x10000) 
0646 753100     490            mov x+1, #high(0 % 0x10000) 
0649 753200     490            mov x+2, #low (0 / 0x10000) 
064C 753300     490            mov x+3, #high(0 / 0x10000) 
064F 856F30     491       mov x+0, temp_refl
0652 120138     492       lcall hex2bcd
0655 C0E0       493            push acc
0657 7401       493            mov a, #1
0659 14         493            dec a
065A 12011B     493            lcall ?Set_Cursor_2 ; Select column and row
065D D0E0       493            pop acc
065F C000       494            push ar0
0661 A839       494            mov r0, bcd+1
0663 120122     494            lcall ?Display_BCD
0666 D000       494            pop ar0
0668 C000       495            push ar0
066A A838       495            mov r0, bcd+0
066C 120122     495            lcall ?Display_BCD
066F D000       495            pop ar0
0671 753000     496            mov x+0, #low (0 % 0x10000) 
0674 753100     496            mov x+1, #high(0 % 0x10000) 
0677 753200     496            mov x+2, #low (0 / 0x10000) 
067A 753300     496            mov x+3, #high(0 / 0x10000)  
067D 0206E3     497       ljmp Timer2_ISR_done
0680            498       
0680            499   
0680            500   Display_4: ; Displays state 4 - Reflow Time
0680 E55F       501       mov a, selected_state
0682 B4045E     502       cjne a, #4, Timer2_ISR_Done
0685 30055B     503       jnb display_flag, Timer2_ISR_done
0688 C0E0       504            push acc
068A 7401       504            mov a, #1
068C 14         504            dec a
068D 12011D     504            lcall ?Set_Cursor_1 ; Select column and row
0690 D0E0       504            pop acc
0692 C083       505            push dph
0694 C082       505            push dpl
0696 C0E0       505            push acc
0698 900070     505            mov dptr, #time_refl_string
069B 120110     505            lcall ?Send_Constant_String
069E D0E0       505            pop acc
06A0 D082       505            pop dpl
06A2 D083       505            pop dph
06A4 C205       506       clr display_flag
06A6 753000     507            mov x+0, #low (0 % 0x10000) 
06A9 753100     507            mov x+1, #high(0 % 0x10000) 
06AC 753200     507            mov x+2, #low (0 / 0x10000) 
06AF 753300     507            mov x+3, #high(0 / 0x10000) 
06B2 857030     508       mov x+0, time_refl
06B5 120138     509       lcall hex2bcd
06B8 C0E0       510            push acc
06BA 7401       510            mov a, #1
06BC 14         510            dec a
06BD 12011B     510            lcall ?Set_Cursor_2 ; Select column and row
06C0 D0E0       510            pop acc
06C2 C000       511            push ar0
06C4 A839       511            mov r0, bcd+1
06C6 120122     511            lcall ?Display_BCD
06C9 D000       511            pop ar0            ; x is 8 bits, we represent in hex as 0xFF, therefore FF is displayed
06CB C000       512            push ar0
06CD A838       512            mov r0, bcd+0
06CF 120122     512            lcall ?Display_BCD
06D2 D000       512            pop ar0
06D4 753000     513            mov x+0, #low (0 % 0x10000) 
06D7 753100     513            mov x+1, #high(0 % 0x10000) 
06DA 753200     513            mov x+2, #low (0 / 0x10000) 
06DD 753300     513            mov x+3, #high(0 / 0x10000)                
06E0 0206E3     514       ljmp Timer2_ISR_done
06E3            515       
06E3            516   
06E3            517   Timer2_ISR_done:
06E3 D0D0       518       pop psw
06E5 D0E0       519       pop acc
06E7 856030     520       mov x+0, save_x+0 
06EA 856131     521       mov x+1, save_x+1
06ED 856232     522       mov x+2, save_x+2
06F0 856333     523       mov x+3, save_x+3
06F3 32         524       reti
06F4            525   
06F4            526   ;----------------------------------------------------------------------
06F4            527   ; Initialization
06F4            528   ;----------------------------------------------------------------------
06F4            529   Init_All:
06F4            530       ; Configure all the pins for bidirectional I/O
06F4 75AC00     531       mov P3M1, #0x00
06F7 75AD00     532       mov P3M2, #0x00
06FA 75B300     533       mov P1M1, #0x00
06FD 75B400     534       mov P1M2, #0x00
0700 75B100     535       mov P0M1, #0x00
0703 75B200     536       mov P0M2, #0x00
0706            537   
0706 1203BE     538       lcall Timer2_Init
0709            539   
0709            540       ; Timer1 for UART
0709 438E10     541       orl  CKCON, #0x10     ; Timer1 uses system clock
070C 438780     542       orl  PCON,  #0x80     ; SMOD=1 -> double baud
070F 759852     543       mov  SCON,  #0x52     ; UART mode 1, REN=1
0712 53C4DF     544       anl  T3CON, #0b11011111
0715 53890F     545       anl  TMOD,  #0x0F
0718 438920     546       orl  TMOD,  #0x20     ; Timer1 Mode2 (8-bit auto-reload)
071B 758DF7     547       mov  TH1, #TIMER1_RELOAD
071E D28E       548       setb TR1
0720            549   
0720            550       ; Timer0 for waitms
0720 C28C       551       clr TR0
0722 438E08     552       orl CKCON, #0x08
0725 5389F0     553       anl TMOD,  #0xF0
0728 438901     554       orl TMOD,  #0x01      ; 16-bit mode
072B 758CE3     555       mov TH0, #high(TIMER0_RELOAD)
072E 758A2F     556       mov TL0, #low(TIMER0_RELOAD)
0731 D2A9       557       setb ET0 ; Enable timer 0  interrupt
0733 D28C       558       setb TR0 ; Start timer 0
0735            559       ; ADC pins: P1.1 (AIN7), P1.7 (AIN0)
0735 43B382     560       orl P1M1, #0b10000010 ; Set P1.1 & P1.7 as input
0738 53B47D     561       anl P1M2, #0b01111101
073B            562   
073B            563       ; Initialize ADC
073B 53E8F0     564       anl ADCCON0, #0xF0
073E 43E807     565       orl ADCCON0, #0x07    ; default to channel 7
0741 75F600     566       mov AINDIDS, #0x00    ; disable all digital inputs
0744 43F681     567       orl AINDIDS, #0b10000001 ; activate AIN0 and AIN7
0747 43E101     568       orl ADCCON1, #0x01    ; enable ADC
074A 22         569       ret
074B            570   
074B            571   ;----------------------------------------------------------------------
074B            572   ; Delay Routines
074B            573   ;----------------------------------------------------------------------
074B            574   wait_1ms:
074B C28C       575       clr TR0
074D C28D       576       clr TF0
074F 758CE3     577       mov TH0, #high(TIMER0_RELOAD)
0752 758A2F     578       mov TL0, #low(TIMER0_RELOAD)
0755 D28C       579       setb TR0
0757 308DFD     580       jnb TF0, $
075A 22         581       ret
075B            582   
075B            583   ; Wait R2 milliseconds
075B            584   waitms:
075B 12074B     585       lcall wait_1ms
075E DAFB       586       djnz R2, waitms
0760 22         587       ret
0761            588   
0761            589   ;----------------------------------------------------------------------
0761            590   ; LCD_PB: Read the 5 push buttons into PB0..PB4 bits
0761            591   ;----------------------------------------------------------------------
0761            592   LCD_PB:
0761            593       ; Default all PB bits to 1 (released)
0761 D20E       594       setb PB0 
0763 D20F       595       setb PB1
0765 D210       596       setb PB2
0767 D211       597       setb PB3
0769 D212       598       setb PB4
076B            599       ; The input pin is idle-high (pull-up)
076B D295       600       setb PB_INPUT_PIN
076D            601   
076D            602       ; Set MUX lines to 0 first
076D C293       603       clr MUX_CONTROL_0
076F C280       604       clr MUX_CONTROL_1
0771 C281       605       clr MUX_CONTROL_2
0773 C282       606       clr MUX_CONTROL_3
0775 C283       607       clr MUX_CONTROL_4
0777            608   
0777            609       ;---------------------------------
0777            610       ; Debouncing
0777            611       ;---------------------------------
0777            612   
0777            613       ; Now set all MUX lines = 1 to read them individually
0777 D293       614       setb MUX_CONTROL_0
0779 D280       615       setb MUX_CONTROL_1
077B D281       616       setb MUX_CONTROL_2
077D D282       617       setb MUX_CONTROL_3
077F D283       618       setb MUX_CONTROL_4
0781            619   
0781            620       ; Check PB4
0781 C283       621       clr MUX_CONTROL_4
0783 A295       622       mov c, PB_INPUT_PIN
0785 9212       623       mov PB4, c
0787 D283       624       setb MUX_CONTROL_4
0789            625   
0789            626       ; Check PB3
0789 C282       627       clr MUX_CONTROL_3
078B A295       628       mov c, PB_INPUT_PIN
078D 9211       629       mov PB3, c
078F D282       630       setb MUX_CONTROL_3
0791            631   
0791            632       ; Check PB2
0791 C281       633       clr MUX_CONTROL_2
0793 A295       634       mov c, PB_INPUT_PIN
0795 9210       635       mov PB2, c
0797 D281       636       setb MUX_CONTROL_2
0799            637   
0799            638       ; Check PB1
0799 C280       639       clr MUX_CONTROL_1
079B A295       640       mov c, PB_INPUT_PIN
079D 920F       641       mov PB1, c
079F D280       642       setb MUX_CONTROL_1
07A1            643   
07A1            644       ; Check PB0
07A1 C293       645       clr MUX_CONTROL_0
07A3 A295       646       mov c, PB_INPUT_PIN
07A5 920E       647       mov PB0, c
07A7 D293       648       setb MUX_CONTROL_0
07A9            649   
07A9            650   
07A9            651   LCD_PB_Done:
07A9 D293       652       setb LCD_RS
07AB D294       653       setb LCD_E
07AD 22         654       ret
07AE            655   
07AE            656   ;----------------------------------------------------------------------
07AE            657   ; Display_formated_BCD: Display the result with decimal
07AE            658   ;----------------------------------------------------------------------
07AE            659   Display_formated_BCD:
07AE C0E0       660            push acc
07B0 7408       660            mov a, #8
07B2 14         660            dec a
07B3 12011B     660            lcall ?Set_Cursor_2 ; Select column and row
07B6 D0E0       660            pop acc
07B8 C000       661            push ar0
07BA A83A       661            mov r0, bcd+2
07BC 120122     661            lcall ?Display_BCD
07BF D000       661            pop ar0
07C1 C000       662            push ar0
07C3 A839       662            mov r0, bcd+1
07C5 120122     662            lcall ?Display_BCD
07C8 D000       662            pop ar0
07CA C0E0       663            push acc
07CC 742E       663            mov a, #'.'
07CE 1200D3     663            lcall ?WriteData
07D1 D0E0       663            pop acc
07D3 C000       664            push ar0
07D5 A838       664            mov r0, bcd+0
07D7 120122     664            lcall ?Display_BCD
07DA D000       664            pop ar0
07DC C0E0       665            push acc
07DE 74DF       665            mov a, #0xDF
07E0 1200D3     665            lcall ?WriteData
07E3 D0E0       665            pop acc    ; Degree symbol
07E5 C0E0       666            push acc
07E7 7443       666            mov a, #'C'
07E9 1200D3     666            lcall ?WriteData
07EC D0E0       666            pop acc
07EE C0E0       667            push acc
07F0 7408       667            mov a, #8
07F2 14         667            dec a
07F3 12011B     667            lcall ?Set_Cursor_2 ; Select column and row
07F6 D0E0       667            pop acc
07F8 C0E0       668            push acc
07FA 7420       668            mov a, #' '
07FC 1200D3     668            lcall ?WriteData
07FF D0E0       668            pop acc
0801 22         669       ret
0802            670   
0802            671   ;----------------------------------------------------------------------
0802            672   ; Read_ADC: reads current ADC channel into R0:R1 (12-bit)
0802            673   ;----------------------------------------------------------------------
0802            674   Read_ADC:
0802 C2EF       675       clr  ADCF
0804 D2EE       676       setb ADCS
0806 30EFFD     677       jnb  ADCF, $          ; Wait conversion
0809 E5C2       678       mov  a, ADCRL
080B 540F       679       anl  a, #0x0F
080D F8         680       mov  R0, a
080E E5C3       681       mov  a, ADCRH
0810 C4         682       swap a
0811 C0E0       683       push acc
0813 540F       684       anl  a, #0x0F
0815 F9         685       mov  R1, a
0816 D0E0       686       pop  acc
0818 54F0       687       anl  a, #0xF0
081A 48         688       orl  a, R0
081B F8         689       mov  R0, a
081C 22         690       ret
081D            691   
081D            692   ;----------------------------------------------------------------------
081D            693   ; New code for push-button-based FSM parameter updates
081D            694   ; We intercept button presses in SendSerial
081D            695   ;----------------------------------------------------------------------
081D            696   SendBCD:
081D            697   
081D E53A       698            mov a, bcd+2
081F 540F       699            anl a, #0x0F ; Isolate ones place
0821 2430       700            add a, #'0' ; Convert value to ASCII
0823 12085C     701            lcall SendSerial
0826            702   
0826 E539       703            mov a, bcd+1
0828 54F0       704            anl a, #0xF0 ; Isolate tens place
082A C4         705            swap a ; Put high nibble into lower nibble
082B 2430       706            add a, #'0' ; Convert value to ASCII
082D 12085C     707            lcall SendSerial
0830            708   
0830 E539       709            mov a, bcd+1
0832 540F       710            anl a, #0x0F ; Isolate ones place
0834 2430       711            add a, #'0' ; Convert value to ASCII
0836 12085C     712            lcall SendSerial
0839            713   
0839 742E       714            mov a, #'.'
083B 12085C     715            lcall SendSerial
083E            716   
083E E538       717            mov a, bcd+0
0840 54F0       718            anl a, #0xF0 ; Isolate 0.1 place
0842 C4         719            swap a ; Put high nibble into lower nibble
0843 2430       720            add a, #'0' ; Convert value to ASCII
0845 12085C     721            lcall SendSerial
0848            722   
0848 E538       723            mov a, bcd+0
084A 540F       724            anl a, #0x0F ; Isolate 0.01 place
084C 2430       725            add a, #'0' ; Convert value to ASCII
084E 12085C     726            lcall SendSerial
0851            727   
0851 740A       728            mov a, #'\n'
0853 12085C     729            lcall SendSerial
0856            730   
0856 740D       731            mov a, #'\r'
0858 12085C     732            lcall SendSerial
085B            733   
085B 22         734            ret
085C            735   
085C            736   SendSerial:
085C C299       737            clr TI
085E F599       738            mov SBUF, a
0860 3099FD     739            jnb TI, $
0863 22         740            ret
0864            741   
0864            742   button_logic:
0864 30130A     743       jnb PB0_db, start_oven
0867 301422     744       jnb PB1_db, toggle_state
086A 301531     745       jnb PB2_db, inc_value
086D 301654     746       jnb PB3_db, dec_value
0870            747       ; PB4 is unused for now, do nothing if pressed.
0870            748   
0870 22         749       ret
0871            750   
0871            751   ; Start the FSM
0871            752   start_oven:
0871 D213       753       setb PB0_db
0873 C3         754            clr c
0874 A207       755       mov c, start
0876 E4         756       clr a
0877 92E0       757       mov acc.0, c
0879 F4         758       cpl a                                ; set the flag to 1, indicating that the FSM should begin
087A A2E0       759       mov c, acc.0
087C 9207       760       mov start, c
087E E4         761       clr a
087F C3         762       clr c
0880 A20D       763       mov c, kill_flag
0882 92E0       764       mov acc.0, c
0884 F4         765       cpl a                    ; compliment kill
0885 A2E0       766       mov c, acc.0 
0887 920D       767       mov kill_flag, c
0889            768       ;mov start, # 1                                ; return to main or update display as needed
0889 0208EE     769       ljmp end_button_logic           ; jump to exit logic
088C            770   
088C            771   ; Toggle which parameter is selected (1..4)
088C            772   toggle_state:
088C D205       773       setb display_flag
088E D214       774       setb PB1_db
0890 E55F       775       mov a, selected_state           ; load the selected state to the accumulator
0892 2401       776       add a, #1                       ; icnrement the selection
0894 B40502     777       cjne a, #5, noWrap              ; if not greater than 4, jump to noWrap
0897 7401       778       mov a, #1                       ; if (selected_state == 5), reset the selected state, i.e. selected_state == 1
0899            779   noWrap:
0899 F55F       780       mov selected_state, a           ; store the updated selected_state
089B 0208EE     781       ljmp end_button_logic           ; jump to exit logic
089E            782   
089E            783   ; Increment whichever parameter is selected
089E            784   ; ** DOUBLE CHECK THIS LOGIC IM NOT TOO SURE **
089E            785   inc_value:
089E D205       786       setb display_flag
08A0 D215       787       setb PB2_db
08A2 E55F       788       mov a, selected_state           ; load the selected state into the accumulator
08A4 B40105     789       cjne a, #1, checkState2         ; if selected_state != temp_soak, check the next selected state
08A7 056D       790       inc temp_soak                   ; increment temp_soak if above condition not true
08A9 0208EE     791       ljmp end_button_logic           ; jump to exit logic
08AC            792   
08AC            793   checkState2:                    
08AC B40205     794       cjne a, #2, checkState3         ; if not time_soak, check the next parameter
08AF 056E       795       inc time_soak                   ; increment time_soak
08B1 0208EE     796       ljmp end_button_logic           ; jump to exit logic
08B4            797   
08B4            798   checkState3:
08B4 B40305     799       cjne a, #3, checkState4         ; if not temp_refl, check next parameter
08B7 056F       800       inc temp_refl                   ; increment temp_refl
08B9 0208EE     801       ljmp end_button_logic           ; jump to exit logic
08BC            802   
08BC            803   checkState4:                        
08BC B4042F     804       cjne a, #4, end_button_logic    ; if not time_refl, exit 
08BF 0570       805       inc time_refl                   ; inc time_refl
08C1 0208EE     806       ljmp end_button_logic           ; jump to exit logic
08C4            807   
08C4            808   ; Decrement whichever parameter is selected
08C4            809   ; ** SAME IDEA BUT CHECK THE LOGIC PLEASE ** 
08C4            810   dec_value:
08C4 D205       811       setb display_flag
08C6 D216       812       setb PB3_db
08C8 E55F       813       mov a, selected_state
08CA            814       
08CA B40106     815       cjne a, #1, dcheckState2
08CD D56D1E     816       djnz temp_soak, end_button_logic
08D0 0208EE     817       ljmp end_button_logic
08D3            818   
08D3            819   dcheckState2:
08D3 B40206     820       cjne a, #2, dcheckState3
08D6 D56E15     821       djnz time_soak, end_button_logic
08D9 0208EE     822       ljmp end_button_logic
08DC            823   
08DC            824   dcheckState3:
08DC B40306     825       cjne a, #3, dcheckState4
08DF D56F0C     826       djnz temp_refl, end_button_logic
08E2 0208EE     827       ljmp end_button_logic
08E5            828   
08E5            829   dcheckState4:
08E5 B40406     830       cjne a, #4, end_button_logic
08E8 D57003     831       djnz time_refl, end_button_logic
08EB 0208EE     832       ljmp end_button_logic
08EE            833   
08EE            834   end_button_logic:
08EE 22         835       ret
08EF            836   
08EF            837   
08EF            838   ;----------------------------------------------------------------------
08EF            839   ; main
08EF            840   ;----------------------------------------------------------------------
08EF            841   main:
08EF 75817F     842       mov sp, #0x7F
08F2 1206F4     843       lcall Init_All
08F5 1200DD     844       lcall LCD_4BIT
08F8 1203BE     845       lcall Timer2_Init ; initialize interupts 
08FB D2AF       846       setb EA
08FD            847   
08FD C284       848       clr SSR_BOX
08FF            849   
08FF 754601     850       mov MeasurementCounter+0, #1
0902 754700     851       mov MeasurementCounter+1, #0
0905 754A02     852       mov TimePerSample, #2
0908            853   
0908 754896     854       mov SamplesPerDisplay+0, #low(SAMPLES_PER_DISPLAY)
090B 754900     855       mov SamplesPerDisplay+1, #high(SAMPLES_PER_DISPLAY)
090E            856   
090E            857       ; We start with "state=0" (idle)
090E 753F00     858       mov state, #0
0911 C207       859       clr start ; compliment in start_oven
0913 C201       860       clr m_flag
0915 D20D       861       setb kill_flag
0917            862   
0917            863       ; Default setpoints
0917 756D64     864       mov temp_soak, #100
091A 756E37     865       mov time_soak, #55
091D 756FD2     866       mov temp_refl, #210
0920 757028     867       mov time_refl, #40
0923            868   
0923            869       ; Which parameter we are currently adjusting: 1=temp_soak,2=time_soak,3=temp_refl,4=time_refl
0923 755F01     870       mov selected_state, #1
0926            871   
0926 754B00     872       mov LastMeasurement+0, #0
0929 754C00     873       mov LastMeasurement+1, #0
092C 754D00     874       mov LastMeasurement+2, #0
092F 754E00     875       mov LastMeasurement+3, #0
0932            876       
0932 C208       877       clr temp_state1
0934 C209       878       clr temp_state3
0936 C20B       879       clr debug_bit
0938 C20C       880       clr debug_bit1
093A C203       881       clr err_tmp
093C C204       882       clr err_tmp_150
093E D205       883       setb display_flag
0940 757100     884       mov seconds, #0
0943 757200     885       mov state_sec, #0
0946 756600     886       mov pwm_counter, #0
0949 756700     887       mov pwm, #0
094C D213       888       setb PB0_db
094E D214       889       setb PB1_db
0950 D215       890       setb PB2_db
0952 D216       891       setb PB3_db
0954 D217       892       setb PB4_db
0956 D218       893       setb sound_flag
0958            894       ; Show initial LCD message
0958            895       ;Set_Cursor(1, 1)
0958            896       ;Send_Constant_String(#test_message)
0958            897   
0958            898   Forever:
0958            899       ; Always read the push buttons each pass
0958 120761     900            lcall LCD_PB
095B 120864     901            lcall button_logic
095E            902            
095E            903   
095E            904   SkipCheck:
095E            905       ; Example read reference (AIN0)
095E 53E8F0     906       anl  ADCCON0, #0xF0
0961 43E800     907       orl  ADCCON0, #0x00 ; Channel0
0964 120802     908       lcall Read_ADC
0967 883D       909       mov  VAL_LM4040+0, R0
0969 893E       910       mov  VAL_LM4040+1, R1
096B            911   
096B            912       ; Read LM335 on AIN7
096B 53E8F0     913       anl  ADCCON0, #0xF0
096E 43E807     914       orl  ADCCON0, #0x07
0971 120802     915       lcall Read_ADC
0974            916   
0974            917       ; Convert to "voltage" in x
0974 8830       918       mov  x+0, R0
0976 8931       919       mov  x+1, R1
0978 753200     920       mov  x+2, #0
097B 753300     921       mov  x+3, #0
097E 7534FF     922            mov y+0, #low (40959 % 0x10000) 
0981 75359F     922            mov y+1, #high(40959 % 0x10000) 
0984 753600     922            mov y+2, #low (40959 / 0x10000) 
0987 753700     922            mov y+3, #high(40959 / 0x10000)        ; e.g. 4.0959 => times 10000 in math
098A 1202B2     923       lcall mul32
098D 853D34     924       mov  y+0, VAL_LM4040+0
0990 853E35     925       mov  y+1, VAL_LM4040+1
0993 753600     926       mov  y+2, #0
0996 753700     927       mov  y+3, #0
0999 12033F     928       lcall div32
099C            929   
099C            930       ; Add partial result to StoreMeasurements
099C 854034     931       mov  y+0, StoreMeasurements+0
099F 854135     932       mov  y+1, StoreMeasurements+1
09A2 854236     933       mov  y+2, StoreMeasurements+2
09A5 854337     934       mov  y+3, StoreMeasurements+3
09A8 1201FD     935       lcall add32
09AB 853040     936       mov  StoreMeasurements+0, x+0
09AE 853141     937       mov  StoreMeasurements+1, x+1
09B1 853242     938       mov  StoreMeasurements+2, x+2
09B4 853343     939       mov  StoreMeasurements+3, x+3
09B7            940   
09B7            941       ; Read thermocouple on AIN4
09B7 53E8F0     942       anl  ADCCON0, #0xF0
09BA 43E804     943       orl  ADCCON0, #0x04
09BD 120802     944       lcall Read_ADC
09C0            945   
09C0 8830       946       mov  x+0, R0
09C2 8931       947       mov  x+1, R1
09C4 753200     948       mov  x+2, #0
09C7 753300     949       mov  x+3, #0
09CA 7534FF     950            mov y+0, #low (40959 % 0x10000) 
09CD 75359F     950            mov y+1, #high(40959 % 0x10000) 
09D0 753600     950            mov y+2, #low (40959 / 0x10000) 
09D3 753700     950            mov y+3, #high(40959 / 0x10000) 
09D6 1202B2     951       lcall mul32
09D9 853D34     952       mov  y+0, VAL_LM4040+0
09DC 853E35     953       mov  y+1, VAL_LM4040+1
09DF 753600     954       mov  y+2, #0
09E2 753700     955       mov  y+3, #0
09E5 12033F     956       lcall div32
09E8            957   
09E8 753440     958            mov y+0, #low (1000000 % 0x10000) 
09EB 753542     958            mov y+1, #high(1000000 % 0x10000) 
09EE 75360F     958            mov y+2, #low (1000000 / 0x10000) 
09F1 753700     958            mov y+3, #high(1000000 / 0x10000) 
09F4 1202B2     959       lcall mul32
09F7            960   
09F7 7534F3     961            mov y+0, #low (243 % 0x10000) 
09FA 753500     961            mov y+1, #high(243 % 0x10000) 
09FD 753600     961            mov y+2, #low (243 / 0x10000) 
0A00 753700     961            mov y+3, #high(243 / 0x10000) 
0A03 12033F     962       lcall div32
0A06            963   
0A06 753404     964            mov y+0, #low (4100 % 0x10000) 
0A09 753510     964            mov y+1, #high(4100 % 0x10000) 
0A0C 753600     964            mov y+2, #low (4100 / 0x10000) 
0A0F 753700     964            mov y+3, #high(4100 / 0x10000) 
0A12 12033F     965       lcall div32
0A15            966   
0A15            967       ; Add partial result to StoreThermocouple
0A15 854F34     968       mov  y+0, StoreThermocouple+0
0A18 855035     969       mov  y+1, StoreThermocouple+1
0A1B 855136     970       mov  y+2, StoreThermocouple+2
0A1E 855237     971       mov  y+3, StoreThermocouple+3
0A21 1201FD     972       lcall add32
0A24 85304F     973       mov  StoreThermocouple+0, x+0
0A27 853150     974       mov  StoreThermocouple+1, x+1
0A2A 853251     975       mov  StoreThermocouple+2, x+2
0A2D 853352     976       mov  StoreThermocouple+3, x+3
0A30            977   
0A30            978       ; Delay between samples
0A30 AA4A       979       mov R2, TimePerSample
0A32 12075B     980       lcall waitms
0A35            981   
0A35            982       ; Decrement measurement counter
0A35 1546       983       dec MeasurementCounter+0
0A37 E546       984       mov a, MeasurementCounter+0
0A39 B4FF02     985       cjne a, #0xFF, CheckHigh
0A3C 1547       986       dec MeasurementCounter+1
0A3E            987   CheckHigh:
0A3E E546       988       mov a, MeasurementCounter+0
0A40 4547       989       orl a, MeasurementCounter+1
0A42 6003       990       jz  DisplayValue
0A44 020BAB     991       ljmp EndForever
0A47            992   
0A47            993   ;----------------------------------------------------------------------
0A47            994   ; If enough measurements collected -> compute final temperature
0A47            995   ;----------------------------------------------------------------------
0A47            996   DisplayValue:
0A47 753400     997            mov y+0, #low (0 % 0x10000) 
0A4A 753500     997            mov y+1, #high(0 % 0x10000) 
0A4D 753600     997            mov y+2, #low (0 / 0x10000) 
0A50 753700     997            mov y+3, #high(0 / 0x10000) 
0A53            998       ; Combine for LM335 reading
0A53 854030     999       mov x+0, StoreMeasurements+0
0A56 854131    1000       mov x+1, StoreMeasurements+1
0A59 854232    1001       mov x+2, StoreMeasurements+2
0A5C 854333    1002       mov x+3, StoreMeasurements+3
0A5F E548      1003       mov a, SamplesPerDisplay+0
0A61 F534      1004       mov y+0, a
0A63 F546      1005       mov MeasurementCounter+0, a
0A65 E549      1006       mov a, SamplesPerDisplay+1
0A67 F535      1007       mov y+1, a
0A69 F547      1008       mov MeasurementCounter+1, a
0A6B 12033F    1009       lcall div32
0A6E           1010   
0A6E           1011       ; Subtract 273.00 => Celsius reading
0A6E 7534A4    1012            mov y+0, #low (27300 % 0x10000) 
0A71 75356A    1012            mov y+1, #high(27300 % 0x10000) 
0A74 753600    1012            mov y+2, #low (27300 / 0x10000) 
0A77 753700    1012            mov y+3, #high(27300 / 0x10000) 
0A7A 12021E    1013       lcall sub32
0A7D 853057    1014       mov FinalLM335+0, x+0
0A80 853158    1015       mov FinalLM335+1, x+1
0A83 853259    1016       mov FinalLM335+2, x+2
0A86 85335A    1017       mov FinalLM335+3, x+3
0A89           1018   
0A89           1019       ; Combine for thermocouple reading
0A89 753400    1020            mov y+0, #low (0 % 0x10000) 
0A8C 753500    1020            mov y+1, #high(0 % 0x10000) 
0A8F 753600    1020            mov y+2, #low (0 / 0x10000) 
0A92 753700    1020            mov y+3, #high(0 / 0x10000) 
0A95 854F30    1021       mov x+0, StoreThermocouple+0
0A98 855031    1022       mov x+1, StoreThermocouple+1
0A9B 855132    1023       mov x+2, StoreThermocouple+2
0A9E 855233    1024       mov x+3, StoreThermocouple+3
0AA1 E548      1025       mov a, SamplesPerDisplay+0
0AA3 F534      1026       mov y+0, a
0AA5 E549      1027       mov a, SamplesPerDisplay+1
0AA7 F535      1028       mov y+1, a
0AA9 12033F    1029       lcall div32
0AAC           1030   
0AAC           1031       ; Add thermocouple to LM335 reading => final in x
0AAC 753400    1032            mov y+0, #low (0 % 0x10000) 
0AAF 753500    1032            mov y+1, #high(0 % 0x10000) 
0AB2 753600    1032            mov y+2, #low (0 / 0x10000) 
0AB5 753700    1032            mov y+3, #high(0 / 0x10000) 
0AB8 855734    1033       mov y+0, FinalLM335+0
0ABB 855835    1034       mov y+1, FinalLM335+1
0ABE 855936    1035       mov y+2, FinalLM335+2
0AC1 855A37    1036       mov y+3, FinalLM335+3
0AC4 1201FD    1037       lcall add32
0AC7           1038   
0AC7 85305B    1039       mov FinalTemp+0, x+0
0ACA 85315C    1040       mov FinalTemp+1, x+1
0ACD 85325D    1041       mov FinalTemp+2, x+2
0AD0 85335E    1042       mov FinalTemp+3, x+3
0AD3           1043   
0AD3           1044       ; --------------------------------------------------------
0AD3           1045       ; Compare final temperature with soak/reflow setpoints
0AD3           1046       ; --------------------------------------------------------
0AD3 C200      1047       clr mf
0AD5 753464    1048            mov y+0, #low (100 % 0x10000) 
0AD8 753500    1048            mov y+1, #high(100 % 0x10000) 
0ADB 753600    1048            mov y+2, #low (100 / 0x10000) 
0ADE 753700    1048            mov y+3, #high(100 / 0x10000) 
0AE1 856D30    1049       mov x+0, temp_soak
0AE4 753100    1050       mov x+1, #0
0AE7 753200    1051       mov x+2, #0
0AEA 753300    1052       mov x+3, #0
0AED 1202B2    1053       lcall mul32
0AF0 855B34    1054       mov y+0, FinalTemp+0
0AF3 855C35    1055       mov y+1, FinalTemp+1
0AF6 855D36    1056       mov y+2, FinalTemp+2
0AF9 855E37    1057       mov y+3, FinalTemp+3
0AFC 1202A8    1058       lcall x_lteq_y ; mf = 1 if temp_soak<=FinalTemp
0AFF A200      1059       mov c, mf
0B01 9208      1060       mov temp_state1, c
0B03           1061   
0B03 C200      1062       clr mf
0B05 753464    1063            mov y+0, #low (100 % 0x10000) 
0B08 753500    1063            mov y+1, #high(100 % 0x10000) 
0B0B 753600    1063            mov y+2, #low (100 / 0x10000) 
0B0E 753700    1063            mov y+3, #high(100 / 0x10000) 
0B11 856F30    1064       mov x+0, temp_refl
0B14 753100    1065       mov x+1, #0
0B17 753200    1066       mov x+2, #0
0B1A 753300    1067       mov x+3, #0
0B1D 1202B2    1068       lcall mul32
0B20 855B34    1069       mov y+0, FinalTemp+0
0B23 855C35    1070       mov y+1, FinalTemp+1
0B26 855D36    1071       mov y+2, FinalTemp+2
0B29 855E37    1072       mov y+3, FinalTemp+3
0B2C 1202A8    1073       lcall x_lteq_y ; mf = 1 if temp_refl<=FinalTemp
0B2F A200      1074       mov c, mf
0B31 9209      1075       mov temp_state3, c
0B33           1076   
0B33           1077       ; Check error states
0B33 855B30    1078       mov x+0, FinalTemp+0
0B36 855C31    1079       mov x+1, FinalTemp+1
0B39 855D32    1080       mov x+2, FinalTemp+2
0B3C 855E33    1081       mov x+3, FinalTemp+3
0B3F           1082   
0B3F C200      1083       clr mf
0B41 7534A8    1084            mov y+0, #low (25000 % 0x10000) 
0B44 753561    1084            mov y+1, #high(25000 % 0x10000) 
0B47 753600    1084            mov y+2, #low (25000 / 0x10000) 
0B4A 753700    1084            mov y+3, #high(25000 / 0x10000) 
0B4D 12029E    1085       lcall x_gteq_y ; mf = 1 if FinalTemp<=250
0B50 A200      1086       mov c, mf
0B52 9204      1087       mov err_tmp_150, c
0B54           1088   
0B54 C200      1089       clr mf
0B56 753488    1090            mov y+0, #low (5000 % 0x10000) 
0B59 753513    1090            mov y+1, #high(5000 % 0x10000) 
0B5C 753600    1090            mov y+2, #low (5000 / 0x10000) 
0B5F 753700    1090            mov y+3, #high(5000 / 0x10000) 
0B62 12029E    1091       lcall x_gteq_y ; mf = 1 if FinalTemp>=50
0B65 A200      1092       mov c, mf
0B67 9203      1093       mov err_tmp, c
0B69           1094   
0B69 C200      1095       clr mf
0B6B 7534B8    1096            mov y+0, #low (3000 % 0x10000) 
0B6E 75350B    1096            mov y+1, #high(3000 % 0x10000) 
0B71 753600    1096            mov y+2, #low (3000 / 0x10000) 
0B74 753700    1096            mov y+3, #high(3000 / 0x10000) 
0B77 1202A8    1097       lcall x_lteq_y ; mf = 1 if FinalTemp<=60
0B7A A200      1098       mov c, mf
0B7C 920A      1099       mov temp_state5, c
0B7E           1100   
0B7E           1101   
0B7E           1102   
0B7E           1103       ; Convert FinalTemp => BCD => display
0B7E 120138    1104       lcall hex2bcd
0B81 12081D    1105       lcall SendBCD
0B84           1106       
0B84           1107      ; jnb display_temp EndForever
0B84 1207AE    1108       lcall Display_formated_BCD
0B87           1109   
0B87 754000    1110       mov StoreMeasurements+0, #0
0B8A 754100    1111       mov StoreMeasurements+1, #0
0B8D 754200    1112       mov StoreMeasurements+2, #0
0B90 754300    1113       mov StoreMeasurements+3, #0
0B93           1114   
0B93 754F00    1115       mov StoreThermocouple+0, #0
0B96 755000    1116       mov StoreThermocouple+1, #0
0B99 755100    1117       mov StoreThermocouple+2, #0
0B9C 755200    1118       mov StoreThermocouple+3, #0
0B9F           1119   
0B9F 755700    1120       mov FinalLM335+0, #0
0BA2 755801    1121       mov FinalLM335+1, #1
0BA5 755902    1122       mov FinalLM335+2, #2
0BA8 755A03    1123       mov FinalLM335+3, #3
0BAB           1124   
0BAB           1125   EndForever:
0BAB           1126       ; Always read the push buttons each pass
0BAB           1127       ;lcall LCD_PB
0BAB           1128       ; Reset accumulators
0BAB           1129   
0BAB 753000    1130       mov x+0, #0
0BAE 753100    1131       mov x+1, #0
0BB1 753200    1132       mov x+2, #0
0BB4 753300    1133       mov x+3, #0
0BB7 020958    1134       ljmp Forever
0BBA           1135   
0BBA           1136   END
