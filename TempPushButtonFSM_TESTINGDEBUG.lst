0000              1   ;----------------------------------------------------------------------
0000              2   ; 76E003 ADC test program (reflow oven controller + push buttons)
0000              3   ; Reads channel 7 on P1.1, pin 14
0000              4   ; This version uses the LM4040 voltage reference connected to pin 6 (P1.7/AIN0)
0000              5   ; Incorporates push-button control to set up times/temperatures and start FSM.
0000              6   ;----------------------------------------------------------------------
0000              7   
                  9   $LIST
0000             11   
0000             12   ;  N76E003 pinout:
0000             13   ;                               -------
0000             14   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             15   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             16   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             17   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             18   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             19   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             20   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             21   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             22   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             23   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             24   ;                               -------
0000             25   ;
0000             26   
0000             27   ;----------------------------------------------------------------------
0000             28   ; System/Timer/Constants
0000             29   ;----------------------------------------------------------------------
0000             30   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             31   BAUD              EQU 115200   ; Baud rate of UART in bps
0000             32   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             33   
0000             34   TIMER2_RATE       EQU 100      ; 100 Hz -> 10ms tick
0000             35   TIMER2_RELOAD     EQU ((65536-(CLK/(16*TIMER2_RATE))))
0000             36   
0000             37   SAMPLES_PER_DISPLAY  EQU 300
0000             38   REFRESHES_PER_SECOND EQU 45
0000             39   TIMER0_DENOM         EQU (SAMPLES_PER_DISPLAY*REFRESHES_PER_SECOND)
0000             40   TIMER0_RELOAD        EQU (0x10000-(CLK/TIMER0_DENOM))
0000             41   
0000             42   ORG 0x0000
0000 020688      43       ljmp main
0003             44   
002B             45   org 0x002B
002B 020385      46       ljmp Timer2_ISR
002E             47   
002E             48   ;----------------------------------------------------------------------
002E             49   ; Hardware Pin Definitions
002E             50   ;----------------------------------------------------------------------
002E             51   
002E             52   ; PUSH BUTTONS (single-pin read approach)
002E             53   PB_INPUT_PIN   EQU P1.5  ; The single pin used to read all 5 PBs
002E             54   MUX_CONTROL_0  EQU P1.3  
002E             55   MUX_CONTROL_1  EQU P0.0  
002E             56   MUX_CONTROL_2  EQU P0.1  
002E             57   MUX_CONTROL_3  EQU P0.2  
002E             58   MUX_CONTROL_4  EQU P0.3  
002E             59   
002E             60   ; LCD assignments
002E             61   LCD_RS  equ P1.3
002E             62   LCD_E   equ P1.4
002E             63   LCD_D4  equ P0.0
002E             64   LCD_D5  equ P0.1
002E             65   LCD_D6  equ P0.2
002E             66   LCD_D7  equ P0.3
002E             67   SSR_BOX equ P0.4
002E             68   
002E             69   ; Strings for LCD
002E 43757272    70   test_message:     db 'Current Temp.:', 0
     656E7420
     54656D70
     2E3A00
003D 4465672E    71   value_message:    db 'Deg. C', 0
     204300
0044             72   
0044             73   cseg
0044             74   
                 76   	$LIST
00F8             78   
00F8             79   ;----------------------------------------------------------------------
00F8             80   ; 32-bit math placeholders
00F8             81   ;----------------------------------------------------------------------
0030             82   DSEG at 30H
0030             83   x:   ds 4
0034             84   y:   ds 4
0038             85   bcd: ds 5
003D             86   VAL_LM4040: ds 2
003F             87   
003F             88   ; Variables
003F             89   state:              ds 1
0040             90   StoreMeasurements:  ds 4
0044             91   TempStore:          ds 2
0046             92   MeasurementCounter: ds 2
0048             93   SamplesPerDisplay:  ds 2
004A             94   TimePerSample:      ds 1
004B             95   LastMeasurement:    ds 4
004F             96   StoreThermocouple:  ds 4
0053             97   CurrentTemp:        ds 4
0057             98   FinalLM335:         ds 4
005B             99   FinalTemp:          ds 4
005F            100   selected_state:          ds 1
0060            101   
0060            102   Count1ms:      ds 2
0062            103   pwm_counter:   ds 1
0063            104   pwm:           ds 1
0064            105   
0064            106   ; Oven settings
0064            107   temp_soak: ds 1  ; For state 1
0065            108   time_soak: ds 1  ; For state 2
0066            109   temp_refl: ds 1  ; For state 3
0067            110   time_refl: ds 1  ; For state 4
0068            111   
0068            112   seconds: ds 1
0069            113   state_sec: ds 1
006A            114   
006A            115   ;----------------------------------------------------------------------
006A            116   ; Bit variables (BSEG)
006A            117   ;----------------------------------------------------------------------
0000            118   BSEG
0000            119   mf:            dbit 1
0001            120   m_flag:        dbit 1
0002            121   s_flag:        dbit 1
0003            122   err_tmp:       dbit 1
0004            123   err_tmp_150:   dbit 1
0005            124   
0005            125   start:         dbit 1  ; Start the FSM
0006            126   temp_state1:   dbit 1
0007            127   temp_state3:   dbit 1
0008            128   temp_state5:   dbit 1
0009            129   
0009            130   debug_bit:     dbit 1 ;Set to true to check which lines of code actually execute
000A            131   
000A            132   ; For push buttons
000A            133   PB0: dbit 1  ; Start/Pause
000B            134   PB1: dbit 1  ; Toggle selected parameter
000C            135   PB2: dbit 1  ; Increment
000D            136   PB3: dbit 1  ; Decrement
000E            137   PB4: dbit 1  ; Unused or extra
000F            138   
000F            139   ;SETATS
000F            140   
000F            141   ; We include math32 at the end of initialization
                546   $LIST
                143   $LIST
0368            145   
0368            146   ;----------------------------------------------------------------------
0368            147   ; Timer2 Initialization & ISR
0368            148   ;----------------------------------------------------------------------
0368            149   Timer2_Init:
0368 75C800     150       mov T2CON, #0       ; Stop timer, mode = auto-reload
036B 75CDD7     151       mov TH2, #high(TIMER2_RELOAD)
036E 75CC79     152       mov TL2, #low(TIMER2_RELOAD)
0371 43C9A0     153       orl T2MOD, #0b1010_0000    ; Enable auto-reload
0374 75CBD7     154       mov RCMP2H, #high(TIMER2_RELOAD)
0377 75CA79     155       mov RCMP2L, #low(TIMER2_RELOAD)
037A E4         156       clr  a
037B F560       157       mov  Count1ms+0, a
037D F561       158       mov  Count1ms+1, a
037F 439B80     159       orl  EIE, #0x80     ; Enable timer2 interrupt (ET2=1)
0382 D2CA       160       setb TR2            ; Start Timer2
0384 22         161       ret
0385            162   
0385            163   Timer2_ISR:
0385 C2CF       164       clr TF2 ; Must clear TF2 manually on N76
0387 C0E0       165       push acc
0389 C0D0       166       push psw
038B            167   
038B            168       ;---------------------------------
038B            169       ; PWM for SSR control
038B            170       ;---------------------------------
038B 0562       171       inc pwm_counter ;Every 10ms, pwm_counter is incremented
038D C3         172       clr c
038E E563       173       mov a, pwm
0390 9562       174       subb a, pwm_counter ; if pwm_counter <= pwm, c=1, so if pwm=20 for example, if 210ms has passed, c = 0, and the SSR box is always on
0392 B3         175       cpl c
0393 9284       176       mov SSR_BOX, c
0395            177   
0395 E562       178       mov a, pwm_counter
0397 B46412     179       cjne a, #100, State_0 ; If 1 second has not passed, skip to State_0
039A 756200     180       mov pwm_counter, #0 ; Reset pwm_counter
039D 0568       181       inc seconds ; Increment seconds
039F 0569       182       inc state_sec ; Will only increment in states 2 and 4, gets reset to 0 in all other states otherrwise
03A1 E4         183       clr a
03A2 E568       184       mov a, seconds
03A4 B43C05     185       cjne a, #60, State_0 ;If exactly 60 seconds has not passed, skip to State_0, otherwise set m_flag to indicate a minute has passed
03A7 D201       186       setb m_flag
03A9 0203AC     187       ljmp State_0
03AC            188   
03AC            189   
03AC            190   State_0:
03AC E53F       191       mov a, state
03AE B40010     192            cjne a, #0, State_1
03B1 E4         193       clr a
03B2 756900     194       mov state_sec, #0
03B5 756300     195            mov pwm, #0
03B8 30054C     196            jnb start, jumpy 
03BB 753F01     197            mov state, #1
03BE 020458     198            ljmp Timer2_ISR_done
03C1            199            
03C1            200   State_1:
03C1 E53F       201            mov a, state
03C3 B40128     202            cjne a, #1, State_2
03C6 756364     203            mov pwm, #100                                   ; set pwm for relfow oven to 100%
03C9 756900     204       mov state_sec, #0
03CC            205   ;        jb m_flag, Cond_check
03CC            206   ;        mov c, temp_state1
03CC            207   ;        clr a                                                   ; clear the accumulator
03CC            208   ;        mov acc.0, c
03CC            209   ;        clr c                                                   ; clear the carry bit
03CC 300638     210            jnb temp_state1, jumpy          ; mf = 1 if oven temp <= set temp, jump out of ISR. mf = 0 if oven temp > set temp, thus move onto next state                   
03CF E4         211            clr a                                           
03D0 753F02     212            mov state, #2
03D3 756900     213       mov state_sec, #0
03D6 0203EE     214            ljmp State_2
03D9            215   
03D9            216   Cond_check: ; cjne is not bit-addressable, therefore we must move bits into byte registers (i.e. accumulator and register b)
03D9 A203       217            mov c, err_tmp
03DB E4         218            clr a 
03DC 92E0       219            mov acc.0, c ; mov value in carry to the lowest bit of the accumulator
03DE A201       220            mov c, m_flag
03E0 C201       221            clr m_flag ; clear minute flag
03E2 75F000     222            mov b, #00h 
03E5 92F0       223            mov b.0, c ; mov value in carry to the lowest bit of the B regrister
03E7 C3         224            clr c
03E8 B5F069     225            cjne a, b, State_error
03EB 0203C1     226            ljmp State_1
03EE            227   
03EE            228   State_2: ;transition to state three if more than 60 seconds have passed
03EE E53F       229            mov a, state
03F0 B40217     230            cjne a, #2, State_3
03F3 756314     231            mov pwm, #20
03F6 20045B     232            jb err_tmp_150, State_error
03F9 E4         233       clr a        
03FA E569       234       mov a, state_sec
03FC C3         235       clr c
03FD 9565       236       subb a, time_soak ; If state_sec - time_soak is negative (so not enough time has passed), then c = 1, 
03FF 4057       237       jc Timer2_ISR_done
0401 753F03     238            mov state, #3
0404 756900     239       mov state_sec, #0
0407            240   
0407            241   jumpy:
0407 020458     242       ljmp Timer2_ISR_done
040A            243   
040A            244   State_3: 
040A E53F       245            mov a, state
040C B40313     246            cjne a, #3, State_4 ; check if state = 3, if not, move to state_4
040F 756364     247            mov pwm, #100 ; set pwm to 100%
0412 756900     248       mov state_sec, #0
0415 20043C     249            jb err_tmp_150, State_error
0418            250            ;mov c, temp_state3
0418            251            ;clr a                                                          ; clear the accumulator
0418            252            ;mov acc.0, c
0418            253            ;clr c                                                          ; clear the carry bit
0418            254            ;cjne a, #0, Timer2_ISR_done ;
0418 30073D     255       jnb temp_state3, Timer2_ISR_done
041B E4         256            clr a
041C 756900     257       mov state_sec, #0
041F 753F04     258            mov state, #4
0422            259   
0422            260   State_4:
0422 E53F       261            mov a, state
0424 B40413     262            cjne a, #4, State_5
0427 756314     263            mov pwm, #20
042A 200427     264            jb err_tmp_150, State_error
042D E4         265       clr a
042E E569       266       mov a, state_sec
0430 9567       267       subb a, time_refl
0432 4024       268       jc Timer2_ISR_Done    
0434 753F05     269            mov state, #5
0437 756900     270       mov state_sec, #0
043A            271   
043A            272   State_5:
043A E53F       273            mov a, state
043C B40519     274            cjne a, #5, Timer2_ISR_done
043F 756300     275            mov pwm, #0
0442 756900     276       mov state_sec, #0
0445 20040C     277       jb err_tmp_150, State_error
0448 30080D     278       jnb temp_state5, Timer2_ISR_done
044B 753F00     279            mov state, #0
044E 756900     280       mov state_sec, #0
0451 020458     281       ljmp Timer2_ISR_done
0454            282   
0454            283   State_error:
0454 7400       284            mov a, #0
0456 F53F       285            mov state, a
0458            286            ; probably should put branch for warning message here
0458            287   
0458            288   Timer2_ISR_done:
0458 D0D0       289       pop psw
045A D0E0       290       pop acc
045C 32         291       reti
045D            292   
045D            293   ;----------------------------------------------------------------------
045D            294   ; Initialization
045D            295   ;----------------------------------------------------------------------
045D            296   Init_All:
045D            297       ; Configure all the pins for bidirectional I/O
045D 75AC00     298       mov P3M1, #0x00
0460 75AD00     299       mov P3M2, #0x00
0463 75B300     300       mov P1M1, #0x00
0466 75B400     301       mov P1M2, #0x00
0469 75B100     302       mov P0M1, #0x00
046C 75B200     303       mov P0M2, #0x00
046F            304   
046F 120368     305       lcall Timer2_Init
0472            306   
0472            307       ; Timer1 for UART
0472 438E10     308       orl  CKCON, #0x10     ; Timer1 uses system clock
0475 438780     309       orl  PCON,  #0x80     ; SMOD=1 -> double baud
0478 759852     310       mov  SCON,  #0x52     ; UART mode 1, REN=1
047B 53C4DF     311       anl  T3CON, #0b11011111
047E 53890F     312       anl  TMOD,  #0x0F
0481 438920     313       orl  TMOD,  #0x20     ; Timer1 Mode2 (8-bit auto-reload)
0484 758DF7     314       mov  TH1, #TIMER1_RELOAD
0487 D28E       315       setb TR1
0489            316   
0489            317       ; Timer0 for waitms
0489 C28C       318       clr TR0
048B 438E08     319       orl CKCON, #0x08
048E 5389F0     320       anl TMOD,  #0xF0
0491 438901     321       orl TMOD,  #0x01      ; 16-bit mode
0494            322       ; ADC pins: P1.1 (AIN7), P1.7 (AIN0)
0494 43B382     323       orl P1M1, #0b10000010 ; Set P1.1 & P1.7 as input
0497 53B47D     324       anl P1M2, #0b01111101
049A            325   
049A            326       ; Initialize ADC
049A 53E8F0     327       anl ADCCON0, #0xF0
049D 43E807     328       orl ADCCON0, #0x07    ; default to channel 7
04A0 75F600     329       mov AINDIDS, #0x00    ; disable all digital inputs
04A3 43F681     330       orl AINDIDS, #0b10000001 ; activate AIN0 and AIN7
04A6 43E101     331       orl ADCCON1, #0x01    ; enable ADC
04A9 22         332       ret
04AA            333   
04AA            334   ;----------------------------------------------------------------------
04AA            335   ; Delay Routines
04AA            336   ;----------------------------------------------------------------------
04AA            337   wait_1ms:
04AA C28C       338       clr TR0
04AC C28D       339       clr TF0
04AE 758CFB     340       mov TH0, #high(TIMER0_RELOAD)
04B1 758A33     341       mov TL0, #low(TIMER0_RELOAD)
04B4 D28C       342       setb TR0
04B6 308DFD     343       jnb TF0, $
04B9 22         344       ret
04BA            345   
04BA            346   ; Wait R2 milliseconds
04BA            347   waitms:
04BA 1204AA     348       lcall wait_1ms
04BD DAFB       349       djnz R2, waitms
04BF 22         350       ret
04C0            351   
04C0            352   ;----------------------------------------------------------------------
04C0            353   ; LCD_PB: Read the 5 push buttons into PB0..PB4 bits
04C0            354   ;----------------------------------------------------------------------
04C0            355   LCD_PB:
04C0            356       ; Default all PB bits to 1 (released)
04C0 D20A       357       setb PB0 
04C2 D20B       358       setb PB1
04C4 D20C       359       setb PB2
04C6 D20D       360       setb PB3
04C8 D20E       361       setb PB4
04CA            362       ; The input pin is idle-high (pull-up)
04CA D295       363       setb PB_INPUT_PIN
04CC            364   
04CC            365       ; Set MUX lines to 0 first
04CC C293       366       clr MUX_CONTROL_0
04CE C280       367       clr MUX_CONTROL_1
04D0 C281       368       clr MUX_CONTROL_2
04D2 C282       369       clr MUX_CONTROL_3
04D4 C283       370       clr MUX_CONTROL_4
04D6            371   
04D6            372       ;---------------------------------
04D6            373       ; Debouncing
04D6            374       ;---------------------------------
04D6 20953A     375       jb  PB_INPUT_PIN, LCD_PB_Done 
04D9 7A32       376       mov R2, #50
04DB 1204BA     377       lcall waitms
04DE            378       
04DE 209532     379       jb  PB_INPUT_PIN, LCD_PB_Done
04E1            380   
04E1            381       ; Now set all MUX lines = 1 to read them individually
04E1 D293       382       setb MUX_CONTROL_0
04E3 D280       383       setb MUX_CONTROL_1
04E5 D281       384       setb MUX_CONTROL_2
04E7 D282       385       setb MUX_CONTROL_3
04E9 D283       386       setb MUX_CONTROL_4
04EB            387   
04EB            388       ; Check PB4
04EB C283       389       clr MUX_CONTROL_4
04ED A295       390       mov c, PB_INPUT_PIN
04EF 920E       391       mov PB4, c
04F1 D283       392       setb MUX_CONTROL_4
04F3            393   
04F3            394       ; Check PB3
04F3 C282       395       clr MUX_CONTROL_3
04F5 A295       396       mov c, PB_INPUT_PIN
04F7 920D       397       mov PB3, c
04F9 D282       398       setb MUX_CONTROL_3
04FB            399   
04FB            400       ; Check PB2
04FB C281       401       clr MUX_CONTROL_2
04FD A295       402       mov c, PB_INPUT_PIN
04FF 920C       403       mov PB2, c
0501 D281       404       setb MUX_CONTROL_2
0503            405   
0503            406       ; Check PB1
0503 C280       407       clr MUX_CONTROL_1
0505 A295       408       mov c, PB_INPUT_PIN
0507 920B       409       mov PB1, c
0509 D280       410       setb MUX_CONTROL_1
050B            411   
050B            412       ; Check PB0
050B C293       413       clr MUX_CONTROL_0
050D A295       414       mov c, PB_INPUT_PIN
050F 920A       415       mov PB0, c
0511 D293       416       setb MUX_CONTROL_0
0513            417   
0513            418   LCD_PB_Done:
0513 22         419       ret
0514            420   
0514            421   ;----------------------------------------------------------------------
0514            422   ; Display_formated_BCD: Display the result with decimal
0514            423   ;----------------------------------------------------------------------
0514            424   Display_formated_BCD:
0514 C0E0       425            push acc
0516 7401       425            mov a, #1
0518 14         425            dec a
0519 1200DB     425            lcall ?Set_Cursor_2 ; Select column and row
051C D0E0       425            pop acc
051E C000       426            push ar0
0520 A83A       426            mov r0, bcd+2
0522 1200E2     426            lcall ?Display_BCD
0525 D000       426            pop ar0
0527 C000       427            push ar0
0529 A839       427            mov r0, bcd+1
052B 1200E2     427            lcall ?Display_BCD
052E D000       427            pop ar0
0530 C0E0       428            push acc
0532 742E       428            mov a, #'.'
0534 120093     428            lcall ?WriteData
0537 D0E0       428            pop acc
0539 C000       429            push ar0
053B A838       429            mov r0, bcd+0
053D 1200E2     429            lcall ?Display_BCD
0540 D000       429            pop ar0
0542 C0E0       430            push acc
0544 74DF       430            mov a, #0xDF
0546 120093     430            lcall ?WriteData
0549 D0E0       430            pop acc    ; Degree symbol
054B C0E0       431            push acc
054D 7443       431            mov a, #'C'
054F 120093     431            lcall ?WriteData
0552 D0E0       431            pop acc
0554 C0E0       432            push acc
0556 7401       432            mov a, #1
0558 14         432            dec a
0559 1200DB     432            lcall ?Set_Cursor_2 ; Select column and row
055C D0E0       432            pop acc
055E C0E0       433            push acc
0560 7420       433            mov a, #' '
0562 120093     433            lcall ?WriteData
0565 D0E0       433            pop acc
0567 22         434       ret
0568            435   
0568            436   ;----------------------------------------------------------------------
0568            437   ; Read_ADC: reads current ADC channel into R0:R1 (12-bit)
0568            438   ;----------------------------------------------------------------------
0568            439   Read_ADC:
0568 C2EF       440       clr  ADCF
056A D2EE       441       setb ADCS
056C 30EFFD     442       jnb  ADCF, $          ; Wait conversion
056F E5C2       443       mov  a, ADCRL
0571 540F       444       anl  a, #0x0F
0573 F8         445       mov  R0, a
0574 E5C3       446       mov  a, ADCRH
0576 C4         447       swap a
0577 C0E0       448       push acc
0579 540F       449       anl  a, #0x0F
057B F9         450       mov  R1, a
057C D0E0       451       pop  acc
057E 54F0       452       anl  a, #0xF0
0580 48         453       orl  a, R0
0581 F8         454       mov  R0, a
0582 22         455       ret
0583            456   
0583            457   ;----------------------------------------------------------------------
0583            458   ; New code for push-button-based FSM parameter updates
0583            459   ; We intercept button presses in SendSerial
0583            460   ;----------------------------------------------------------------------
0583            461   SendBCD:
0583            462   
0583 E53A       463            mov a, bcd+2
0585 540F       464            anl a, #0x0F ; Isolate ones place
0587 2430       465            add a, #'0' ; Convert value to ASCII
0589 120616     466            lcall SendSerial
058C            467   
058C E539       468            mov a, bcd+1
058E 54F0       469            anl a, #0xF0 ; Isolate tens place
0590 C4         470            swap a ; Put high nibble into lower nibble
0591 2430       471            add a, #'0' ; Convert value to ASCII
0593 120616     472            lcall SendSerial
0596            473   
0596 E539       474            mov a, bcd+1
0598 540F       475            anl a, #0x0F ; Isolate ones place
059A 2430       476            add a, #'0' ; Convert value to ASCII
059C 120616     477            lcall SendSerial
059F            478   
059F 742E       479            mov a, #'.'
05A1 120616     480            lcall SendSerial
05A4            481   
05A4 E538       482            mov a, bcd+0
05A6 54F0       483            anl a, #0xF0 ; Isolate 0.1 place
05A8 C4         484            swap a ; Put high nibble into lower nibble
05A9 2430       485            add a, #'0' ; Convert value to ASCII
05AB 120616     486            lcall SendSerial
05AE            487   
05AE E538       488            mov a, bcd+0
05B0 540F       489            anl a, #0x0F ; Isolate 0.01 place
05B2 2430       490            add a, #'0' ; Convert value to ASCII
05B4 120616     491            lcall SendSerial
05B7            492   
05B7 7420       493       mov a, #' '
05B9 120616     494       lcall SendSerial
05BC            495   
05BC 7400       496       mov a, #0
05BE A206       497       mov c, temp_state1
05C0 92E0       498       mov acc.0, c
05C2 2430       499       add a, #'0'
05C4 120616     500       lcall SendSerial
05C7            501       
05C7 7420       502       mov a, #' '
05C9 120616     503       lcall SendSerial
05CC            504       
05CC E53F       505       mov a, state
05CE 2430       506       add a, #'0'
05D0 120616     507       lcall SendSerial
05D3            508   
05D3 7420       509       mov a, #' '
05D5 120616     510       lcall SendSerial
05D8            511   
05D8 7400       512       mov a, #0
05DA A209       513       mov c, debug_bit
05DC 92E0       514       mov acc.0, c
05DE 2430       515       add a, #'0'
05E0 120616     516       lcall SendSerial
05E3            517   
05E3 7420       518       mov a, #' '
05E5 120616     519       lcall SendSerial
05E8            520       
05E8 E569       521       mov a, state_sec
05EA 2430       522       add a, #'0'
05EC 120616     523       lcall SendSerial
05EF            524   
05EF 7420       525       mov a, #' '
05F1 120616     526       lcall SendSerial
05F4            527       
05F4 E568       528       mov a, seconds
05F6 2430       529       add a, #'0'
05F8 120616     530       lcall SendSerial
05FB            531   
05FB 7420       532           mov a, #' '
05FD 120616     533       lcall SendSerial
0600            534   
0600 7400       535       mov a, #0
0602 A284       536       mov c, SSR_BOX
0604 92E0       537       mov acc.0, c
0606 2430       538       add a, #'0'
0608 120616     539       lcall SendSerial
060B            540   
060B 740A       541            mov a, #'\n'
060D 120616     542            lcall SendSerial
0610            543   
0610 740D       544            mov a, #'\r'
0612 120616     545            lcall SendSerial
0615            546   
0615 22         547            ret
0616            548   
0616            549   
0616            550   SendSerial:
0616            551       ; Simulate sending 'a' to UART
0616 C299       552       clr  TI
0618 F599       553       mov  SBUF, a
061A            554       ; Wait for TX
061A            555   WaitTx:
061A 3099FD     556       jnb TI, WaitTx
061D C299       557       clr TI
061F            558   
061F            559       ; Now check buttons each time we "send":
061F            560       ; If button is pressed (bit=0), jump to its handler.
061F 300A0A     561       jnb PB0, start_oven
0622 300B0C     562       jnb PB1, toggle_state
0625 300C17     563       jnb PB2, inc_value
0628 300D36     564       jnb PB3, dec_value
062B            565       ; PB4 is unused for now, do nothing if pressed.
062B            566   
062B 22         567       ret
062C            568   
062C            569   ; Start the FSM
062C            570   start_oven:
062C D205       571       setb start                           ; set the flag to 1, indicating that the FSM should begin
062E            572       ;mov start, # 1                                ; return to main or update display as needed
062E 020687     573       ljmp end_button_logic           ; jump to exit logic
0631            574   
0631            575   ; Toggle which parameter is selected (1..4)
0631            576   toggle_state:
0631 E55F       577       mov a, selected_state           ; load the selected state to the accumulator
0633 2401       578       add a, #1                       ; icnrement the selection
0635 B40502     579       cjne a, #5, noWrap              ; if not greater than 4, jump to noWrap
0638 7401       580       mov a, #1                       ; if (selected_state == 5), reset the selected state, i.e. selected_state == 1
063A            581   noWrap:
063A F55F       582       mov selected_state, a           ; store the updated selected_state
063C 020687     583       ljmp end_button_logic           ; jump to exit logic
063F            584   
063F            585   ; Increment whichever parameter is selected
063F            586   ; ** DOUBLE CHECK THIS LOGIC IM NOT TOO SURE **
063F            587   inc_value:
063F E55F       588       mov a, selected_state           ; load the selected state into the accumulator
0641 B40105     589       cjne a, #1, checkState2         ; if selected_state != temp_soak, check the next selected state
0644 0564       590       inc temp_soak                   ; increment temp_soak if above condition not true
0646 020687     591       ljmp end_button_logic           ; jump to exit logic
0649            592   
0649            593   checkState2:                    
0649 B40205     594       cjne a, #2, checkState3         ; if not time_soak, check the next parameter
064C 0565       595       inc time_soak                   ; increment time_soak
064E 020687     596       ljmp end_button_logic           ; jump to exit logic
0651            597   
0651            598   checkState3:
0651 B40305     599       cjne a, #3, checkState4         ; if not temp_refl, check next parameter
0654 0566       600       inc temp_refl                   ; increment temp_refl
0656 020687     601       ljmp end_button_logic           ; jump to exit logic
0659            602   
0659            603   checkState4:                        
0659 B4042B     604       cjne a, #4, end_button_logic    ; if not time_refl, exit 
065C 0567       605       inc time_refl                   ; inc time_refl
065E 020687     606       ljmp end_button_logic           ; jump to exit logic
0661            607   
0661            608   ; Decrement whichever parameter is selected
0661            609   ; ** SAME IDEA BUT CHECK THE LOGIC PLEASE ** 
0661            610   dec_value:
0661 E55F       611       mov a, selected_state
0663 B40106     612       cjne a, #1, dcheckState2
0666 D5641E     613       djnz temp_soak, end_button_logic
0669 020687     614       ljmp end_button_logic
066C            615   
066C            616   dcheckState2:
066C B40206     617       cjne a, #2, dcheckState3
066F D56515     618       djnz time_soak, end_button_logic
0672 020687     619       ljmp end_button_logic
0675            620   
0675            621   dcheckState3:
0675 B40306     622       cjne a, #3, dcheckState4
0678 D5660C     623       djnz temp_refl, end_button_logic
067B 020687     624       ljmp end_button_logic
067E            625   
067E            626   dcheckState4:
067E B40406     627       cjne a, #4, end_button_logic
0681 D56703     628       djnz time_refl, end_button_logic
0684 020687     629       ljmp end_button_logic
0687            630   
0687            631   end_button_logic:
0687 22         632       ret
0688            633   
0688            634   ;----------------------------------------------------------------------
0688            635   ; main
0688            636   ;----------------------------------------------------------------------
0688            637   main:
0688 75817F     638       mov sp, #0x7F
068B 12045D     639       lcall Init_All
068E 12009D     640       lcall LCD_4BIT
0691 120368     641       lcall Timer2_Init ; initialize interupts 
0694 D2AF       642       setb EA
0696            643   
0696 754601     644       mov MeasurementCounter+0, #1
0699 754700     645       mov MeasurementCounter+1, #0
069C 754A01     646       mov TimePerSample, #1
069F            647   
069F 75482C     648       mov SamplesPerDisplay+0, #low(SAMPLES_PER_DISPLAY)
06A2 754901     649       mov SamplesPerDisplay+1, #high(SAMPLES_PER_DISPLAY)
06A5            650   
06A5            651       ; We start with "state=0" (idle)
06A5 753F00     652       mov state, #0
06A8 C205       653       clr start 
06AA C201       654       clr m_flag
06AC            655   
06AC            656       ; Default setpoints
06AC 75641C     657       mov temp_soak, #28
06AF 756505     658       mov time_soak, #5
06B2 75661E     659       mov temp_refl, #30
06B5 756705     660       mov time_refl, #5
06B8            661   
06B8            662       ; Which parameter we are currently adjusting: 1=temp_soak,2=time_soak,3=temp_refl,4=time_refl
06B8 755F01     663       mov selected_state, #1
06BB            664   
06BB 754B00     665       mov LastMeasurement+0, #0
06BE 754C00     666       mov LastMeasurement+1, #0
06C1 754D00     667       mov LastMeasurement+2, #0
06C4 754E00     668       mov LastMeasurement+3, #0
06C7            669       
06C7 C206       670       clr temp_state1
06C9 C207       671       clr temp_state3
06CB C209       672       clr debug_bit
06CD C203       673       clr err_tmp
06CF C204       674       clr err_tmp_150
06D1 756800     675       mov seconds, #0
06D4 756900     676       mov state_sec, #0
06D7 756200     677       mov pwm_counter, #0
06DA 756300     678       mov pwm, #0
06DD            679   
06DD            680       ; Show initial LCD message
06DD C0E0       681            push acc
06DF 7401       681            mov a, #1
06E1 14         681            dec a
06E2 1200DD     681            lcall ?Set_Cursor_1 ; Select column and row
06E5 D0E0       681            pop acc
06E7 C083       682            push dph
06E9 C082       682            push dpl
06EB C0E0       682            push acc
06ED 90002E     682            mov dptr, #test_message
06F0 1200D0     682            lcall ?Send_Constant_String
06F3 D0E0       682            pop acc
06F5 D082       682            pop dpl
06F7 D083       682            pop dph
06F9            683   
06F9            684   Forever:
06F9            685       ; Example read reference (AIN0)
06F9 53E8F0     686       anl  ADCCON0, #0xF0
06FC 43E800     687       orl  ADCCON0, #0x00 ; Channel0
06FF 120568     688       lcall Read_ADC
0702 883D       689       mov  VAL_LM4040+0, R0
0704 893E       690       mov  VAL_LM4040+1, R1
0706            691   
0706            692       ; Read LM335 on AIN7
0706 53E8F0     693       anl  ADCCON0, #0xF0
0709 43E807     694       orl  ADCCON0, #0x07
070C 120568     695       lcall Read_ADC
070F            696   
070F            697       ; Convert to "voltage" in x
070F 8830       698       mov  x+0, R0
0711 8931       699       mov  x+1, R1
0713 753200     700       mov  x+2, #0
0716 753300     701       mov  x+3, #0
0719 7534FF     702            mov y+0, #low (40959 % 0x10000) 
071C 75359F     702            mov y+1, #high(40959 % 0x10000) 
071F 753600     702            mov y+2, #low (40959 / 0x10000) 
0722 753700     702            mov y+3, #high(40959 / 0x10000)        ; e.g. 4.0959 => times 10000 in math
0725 120272     703       lcall mul32
0728 853D34     704       mov  y+0, VAL_LM4040+0
072B 853E35     705       mov  y+1, VAL_LM4040+1
072E 753600     706       mov  y+2, #0
0731 753700     707       mov  y+3, #0
0734 1202FF     708       lcall div32
0737            709   
0737            710       ; Add partial result to StoreMeasurements
0737 854034     711       mov  y+0, StoreMeasurements+0
073A 854135     712       mov  y+1, StoreMeasurements+1
073D 854236     713       mov  y+2, StoreMeasurements+2
0740 854337     714       mov  y+3, StoreMeasurements+3
0743 1201BD     715       lcall add32
0746 853040     716       mov  StoreMeasurements+0, x+0
0749 853141     717       mov  StoreMeasurements+1, x+1
074C 853242     718       mov  StoreMeasurements+2, x+2
074F 853343     719       mov  StoreMeasurements+3, x+3
0752            720   
0752            721       ; Read thermocouple on AIN4
0752 53E8F0     722       anl  ADCCON0, #0xF0
0755 43E804     723       orl  ADCCON0, #0x04
0758 120568     724       lcall Read_ADC
075B            725   
075B 8830       726       mov  x+0, R0
075D 8931       727       mov  x+1, R1
075F 753200     728       mov  x+2, #0
0762 753300     729       mov  x+3, #0
0765 7534FF     730            mov y+0, #low (40959 % 0x10000) 
0768 75359F     730            mov y+1, #high(40959 % 0x10000) 
076B 753600     730            mov y+2, #low (40959 / 0x10000) 
076E 753700     730            mov y+3, #high(40959 / 0x10000) 
0771 120272     731       lcall mul32
0774 853D34     732       mov  y+0, VAL_LM4040+0
0777 853E35     733       mov  y+1, VAL_LM4040+1
077A 753600     734       mov  y+2, #0
077D 753700     735       mov  y+3, #0
0780 1202FF     736       lcall div32
0783            737   
0783            738       ; Add partial result to StoreThermocouple
0783 854F34     739       mov  y+0, StoreThermocouple+0
0786 855035     740       mov  y+1, StoreThermocouple+1
0789 855136     741       mov  y+2, StoreThermocouple+2
078C 855237     742       mov  y+3, StoreThermocouple+3
078F 1201BD     743       lcall add32
0792 85304F     744       mov  StoreThermocouple+0, x+0
0795 853150     745       mov  StoreThermocouple+1, x+1
0798 853251     746       mov  StoreThermocouple+2, x+2
079B 853352     747       mov  StoreThermocouple+3, x+3
079E            748   
079E            749       ; Delay between samples
079E AA4A       750       mov R2, TimePerSample
07A0 1204BA     751       lcall waitms
07A3            752   
07A3            753       ; Decrement measurement counter
07A3 1546       754       dec MeasurementCounter+0
07A5 E546       755       mov a, MeasurementCounter+0
07A7 B4FF02     756       cjne a, #0xFF, CheckHigh
07AA 1547       757       dec MeasurementCounter+1
07AC            758   CheckHigh:
07AC E546       759       mov a, MeasurementCounter+0
07AE 4547       760       orl a, MeasurementCounter+1
07B0 6003       761       jz  DisplayValue
07B2 020919     762       ljmp EndForever
07B5            763   
07B5            764   ;----------------------------------------------------------------------
07B5            765   ; If enough measurements collected -> compute final temperature
07B5            766   ;----------------------------------------------------------------------
07B5            767   DisplayValue:
07B5 753400     768            mov y+0, #low (0 % 0x10000) 
07B8 753500     768            mov y+1, #high(0 % 0x10000) 
07BB 753600     768            mov y+2, #low (0 / 0x10000) 
07BE 753700     768            mov y+3, #high(0 / 0x10000) 
07C1            769       ; Combine for LM335 reading
07C1 854030     770       mov x+0, StoreMeasurements+0
07C4 854131     771       mov x+1, StoreMeasurements+1
07C7 854232     772       mov x+2, StoreMeasurements+2
07CA 854333     773       mov x+3, StoreMeasurements+3
07CD E548       774       mov a, SamplesPerDisplay+0
07CF F534       775       mov y+0, a
07D1 F546       776       mov MeasurementCounter+0, a
07D3 E549       777       mov a, SamplesPerDisplay+1
07D5 F535       778       mov y+1, a
07D7 F547       779       mov MeasurementCounter+1, a
07D9 1202FF     780       lcall div32
07DC            781   
07DC            782       ; Subtract 273.00 => Celsius reading
07DC 7534A4     783            mov y+0, #low (27300 % 0x10000) 
07DF 75356A     783            mov y+1, #high(27300 % 0x10000) 
07E2 753600     783            mov y+2, #low (27300 / 0x10000) 
07E5 753700     783            mov y+3, #high(27300 / 0x10000) 
07E8 1201DE     784       lcall sub32
07EB 853057     785       mov FinalLM335+0, x+0
07EE 853158     786       mov FinalLM335+1, x+1
07F1 853259     787       mov FinalLM335+2, x+2
07F4 85335A     788       mov FinalLM335+3, x+3
07F7            789   
07F7            790       ; Combine for thermocouple reading
07F7 753400     791            mov y+0, #low (0 % 0x10000) 
07FA 753500     791            mov y+1, #high(0 % 0x10000) 
07FD 753600     791            mov y+2, #low (0 / 0x10000) 
0800 753700     791            mov y+3, #high(0 / 0x10000) 
0803 854F30     792       mov x+0, StoreThermocouple+0
0806 855031     793       mov x+1, StoreThermocouple+1
0809 855132     794       mov x+2, StoreThermocouple+2
080C 855233     795       mov x+3, StoreThermocouple+3
080F E548       796       mov a, SamplesPerDisplay+0
0811 F534       797       mov y+0, a
0813 E549       798       mov a, SamplesPerDisplay+1
0815 F535       799       mov y+1, a
0817 1202FF     800       lcall div32
081A            801   
081A            802       ; Add thermocouple to LM335 reading => final in x
081A 753400     803            mov y+0, #low (0 % 0x10000) 
081D 753500     803            mov y+1, #high(0 % 0x10000) 
0820 753600     803            mov y+2, #low (0 / 0x10000) 
0823 753700     803            mov y+3, #high(0 / 0x10000) 
0826 855734     804       mov y+0, FinalLM335+0
0829 855835     805       mov y+1, FinalLM335+1
082C 855936     806       mov y+2, FinalLM335+2
082F 855A37     807       mov y+3, FinalLM335+3
0832 1201BD     808       lcall add32
0835            809   
0835 85305B     810       mov FinalTemp+0, x+0
0838 85315C     811       mov FinalTemp+1, x+1
083B 85325D     812       mov FinalTemp+2, x+2
083E 85335E     813       mov FinalTemp+3, x+3
0841            814   
0841            815       ; --------------------------------------------------------
0841            816       ; Compare final temperature with soak/reflow setpoints
0841            817       ; --------------------------------------------------------
0841 C200       818       clr mf
0843 753464     819            mov y+0, #low (100 % 0x10000) 
0846 753500     819            mov y+1, #high(100 % 0x10000) 
0849 753600     819            mov y+2, #low (100 / 0x10000) 
084C 753700     819            mov y+3, #high(100 / 0x10000) 
084F 856430     820       mov x+0, temp_soak
0852 753100     821       mov x+1, #0
0855 753200     822       mov x+2, #0
0858 753300     823       mov x+3, #0
085B 120272     824       lcall mul32
085E 855B34     825       mov y+0, FinalTemp+0
0861 855C35     826       mov y+1, FinalTemp+1
0864 855D36     827       mov y+2, FinalTemp+2
0867 855E37     828       mov y+3, FinalTemp+3
086A 120268     829       lcall x_lteq_y ; mf = 1 if temp_soak<=FinalTemp
086D A200       830       mov c, mf
086F 9206       831       mov temp_state1, c
0871            832   
0871 C200       833       clr mf
0873 753464     834            mov y+0, #low (100 % 0x10000) 
0876 753500     834            mov y+1, #high(100 % 0x10000) 
0879 753600     834            mov y+2, #low (100 / 0x10000) 
087C 753700     834            mov y+3, #high(100 / 0x10000) 
087F 856630     835       mov x+0, temp_refl
0882 753100     836       mov x+1, #0
0885 753200     837       mov x+2, #0
0888 753300     838       mov x+3, #0
088B 120272     839       lcall mul32
088E 855B34     840       mov y+0, FinalTemp+0
0891 855C35     841       mov y+1, FinalTemp+1
0894 855D36     842       mov y+2, FinalTemp+2
0897 855E37     843       mov y+3, FinalTemp+3
089A 120268     844       lcall x_lteq_y ; mf = 1 if temp_refl<=FinalTemp
089D A200       845       mov c, mf
089F 9207       846       mov temp_state3, c
08A1            847   
08A1            848       ; Check error states
08A1 855B30     849       mov x+0, FinalTemp+0
08A4 855C31     850       mov x+1, FinalTemp+1
08A7 855D32     851       mov x+2, FinalTemp+2
08AA 855E33     852       mov x+3, FinalTemp+3
08AD            853   
08AD C200       854       clr mf
08AF 7534A8     855            mov y+0, #low (25000 % 0x10000) 
08B2 753561     855            mov y+1, #high(25000 % 0x10000) 
08B5 753600     855            mov y+2, #low (25000 / 0x10000) 
08B8 753700     855            mov y+3, #high(25000 / 0x10000) 
08BB 12025E     856       lcall x_gteq_y ; mf = 1 if FinalTemp<=250
08BE A200       857       mov c, mf
08C0 9204       858       mov err_tmp_150, c
08C2            859   
08C2 C200       860       clr mf
08C4 753488     861            mov y+0, #low (5000 % 0x10000) 
08C7 753513     861            mov y+1, #high(5000 % 0x10000) 
08CA 753600     861            mov y+2, #low (5000 / 0x10000) 
08CD 753700     861            mov y+3, #high(5000 / 0x10000) 
08D0 12025E     862       lcall x_gteq_y ; mf = 1 if FinalTemp>=50
08D3 A200       863       mov c, mf
08D5 9203       864       mov err_tmp, c
08D7            865   
08D7 C200       866       clr mf
08D9 7534B8     867            mov y+0, #low (3000 % 0x10000) 
08DC 75350B     867            mov y+1, #high(3000 % 0x10000) 
08DF 753600     867            mov y+2, #low (3000 / 0x10000) 
08E2 753700     867            mov y+3, #high(3000 / 0x10000) 
08E5 120268     868       lcall x_lteq_y ; mf = 1 if FinalTemp<=60
08E8 A200       869       mov c, mf
08EA 9208       870       mov temp_state5, c
08EC            871   
08EC            872   
08EC            873   
08EC            874       ; Convert FinalTemp => BCD => display
08EC 1200F8     875       lcall hex2bcd
08EF 120514     876       lcall Display_formated_BCD
08F2 120583     877       lcall SendBCD
08F5            878   
08F5            879       ; Reset accumulators
08F5 754000     880       mov StoreMeasurements+0, #0
08F8 754100     881       mov StoreMeasurements+1, #0
08FB 754200     882       mov StoreMeasurements+2, #0
08FE 754300     883       mov StoreMeasurements+3, #0
0901 754F00     884       mov StoreThermocouple+0, #0
0904 755000     885       mov StoreThermocouple+1, #0
0907 755100     886       mov StoreThermocouple+2, #0
090A 755200     887       mov StoreThermocouple+3, #0
090D 755700     888       mov FinalLM335+0, #0
0910 755801     889       mov FinalLM335+1, #1
0913 755902     890       mov FinalLM335+2, #2
0916 755A03     891       mov FinalLM335+3, #3
0919            892   
0919            893   EndForever:
0919            894       ; Always read the push buttons each pass
0919 1204C0     895       lcall LCD_PB
091C            896   
091C            897   
091C 753000     898       mov x+0, #0
091F 753100     899       mov x+1, #0
0922 753200     900       mov x+2, #0
0925 753300     901       mov x+3, #0
0928 0206F9     902       ljmp Forever
092B            903   
092B            904   END
