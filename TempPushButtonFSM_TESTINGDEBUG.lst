0000              1   ;----------------------------------------------------------------------
0000              2   ; 76E003 ADC test program (reflow oven controller + push buttons)
0000              3   ; Reads channel 7 on P1.1, pin 14
0000              4   ; This version uses the LM4040 voltage reference connected to pin 6 (P1.7/AIN0)
0000              5   ; Incorporates push-button control to set up times/temperatures and start FSM.
0000              6   ;----------------------------------------------------------------------
0000              7   
                  9   $LIST
0000             11   
0000             12   ;  N76E003 pinout:
0000             13   ;                               -------
0000             14   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             15   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             16   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             17   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             18   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             19   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             20   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             21   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             22   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             23   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             24   ;                               -------
0000             25   ;
0000             26   
0000             27   ;----------------------------------------------------------------------
0000             28   ; System/Timer/Constants
0000             29   ;----------------------------------------------------------------------
0000             30   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             31   BAUD              EQU 115200   ; Baud rate of UART in bps
0000             32   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             33   
0000             34   TIMER2_RATE       EQU 100      ; 100 Hz -> 10ms tick
0000             35   TIMER2_RELOAD     EQU ((65536-(CLK/(16*TIMER2_RATE))))
0000             36   
0000             37   TIMER0_RATE          EQU 2250
0000             38   TIMER0_RELOAD        EQU (0x10000-(CLK/TIMER0_RATE))
0000             39   
0000             40   SAMPLES_PER_DISPLAY EQU 150
0000             41   REFRESHES_PER_SECOND EQU 15
0000             42   
0000             43   ORG 0x0000
0000 020992      44       ljmp main
0003             45   
0003             46   ; Timer/Counter 0 overflow interrupt vector
000B             47   org 0x000B
000B 0203A8      48            ljmp Timer0_ISR
000E             49   
000E             50   ; Timer/Counter 2 overflow interrupt vector
002B             51   org 0x002B
002B 0203DB      52       ljmp Timer2_ISR
002E             53   
002E             54   ;----------------------------------------------------------------------
002E             55   ; Hardware Pin Definitions
002E             56   ;----------------------------------------------------------------------
002E             57   
002E             58   ; PUSH BUTTONS (single-pin read approach)
002E             59   PB_INPUT_PIN   EQU P1.5  ; The single pin used to read all 5 PBs
002E             60   MUX_CONTROL_0  EQU P1.3  
002E             61   MUX_CONTROL_1  EQU P0.0  
002E             62   MUX_CONTROL_2  EQU P0.1  
002E             63   MUX_CONTROL_3  EQU P0.2  
002E             64   MUX_CONTROL_4  EQU P0.3  
002E             65   SOUND_OUT      EQU P3.0
002E             66   
002E             67   ; LCD assignments
002E             68   LCD_RS  equ P1.3
002E             69   LCD_E   equ P1.4
002E             70   LCD_D4  equ P0.0
002E             71   LCD_D5  equ P0.1
002E             72   LCD_D6  equ P0.2
002E             73   LCD_D7  equ P0.3
002E             74   SSR_BOX equ P0.4
002E             75   
002E             76   ; Strings for LCD
002E 43757272    77   test_message:     db 'Current Temp.:', 0
     656E7420
     54656D70
     2E3A00
003D 4465672E    78   value_message:    db 'Deg. C', 0
     204300
0044             79   
0044 54656D70    80   temp_soak_string: db 'Temp Soak:    ', 0
     20536F61
     6B3A2020
     202000
0053 54696D65    81   time_soak_string: db 'Time Soak:    ', 0
     20536F61
     6B3A2020
     202000
0062 54656D70    82   temp_refl_string: db 'Temp Reflow: ', 0
     20526566
     6C6F773A
     2000
0070 54696D65    83   time_refl_string: db 'Time Reflow: ', 0
     20526566
     6C6F773A
     2000
007E             84   
007E 204300      85   degree_label: db ' C', 0
0081 207300      86   seconds_label: db ' s', 0
0084             87   
0084             88   
0084             89   cseg
0084             90   
                 92   	$LIST
0138             94   
0138             95   ;----------------------------------------------------------------------
0138             96   ; 32-bit math placeholders
0138             97   ;----------------------------------------------------------------------
0030             98   DSEG at 30H
0030             99   x:   ds 4
0034            100   y:   ds 4
0038            101   bcd: ds 5
003D            102   VAL_LM4040: ds 2
003F            103   
003F            104   ; Variables
003F            105   state:              ds 1
0040            106   StoreMeasurements:  ds 4
0044            107   Store:          ds 2
0046            108   MeasurementCounter: ds 2
0048            109   SamplesPerDisplay:  ds 2
004A            110   TimePerSample:      ds 1
004B            111   LastMeasurement:    ds 4
004F            112   StoreThermocouple:  ds 4
0053            113   CurrentTemp:        ds 4
0057            114   FinalLM335:         ds 4
005B            115   FinalTemp:          ds 4
005F            116   selected_state:          ds 1
0060            117   
0060            118   save_x:             ds 4
0064            119   
0064            120   Count1ms:      ds 2
0066            121   pwm_counter:   ds 1
0067            122   pwm:           ds 1
0068            123   
0068            124   debounce_count_0 :ds 1
0069            125   debounce_count_1 :ds 1
006A            126   debounce_count_2 :ds 1
006B            127   debounce_count_3 :ds 1
006C            128   debounce_count_4 :ds 1
006D            129   
006D            130   ; Oven settings
006D            131   temp_soak: ds 1  ; For state 1
006E            132   time_soak: ds 1  ; For state 2
006F            133   temp_refl: ds 1  ; For state 3
0070            134   time_refl: ds 1  ; For state 4
0071            135   
0071            136   seconds: ds 1
0072            137   state_sec: ds 1
0073            138   
0073            139   ;----------------------------------------------------------------------
0073            140   ; Bit variables (BSEG)
0073            141   ;----------------------------------------------------------------------
0000            142   BSEG
0000            143   mf:            dbit 1
0001            144   m_flag:        dbit 1
0002            145   s_flag:        dbit 1
0003            146   err_tmp:       dbit 1
0004            147   err_tmp_150:   dbit 1
0005            148   display_flag:  dbit 1
0006            149   
0006            150   inc_lock:      dbit 1
0007            151   
0007            152   start:         dbit 1  ; Start the FSM
0008            153   temp_state1:   dbit 1
0009            154   temp_state3:   dbit 1
000A            155   temp_state5:   dbit 1
000B            156   
000B            157   debug_bit:     dbit 1 ;Set to true to check which lines of code actually execute
000C            158   debug_bit1:    dbit 1
000D            159   kill_flag:      dbit 1 ; kill switch
000E            160   
000E            161   ; For push buttons
000E            162   PB0: dbit 1  ; Start/Pause
000F            163   PB1: dbit 1  ; Toggle selected parameter
0010            164   PB2: dbit 1  ; Increment
0011            165   PB3: dbit 1  ; Decrement
0012            166   PB4: dbit 1  ; Unused or extra
0013            167   
0013            168   PB0_db: dbit 1
0014            169   PB1_db: dbit 1
0015            170   PB2_db: dbit 1
0016            171   PB3_db: dbit 1
0017            172   PB4_db: dbit 1
0018            173   
0018            174   sound_flag: dbit 1
0019            175   
0019            176   ;SETATS
0019            177   
0019            178   ; We include math32 at the end of initialization
                546   $LIST
                180   $LIST
03A8            182   
03A8            183   ;----------------------------------------------------------------------
03A8            184   ; Timer2 Initialization & ISR
03A8            185   ;----------------------------------------------------------------------
03A8            186   
03A8            187   
03A8            188   
03A8            189   
03A8            190   
03A8            191   
03A8            192   Timer0_ISR:
03A8            193            ;clr TF0  ; According to the data sheet this is done for us already.
03A8            194            ; Timer 0 doesn't have 16-bit auto-reload, so
03A8 C28C       195            clr TR0
03AA 758CE3     196            mov TH0, #high(TIMER0_RELOAD) ;TH0 and TL0 are only 8 bits, so we need to load each half individually
03AD 758A2F     197            mov TL0, #low(TIMER0_RELOAD) ; For 0xF830 for example, #high gives 0xF8, #low gives #0x30
03B0 D28C       198            setb TR0 ; Start timer 0
03B2 201804     199            jb sound_flag, Timer0_ISR_Sound
03B5 C2B0       200            clr SOUND_OUT
03B7 8004       201            sjmp Timer0_ISR_Done
03B9            202   Timer0_ISR_Sound:
03B9 B2B0       203            cpl SOUND_OUT
03BB 8000       204            sjmp Timer0_ISR_Done
03BD            205   Timer0_ISR_Done:
03BD 32         206            reti
03BE            207   
03BE            208   
03BE            209   Timer2_Init:
03BE 75C800     210       mov T2CON, #0       ; Stop timer, mode = auto-reload
03C1 75CDD7     211       mov TH2, #high(TIMER2_RELOAD)
03C4 75CC79     212       mov TL2, #low(TIMER2_RELOAD)
03C7 43C9A0     213       orl T2MOD, #0b1010_0000    ; Enable auto-reload
03CA 75CBD7     214       mov RCMP2H, #high(TIMER2_RELOAD)
03CD 75CA79     215       mov RCMP2L, #low(TIMER2_RELOAD)
03D0 E4         216       clr  a
03D1 F564       217       mov  Count1ms+0, a
03D3 F565       218       mov  Count1ms+1, a
03D5 439B80     219       orl  EIE, #0x80     ; Enable timer2 interrupt (ET2=1)
03D8 D2CA       220       setb TR2            ; Start Timer2
03DA 22         221       ret
03DB            222   
03DB            223   Timer2_ISR:
03DB C2CF       224       clr TF2 ; Must clear TF2 manually on N76
03DD C0E0       225       push acc
03DF C0D0       226       push psw
03E1 853060     227       mov save_x+0, x+0
03E4 853161     228       mov save_x+1, x+1
03E7 853262     229       mov save_x+2, x+2
03EA 853363     230       mov save_x+3, x+3
03ED            231   
03ED            232       ;---------------------------------
03ED            233       ; PWM for SSR control
03ED            234       ;---------------------------------
03ED 0566       235       inc pwm_counter ;Every 10ms, pwm_counter is incremented
03EF C3         236       clr c
03F0 E567       237       mov a, pwm
03F2 9566       238       subb a, pwm_counter ; if pwm_counter <= pwm, c=1, so if pwm=20 for example, if 210ms has passed, c = 0, and the SSR box is always on
03F4            239       ;cpl c
03F4 9284       240       mov SSR_BOX, c
03F6            241       
03F6            242   CheckButton0:
03F6 200E0D     243       jb PB0, CheckButton1 ;Skip to CheckPWM if a button is not pushed
03F9 0568       244       inc debounce_count_0
03FB E568       245       mov a, debounce_count_0
03FD B40F06     246       cjne a, #15, CheckButton1
0400 C213       247            clr PB0_db
0402 756800     248       mov debounce_count_0, #0
0405 E4         249       clr a
0406            250   
0406            251   CheckButton1:
0406 200F0D     252       jb PB1, CheckButton2 ;Skip to CheckPWM if a button is not pushed
0409 0569       253       inc debounce_count_1
040B E569       254       mov a, debounce_count_1
040D B40F06     255       cjne a, #15, CheckButton2
0410 C214       256            clr PB1_db
0412 756900     257       mov debounce_count_1, #0
0415 E4         258       clr a
0416            259   
0416            260   CheckButton2:
0416 20100D     261       jb PB2, CheckButton3 ;Skip to CheckPWM if a button is not pushed
0419 056A       262       inc debounce_count_2
041B E56A       263       mov a, debounce_count_2
041D B40F06     264       cjne a, #15, CheckButton3
0420 C215       265            clr PB2_db
0422 756A00     266       mov debounce_count_2, #0
0425 E4         267       clr a
0426            268   
0426            269   CheckButton3:
0426 20110D     270       jb PB3, CheckButton4 ;Skip to CheckPWM if a button is not pushed
0429 056B       271       inc debounce_count_3
042B E56B       272       mov a, debounce_count_3
042D B40F06     273       cjne a, #15, CheckButton4
0430 C216       274            clr PB3_db
0432 756B00     275       mov debounce_count_3, #0
0435 E4         276       clr a
0436            277   
0436            278   CheckButton4:
0436 20120D     279       jb PB4, CheckPWM ;Skip to CheckPWM if a button is not pushed
0439 056C       280       inc debounce_count_4
043B E56C       281       mov a, debounce_count_4
043D B40F06     282       cjne a, #15, CheckPWM
0440 C217       283            clr PB4_db
0442 756C00     284       mov debounce_count_4, #0
0445 E4         285       clr a
0446            286   
0446            287   
0446            288   CheckPWM:
0446 E566       289       mov a, pwm_counter
0448 B4641F     290       cjne a, #100, State_0 ; If 1 second has not passed, skip to State_0
044B 756600     291       mov pwm_counter, #0 ; Reset pwm_counter
044E E53F       292       mov a, state
0450 B40003     293       cjne a, #0, SecondsLogic
0453 02046A     294       ljmp State_0
0456            295   
0456            296   
0456            297   SecondsLogic:
0456 0571       298       inc seconds ; Increment seconds
0458 0572       299       inc state_sec ; Will only increment in states 2 and 4, gets reset to 0 in all other states otherrwise
045A E4         300       clr a
045B E53F       301       mov a, state
045D B4010A     302       cjne a, #1, State_0
0460 E571       303       mov a, seconds
0462 B43C05     304       cjne a, #60, State_0 ;If exactly 60 seconds has not passed, skip to State_0, otherwise set m_flag to indicate a minute has passed
0465 D201       305       setb m_flag
0467 02046A     306       ljmp State_0
046A            307   
046A            308   
046A            309   State_0:
046A E53F       310       mov a, state
046C B40010     311            cjne a, #0, State_1
046F E4         312       clr a
0470 757200     313       mov state_sec, #0
0473 756700     314            mov pwm, #0
0476 30074C     315            jnb start, jumpy 
0479 753F01     316            mov state, #1
047C 020554     317            ljmp Display_1
047F            318            
047F            319   State_1:
047F 200D46     320       jb kill_flag, jumpyError
0482 E53F       321            mov a, state
0484 B40122     322            cjne a, #1, State_2
0487 757200     323            mov state_sec, #0
048A 756764     324            mov pwm, #100                                   ; set pwm for relfow oven to 100%
048D 20010F     325            jb m_flag, Cond_check
0490 D20C       326       setb debug_bit1
0492 300830     327            jnb temp_state1, jumpy          ; mf = 1 if oven temp <= set temp, jump out of ISR. mf = 0 if oven temp > set temp, thus move onto next state                   
0495 E4         328            clr a                                           
0496 753F02     329            mov state, #2
0499 757200     330       mov state_sec, #0
049C 0204A9     331            ljmp State_2
049F            332   
049F            333   Cond_check: ; cjne is not bit-addressable, therefore we must move bits into byte registers (i.e. accumulator and register b)
049F D20B       334            setb debug_bit
04A1 300327     335       jnb err_tmp, jumpyErrorKill
04A4 C201       336       clr m_flag
04A6 0204C5     337            ljmp jumpy
04A9            338   
04A9            339   
04A9            340   State_2: ;transition to state three if more than 60 seconds have passed
04A9 200D1C     341       jb kill_flag, jumpyError
04AC E53F       342            mov a, state
04AE B4021D     343            cjne a, #2, State_3
04B1 756714     344            mov pwm, #20
04B4 200414     345            jb err_tmp_150, jumpyErrorKill
04B7 E4         346       clr a        
04B8            347   
04B8            348       
04B8 E572       349       mov a, state_sec
04BA C3         350       clr c
04BB 956E       351       subb a, time_soak ; If state_sec - time_soak is negative (so not enough time has passed), then c = 1, 
04BD 4006       352       jc jumpy
04BF 753F03     353            mov state, #3
04C2 757200     354       mov state_sec, #0
04C5            355   
04C5            356   jumpy:
04C5 020549     357       ljmp Display_0
04C8            358   jumpyError:
04C8 020526     359       ljmp State_error
04CB            360   jumpyErrorkill:
04CB 020520     361       ljmp State_error_kill
04CE            362   
04CE            363   
04CE            364   State_3: 
04CE 200D55     365       jb kill_flag, State_error
04D1 E53F       366            mov a, state
04D3 B40313     367            cjne a, #3, State_4 ; check if state = 3, if not, move to state_4
04D6 756764     368            mov pwm, #100 ; set pwm to 100%
04D9 757200     369       mov state_sec, #0
04DC 200441     370            jb err_tmp_150, State_error_kill
04DF            371            ;mov c, temp_state3
04DF            372            ;clr a                                                          ; clear the accumulator
04DF            373            ;mov acc.0, c
04DF            374            ;clr c                                                          ; clear the carry bit
04DF            375            ;cjne a, #0, Timer2_ISR_done ;
04DF 3009E3     376       jnb temp_state3, jumpy
04E2 E4         377            clr a
04E3 757200     378       mov state_sec, #0
04E6 753F04     379            mov state, #4
04E9            380   
04E9            381   State_4:
04E9 200D3A     382       jb kill_flag, State_error
04EC E53F       383            mov a, state
04EE B40413     384            cjne a, #4, State_5
04F1 756714     385            mov pwm, #20
04F4 200429     386            jb err_tmp_150, State_error_kill
04F7 E4         387       clr a
04F8 E572       388       mov a, state_sec
04FA 9570       389       subb a, time_refl
04FC 40C7       390       jc jumpy    
04FE 753F05     391            mov state, #5
0501 757200     392       mov state_sec, #0
0504            393   
0504            394   State_5:
0504 200D1F     395       jb kill_flag, State_error
0507 E53F       396            mov a, state
0509 B405B9     397            cjne a, #5, jumpy
050C 756700     398            mov pwm, #0
050F 757200     399       mov state_sec, #0
0512 20040B     400       jb err_tmp_150, State_error_kill
0515 300AAD     401       jnb temp_state5, jumpy
0518 753F00     402            mov state, #0
051B 757200     403       mov state_sec, #0
051E 800C       404       sjmp State_end
0520            405   
0520            406   
0520            407   State_error_kill:
0520 7400       408            mov a, #0
0522 F53F       409            mov state, a
0524 8006       410       sjmp State_end
0526            411       
0526            412   State_error:
0526 7400       413            mov a, #0
0528 F53F       414            mov state, a
052A 801D       415       sjmp Display_0
052C            416   
052C            417   State_end:
052C C3         418       clr c
052D A207       419       mov c, start
052F E4         420       clr a
0530 92E0       421       mov acc.0, c
0532 F4         422       cpl a                                ; set the flag to 1, indicating that the FSM should begin
0533 A2E0       423       mov c, acc.0
0535 9207       424       mov start, c
0537 E4         425       clr a
0538 C3         426       clr c
0539 A20D       427       mov c, kill_flag
053B 92E0       428       mov acc.0, c
053D F4         429       cpl a                    ; compliment kill
053E A2E0       430       mov c, acc.0 
0540 920D       431       mov kill_flag, c
0542 C201       432       clr m_flag
0544 757100     433       mov seconds, #0
0547 8000       434       sjmp Display_0
0549            435   
0549            436            ; probably should put branch for warning message here
0549            437   
0549            438   ; Second FSM for displaying values for each state
0549            439   
0549            440   Display_0: ; Displays state 0 - Oven On
0549 020554     441       ljmp Display_1 ;Temporary, test until we set up Display_0
054C E55F       442       mov a, selected_state
054E B40003     443       cjne a, #0, Display_1
0551 0206E3     444       ljmp Timer2_ISR_done
0554            445   
0554            446   Display_1: ; Displays state 1 - Soak Temp.
0554 E55F       447       mov a, selected_state
0556 B40161     448       cjne a, #1, Display_2
0559 30055B     449       jnb display_flag, jumpyEnd
055C C0E0       450            push acc
055E 7401       450            mov a, #1
0560 14         450            dec a
0561 12011D     450            lcall ?Set_Cursor_1 ; Select column and row
0564 D0E0       450            pop acc
0566 C083       451            push dph
0568 C082       451            push dpl
056A C0E0       451            push acc
056C 900044     451            mov dptr, #temp_soak_string
056F 120110     451            lcall ?Send_Constant_String
0572 D0E0       451            pop acc
0574 D082       451            pop dpl
0576 D083       451            pop dph
0578 C205       452       clr display_flag
057A 753000     453            mov x+0, #low (0 % 0x10000) 
057D 753100     453            mov x+1, #high(0 % 0x10000) 
0580 753200     453            mov x+2, #low (0 / 0x10000) 
0583 753300     453            mov x+3, #high(0 / 0x10000) 
0586 856D30     454       mov x+0, temp_soak
0589 120138     455       lcall hex2bcd
058C C0E0       456            push acc
058E 7401       456            mov a, #1
0590 14         456            dec a
0591 12011B     456            lcall ?Set_Cursor_2 ; Select column and row
0594 D0E0       456            pop acc
0596 C000       457            push ar0
0598 A839       457            mov r0, bcd+1
059A 120122     457            lcall ?Display_BCD
059D D000       457            pop ar0
059F C000       458            push ar0
05A1 A838       458            mov r0, bcd+0
05A3 120122     458            lcall ?Display_BCD
05A6 D000       458            pop ar0
05A8 753000     459            mov x+0, #low (0 % 0x10000) 
05AB 753100     459            mov x+1, #high(0 % 0x10000) 
05AE 753200     459            mov x+2, #low (0 / 0x10000) 
05B1 753300     459            mov x+3, #high(0 / 0x10000)  
05B4 0206E3     460       ljmp Timer2_ISR_done
05B7            461   
05B7            462   jumpyEnd:
05B7 0206E3     463       ljmp Timer2_ISR_done
05BA            464   
05BA            465   Display_2: ; Displays state 2 - Soak Time
05BA E55F       466       mov a, selected_state
05BC B4025E     467       cjne a, #2, Display_3
05BF 3005F5     468       jnb display_flag, jumpyEnd
05C2 C0E0       469            push acc
05C4 7401       469            mov a, #1
05C6 14         469            dec a
05C7 12011D     469            lcall ?Set_Cursor_1 ; Select column and row
05CA D0E0       469            pop acc
05CC C083       470            push dph
05CE C082       470            push dpl
05D0 C0E0       470            push acc
05D2 900053     470            mov dptr, #time_soak_string
05D5 120110     470            lcall ?Send_Constant_String
05D8 D0E0       470            pop acc
05DA D082       470            pop dpl
05DC D083       470            pop dph
05DE C205       471       clr display_flag
05E0 753000     472            mov x+0, #low (0 % 0x10000) 
05E3 753100     472            mov x+1, #high(0 % 0x10000) 
05E6 753200     472            mov x+2, #low (0 / 0x10000) 
05E9 753300     472            mov x+3, #high(0 / 0x10000) 
05EC 856E30     473       mov x+0, time_soak
05EF 120138     474       lcall hex2bcd
05F2 C0E0       475            push acc
05F4 7401       475            mov a, #1
05F6 14         475            dec a
05F7 12011B     475            lcall ?Set_Cursor_2 ; Select column and row
05FA D0E0       475            pop acc
05FC C000       476            push ar0
05FE A839       476            mov r0, bcd+1
0600 120122     476            lcall ?Display_BCD
0603 D000       476            pop ar0            ; x is 8 bits, we represent in hex as 0xFF, therefore FF is displayed
0605 C000       477            push ar0
0607 A838       477            mov r0, bcd+0
0609 120122     477            lcall ?Display_BCD
060C D000       477            pop ar0
060E 753000     478            mov x+0, #low (0 % 0x10000) 
0611 753100     478            mov x+1, #high(0 % 0x10000) 
0614 753200     478            mov x+2, #low (0 / 0x10000) 
0617 753300     478            mov x+3, #high(0 / 0x10000)  
061A 0206E3     479       ljmp Timer2_ISR_done
061D            480   
061D            481   
061D            482   
061D            483   Display_3: ; Displays state 3 - Reflow Temp.
061D E55F       484       mov a, selected_state
061F B4035E     485       cjne a, #3, Display_4
0622 300592     486       jnb display_flag, jumpyEnd
0625 C0E0       487            push acc
0627 7401       487            mov a, #1
0629 14         487            dec a
062A 12011D     487            lcall ?Set_Cursor_1 ; Select column and row
062D D0E0       487            pop acc
062F C083       488            push dph
0631 C082       488            push dpl
0633 C0E0       488            push acc
0635 900062     488            mov dptr, #temp_refl_string
0638 120110     488            lcall ?Send_Constant_String
063B D0E0       488            pop acc
063D D082       488            pop dpl
063F D083       488            pop dph
0641 C205       489       clr display_flag
0643 753000     490            mov x+0, #low (0 % 0x10000) 
0646 753100     490            mov x+1, #high(0 % 0x10000) 
0649 753200     490            mov x+2, #low (0 / 0x10000) 
064C 753300     490            mov x+3, #high(0 / 0x10000) 
064F 856F30     491       mov x+0, temp_refl
0652 120138     492       lcall hex2bcd
0655 C0E0       493            push acc
0657 7401       493            mov a, #1
0659 14         493            dec a
065A 12011B     493            lcall ?Set_Cursor_2 ; Select column and row
065D D0E0       493            pop acc
065F C000       494            push ar0
0661 A839       494            mov r0, bcd+1
0663 120122     494            lcall ?Display_BCD
0666 D000       494            pop ar0
0668 C000       495            push ar0
066A A838       495            mov r0, bcd+0
066C 120122     495            lcall ?Display_BCD
066F D000       495            pop ar0
0671 753000     496            mov x+0, #low (0 % 0x10000) 
0674 753100     496            mov x+1, #high(0 % 0x10000) 
0677 753200     496            mov x+2, #low (0 / 0x10000) 
067A 753300     496            mov x+3, #high(0 / 0x10000)  
067D 0206E3     497       ljmp Timer2_ISR_done
0680            498       
0680            499   
0680            500   Display_4: ; Displays state 4 - Reflow Time
0680 E55F       501       mov a, selected_state
0682 B4045E     502       cjne a, #4, Timer2_ISR_Done
0685 30055B     503       jnb display_flag, Timer2_ISR_done
0688 C0E0       504            push acc
068A 7401       504            mov a, #1
068C 14         504            dec a
068D 12011D     504            lcall ?Set_Cursor_1 ; Select column and row
0690 D0E0       504            pop acc
0692 C083       505            push dph
0694 C082       505            push dpl
0696 C0E0       505            push acc
0698 900070     505            mov dptr, #time_refl_string
069B 120110     505            lcall ?Send_Constant_String
069E D0E0       505            pop acc
06A0 D082       505            pop dpl
06A2 D083       505            pop dph
06A4 C205       506       clr display_flag
06A6 753000     507            mov x+0, #low (0 % 0x10000) 
06A9 753100     507            mov x+1, #high(0 % 0x10000) 
06AC 753200     507            mov x+2, #low (0 / 0x10000) 
06AF 753300     507            mov x+3, #high(0 / 0x10000) 
06B2 857030     508       mov x+0, time_refl
06B5 120138     509       lcall hex2bcd
06B8 C0E0       510            push acc
06BA 7401       510            mov a, #1
06BC 14         510            dec a
06BD 12011B     510            lcall ?Set_Cursor_2 ; Select column and row
06C0 D0E0       510            pop acc
06C2 C000       511            push ar0
06C4 A839       511            mov r0, bcd+1
06C6 120122     511            lcall ?Display_BCD
06C9 D000       511            pop ar0            ; x is 8 bits, we represent in hex as 0xFF, therefore FF is displayed
06CB C000       512            push ar0
06CD A838       512            mov r0, bcd+0
06CF 120122     512            lcall ?Display_BCD
06D2 D000       512            pop ar0
06D4 753000     513            mov x+0, #low (0 % 0x10000) 
06D7 753100     513            mov x+1, #high(0 % 0x10000) 
06DA 753200     513            mov x+2, #low (0 / 0x10000) 
06DD 753300     513            mov x+3, #high(0 / 0x10000)                
06E0 0206E3     514       ljmp Timer2_ISR_done
06E3            515       
06E3            516   
06E3            517   Timer2_ISR_done:
06E3 D0D0       518       pop psw
06E5 D0E0       519       pop acc
06E7 856030     520       mov x+0, save_x+0 
06EA 856131     521       mov x+1, save_x+1
06ED 856232     522       mov x+2, save_x+2
06F0 856333     523       mov x+3, save_x+3
06F3 32         524       reti
06F4            525   
06F4            526   ;----------------------------------------------------------------------
06F4            527   ; Initialization
06F4            528   ;----------------------------------------------------------------------
06F4            529   Init_All:
06F4            530       ; Configure all the pins for bidirectional I/O
06F4 75AC00     531       mov P3M1, #0x00
06F7 75AD00     532       mov P3M2, #0x00
06FA 75B300     533       mov P1M1, #0x00
06FD 75B400     534       mov P1M2, #0x00
0700 75B100     535       mov P0M1, #0x00
0703 75B200     536       mov P0M2, #0x00
0706            537   
0706 1203BE     538       lcall Timer2_Init
0709            539   
0709            540       ; Timer1 for UART
0709 438E10     541       orl  CKCON, #0x10     ; Timer1 uses system clock
070C 438780     542       orl  PCON,  #0x80     ; SMOD=1 -> double baud
070F 759852     543       mov  SCON,  #0x52     ; UART mode 1, REN=1
0712 53C4DF     544       anl  T3CON, #0b11011111
0715 53890F     545       anl  TMOD,  #0x0F
0718 438920     546       orl  TMOD,  #0x20     ; Timer1 Mode2 (8-bit auto-reload)
071B 758DF7     547       mov  TH1, #TIMER1_RELOAD
071E D28E       548       setb TR1
0720            549   
0720            550       ; Timer0 for waitms
0720 C28C       551       clr TR0
0722 438E08     552       orl CKCON, #0x08
0725 5389F0     553       anl TMOD,  #0xF0
0728 438901     554       orl TMOD,  #0x01      ; 16-bit mode
072B 758CE3     555       mov TH0, #high(TIMER0_RELOAD)
072E 758A2F     556       mov TL0, #low(TIMER0_RELOAD)
0731 D2A9       557       setb ET0 ; Enable timer 0  interrupt
0733 D28C       558       setb TR0 ; Start timer 0
0735            559       ; ADC pins: P1.1 (AIN7), P1.7 (AIN0)
0735 43B382     560       orl P1M1, #0b10000010 ; Set P1.1 & P1.7 as input
0738 53B47D     561       anl P1M2, #0b01111101
073B            562   
073B            563       ; Initialize ADC
073B 53E8F0     564       anl ADCCON0, #0xF0
073E 43E807     565       orl ADCCON0, #0x07    ; default to channel 7
0741 75F600     566       mov AINDIDS, #0x00    ; disable all digital inputs
0744 43F681     567       orl AINDIDS, #0b10000001 ; activate AIN0 and AIN7
0747 43E101     568       orl ADCCON1, #0x01    ; enable ADC
074A 22         569       ret
074B            570   
074B            571   ;----------------------------------------------------------------------
074B            572   ; Delay Routines
074B            573   ;----------------------------------------------------------------------
074B            574   wait_1ms:
074B C28C       575       clr TR0
074D C28D       576       clr TF0
074F 758CE3     577       mov TH0, #high(TIMER0_RELOAD)
0752 758A2F     578       mov TL0, #low(TIMER0_RELOAD)
0755 D28C       579       setb TR0
0757 308DFD     580       jnb TF0, $
075A 22         581       ret
075B            582   
075B            583   ; Wait R2 milliseconds
075B            584   waitms:
075B 12074B     585       lcall wait_1ms
075E DAFB       586       djnz R2, waitms
0760 22         587       ret
0761            588   
0761            589   ;----------------------------------------------------------------------
0761            590   ; LCD_PB: Read the 5 push buttons into PB0..PB4 bits
0761            591   ;----------------------------------------------------------------------
0761            592   LCD_PB:
0761            593       ; Default all PB bits to 1 (released)
0761 D20E       594       setb PB0 
0763 D20F       595       setb PB1
0765 D210       596       setb PB2
0767 D211       597       setb PB3
0769 D212       598       setb PB4
076B            599       ; The input pin is idle-high (pull-up)
076B D295       600       setb PB_INPUT_PIN
076D            601   
076D            602       ; Set MUX lines to 0 first
076D C293       603       clr MUX_CONTROL_0
076F C280       604       clr MUX_CONTROL_1
0771 C281       605       clr MUX_CONTROL_2
0773 C282       606       clr MUX_CONTROL_3
0775 C283       607       clr MUX_CONTROL_4
0777            608   
0777            609       ;---------------------------------
0777            610       ; Debouncing
0777            611       ;---------------------------------
0777            612   
0777            613       ; Now set all MUX lines = 1 to read them individually
0777 D293       614       setb MUX_CONTROL_0
0779 D280       615       setb MUX_CONTROL_1
077B D281       616       setb MUX_CONTROL_2
077D D282       617       setb MUX_CONTROL_3
077F D283       618       setb MUX_CONTROL_4
0781            619   
0781            620       ; Check PB4
0781 C283       621       clr MUX_CONTROL_4
0783 A295       622       mov c, PB_INPUT_PIN
0785 9212       623       mov PB4, c
0787 D283       624       setb MUX_CONTROL_4
0789            625   
0789            626       ; Check PB3
0789 C282       627       clr MUX_CONTROL_3
078B A295       628       mov c, PB_INPUT_PIN
078D 9211       629       mov PB3, c
078F D282       630       setb MUX_CONTROL_3
0791            631   
0791            632       ; Check PB2
0791 C281       633       clr MUX_CONTROL_2
0793 A295       634       mov c, PB_INPUT_PIN
0795 9210       635       mov PB2, c
0797 D281       636       setb MUX_CONTROL_2
0799            637   
0799            638       ; Check PB1
0799 C280       639       clr MUX_CONTROL_1
079B A295       640       mov c, PB_INPUT_PIN
079D 920F       641       mov PB1, c
079F D280       642       setb MUX_CONTROL_1
07A1            643   
07A1            644       ; Check PB0
07A1 C293       645       clr MUX_CONTROL_0
07A3 A295       646       mov c, PB_INPUT_PIN
07A5 920E       647       mov PB0, c
07A7 D293       648       setb MUX_CONTROL_0
07A9            649   
07A9            650   
07A9            651   LCD_PB_Done:
07A9 D293       652       setb LCD_RS
07AB D294       653       setb LCD_E
07AD 22         654       ret
07AE            655   
07AE            656   ;----------------------------------------------------------------------
07AE            657   ; Display_formated_BCD: Display the result with decimal
07AE            658   ;----------------------------------------------------------------------
07AE            659   Display_formated_BCD:
07AE C0E0       660            push acc
07B0 7408       660            mov a, #8
07B2 14         660            dec a
07B3 12011B     660            lcall ?Set_Cursor_2 ; Select column and row
07B6 D0E0       660            pop acc
07B8 C000       661            push ar0
07BA A83A       661            mov r0, bcd+2
07BC 120122     661            lcall ?Display_BCD
07BF D000       661            pop ar0
07C1 C000       662            push ar0
07C3 A839       662            mov r0, bcd+1
07C5 120122     662            lcall ?Display_BCD
07C8 D000       662            pop ar0
07CA C0E0       663            push acc
07CC 742E       663            mov a, #'.'
07CE 1200D3     663            lcall ?WriteData
07D1 D0E0       663            pop acc
07D3 C000       664            push ar0
07D5 A838       664            mov r0, bcd+0
07D7 120122     664            lcall ?Display_BCD
07DA D000       664            pop ar0
07DC C0E0       665            push acc
07DE 74DF       665            mov a, #0xDF
07E0 1200D3     665            lcall ?WriteData
07E3 D0E0       665            pop acc    ; Degree symbol
07E5 C0E0       666            push acc
07E7 7443       666            mov a, #'C'
07E9 1200D3     666            lcall ?WriteData
07EC D0E0       666            pop acc
07EE C0E0       667            push acc
07F0 7408       667            mov a, #8
07F2 14         667            dec a
07F3 12011B     667            lcall ?Set_Cursor_2 ; Select column and row
07F6 D0E0       667            pop acc
07F8 C0E0       668            push acc
07FA 7420       668            mov a, #' '
07FC 1200D3     668            lcall ?WriteData
07FF D0E0       668            pop acc
0801 22         669       ret
0802            670   
0802            671   ;----------------------------------------------------------------------
0802            672   ; Read_ADC: reads current ADC channel into R0:R1 (12-bit)
0802            673   ;----------------------------------------------------------------------
0802            674   Read_ADC:
0802 C2EF       675       clr  ADCF
0804 D2EE       676       setb ADCS
0806 30EFFD     677       jnb  ADCF, $          ; Wait conversion
0809 E5C2       678       mov  a, ADCRL
080B 540F       679       anl  a, #0x0F
080D F8         680       mov  R0, a
080E E5C3       681       mov  a, ADCRH
0810 C4         682       swap a
0811 C0E0       683       push acc
0813 540F       684       anl  a, #0x0F
0815 F9         685       mov  R1, a
0816 D0E0       686       pop  acc
0818 54F0       687       anl  a, #0xF0
081A 48         688       orl  a, R0
081B F8         689       mov  R0, a
081C 22         690       ret
081D            691   
081D            692   ;----------------------------------------------------------------------
081D            693   ; New code for push-button-based FSM parameter updates
081D            694   ; We intercept button presses in SendSerial
081D            695   ;----------------------------------------------------------------------
081D            696   SendBCD:
081D            697   
081D E53A       698            mov a, bcd+2
081F 540F       699            anl a, #0x0F ; Isolate ones place
0821 2430       700            add a, #'0' ; Convert value to ASCII
0823 1208FF     701            lcall SendSerial
0826            702   
0826 E539       703            mov a, bcd+1
0828 54F0       704            anl a, #0xF0 ; Isolate tens place
082A C4         705            swap a ; Put high nibble into lower nibble
082B 2430       706            add a, #'0' ; Convert value to ASCII
082D 1208FF     707            lcall SendSerial
0830            708   
0830 E539       709            mov a, bcd+1
0832 540F       710            anl a, #0x0F ; Isolate ones place
0834 2430       711            add a, #'0' ; Convert value to ASCII
0836 1208FF     712            lcall SendSerial
0839            713   
0839 742E       714            mov a, #'.'
083B 1208FF     715            lcall SendSerial
083E            716   
083E E538       717            mov a, bcd+0
0840 54F0       718            anl a, #0xF0 ; Isolate 0.1 place
0842 C4         719            swap a ; Put high nibble into lower nibble
0843 2430       720            add a, #'0' ; Convert value to ASCII
0845 1208FF     721            lcall SendSerial
0848            722   
0848 E538       723            mov a, bcd+0
084A 540F       724            anl a, #0x0F ; Isolate 0.01 place
084C 2430       725            add a, #'0' ; Convert value to ASCII
084E 1208FF     726            lcall SendSerial
0851            727   
0851 7420       728       mov a, #' '
0853 1208FF     729       lcall SendSerial
0856            730   
0856 7400       731       mov a, #0
0858 A208       732       mov c, temp_state1
085A 92E0       733       mov acc.0, c
085C 2430       734       add a, #'0'
085E 1208FF     735       lcall SendSerial
0861            736       
0861 7420       737       mov a, #' '
0863 1208FF     738       lcall SendSerial
0866            739       
0866 E53F       740       mov a, state
0868 2430       741       add a, #'0'
086A 1208FF     742       lcall SendSerial
086D            743   
086D 7420       744       mov a, #' '
086F 1208FF     745       lcall SendSerial
0872            746   
0872 7464       747       mov a, #'d'
0874 1208FF     748       lcall SendSerial
0877            749   
0877 7400       750       mov a, #0
0879 A20B       751       mov c, debug_bit
087B 92E0       752       mov acc.0, c
087D 2430       753       add a, #'0'
087F 1208FF     754       lcall SendSerial
0882            755   
0882 7400       756       mov a, #0
0884 A20C       757       mov c, debug_bit1
0886 92E0       758       mov acc.0, c
0888 2430       759       add a, #'0'
088A 1208FF     760       lcall SendSerial
088D            761   
088D 7420       762       mov a, #' '
088F 1208FF     763       lcall SendSerial
0892            764       
0892 E572       765       mov a, state_sec
0894 2430       766       add a, #'0'
0896 1208FF     767       lcall SendSerial
0899            768   
0899 7420       769       mov a, #' '
089B 1208FF     770       lcall SendSerial
089E            771       
089E 742A       772       mov a, #'*'
08A0 1208FF     773       lcall SendSerial
08A3 E571       774       mov a, seconds
08A5 2430       775       add a, #'0'
08A7 1208FF     776       lcall SendSerial
08AA            777   
08AA 7420       778       mov a, #' '
08AC 1208FF     779       lcall SendSerial
08AF            780   
08AF 7400       781       mov a, #0
08B1 A201       782       mov c, m_flag
08B3 92E0       783       mov acc.0, c
08B5 2430       784       add a, #'0'
08B7 1208FF     785       lcall SendSerial
08BA            786   
08BA 7420       787       mov a, #' '
08BC 1208FF     788       lcall SendSerial
08BF 7420       789       mov a, #' '
08C1 1208FF     790       lcall SendSerial
08C4            791   
08C4 7400       792       mov a, #0
08C6 A20D       793       mov c, kill_flag
08C8 92E0       794       mov acc.0, c
08CA 2430       795       add a, #'0'
08CC 1208FF     796       lcall SendSerial
08CF            797   
08CF 7420       798       mov a, #' '
08D1 1208FF     799       lcall SendSerial
08D4            800   
08D4 7400       801       mov a, #0
08D6 A207       802       mov c, start
08D8 92E0       803       mov acc.0, c
08DA 2430       804       add a, #'0'
08DC 1208FF     805       lcall SendSerial
08DF            806       
08DF 7420       807       mov a, #' '
08E1 1208FF     808       lcall SendSerial
08E4            809       
08E4 7470       810       mov a, #'p'
08E6 1208FF     811       lcall SendSerial
08E9            812   
08E9 7400       813       mov a, #0
08EB A284       814       mov c, SSR_BOX
08ED 92E0       815       mov acc.0, c
08EF 2430       816       add a, #'0'
08F1 1208FF     817       lcall SendSerial
08F4            818   
08F4            819   
08F4            820   
08F4 740A       821            mov a, #'\n'
08F6 1208FF     822            lcall SendSerial
08F9            823   
08F9 740D       824            mov a, #'\r'
08FB 1208FF     825            lcall SendSerial
08FE            826   
08FE 22         827            ret
08FF            828   
08FF            829   SendSerial:
08FF C299       830            clr TI
0901 F599       831            mov SBUF, a
0903 3099FD     832            jnb TI, $
0906 22         833            ret
0907            834   
0907            835   button_logic:
0907 30130A     836       jnb PB0_db, start_oven
090A 301422     837       jnb PB1_db, toggle_state
090D 301531     838       jnb PB2_db, inc_value
0910 301654     839       jnb PB3_db, dec_value
0913            840       ; PB4 is unused for now, do nothing if pressed.
0913            841   
0913 22         842       ret
0914            843   
0914            844   ; Start the FSM
0914            845   start_oven:
0914 D213       846       setb PB0_db
0916 C3         847            clr c
0917 A207       848       mov c, start
0919 E4         849       clr a
091A 92E0       850       mov acc.0, c
091C F4         851       cpl a                                ; set the flag to 1, indicating that the FSM should begin
091D A2E0       852       mov c, acc.0
091F 9207       853       mov start, c
0921 E4         854       clr a
0922 C3         855       clr c
0923 A20D       856       mov c, kill_flag
0925 92E0       857       mov acc.0, c
0927 F4         858       cpl a                    ; compliment kill
0928 A2E0       859       mov c, acc.0 
092A 920D       860       mov kill_flag, c
092C            861       ;mov start, # 1                                ; return to main or update display as needed
092C 020991     862       ljmp end_button_logic           ; jump to exit logic
092F            863   
092F            864   ; Toggle which parameter is selected (1..4)
092F            865   toggle_state:
092F D205       866       setb display_flag
0931 D214       867       setb PB1_db
0933 E55F       868       mov a, selected_state           ; load the selected state to the accumulator
0935 2401       869       add a, #1                       ; icnrement the selection
0937 B40502     870       cjne a, #5, noWrap              ; if not greater than 4, jump to noWrap
093A 7401       871       mov a, #1                       ; if (selected_state == 5), reset the selected state, i.e. selected_state == 1
093C            872   noWrap:
093C F55F       873       mov selected_state, a           ; store the updated selected_state
093E 020991     874       ljmp end_button_logic           ; jump to exit logic
0941            875   
0941            876   ; Increment whichever parameter is selected
0941            877   ; ** DOUBLE CHECK THIS LOGIC IM NOT TOO SURE **
0941            878   inc_value:
0941 D205       879       setb display_flag
0943 D215       880       setb PB2_db
0945 E55F       881       mov a, selected_state           ; load the selected state into the accumulator
0947 B40105     882       cjne a, #1, checkState2         ; if selected_state != temp_soak, check the next selected state
094A 056D       883       inc temp_soak                   ; increment temp_soak if above condition not true
094C 020991     884       ljmp end_button_logic           ; jump to exit logic
094F            885   
094F            886   checkState2:                    
094F B40205     887       cjne a, #2, checkState3         ; if not time_soak, check the next parameter
0952 056E       888       inc time_soak                   ; increment time_soak
0954 020991     889       ljmp end_button_logic           ; jump to exit logic
0957            890   
0957            891   checkState3:
0957 B40305     892       cjne a, #3, checkState4         ; if not temp_refl, check next parameter
095A 056F       893       inc temp_refl                   ; increment temp_refl
095C 020991     894       ljmp end_button_logic           ; jump to exit logic
095F            895   
095F            896   checkState4:                        
095F B4042F     897       cjne a, #4, end_button_logic    ; if not time_refl, exit 
0962 0570       898       inc time_refl                   ; inc time_refl
0964 020991     899       ljmp end_button_logic           ; jump to exit logic
0967            900   
0967            901   ; Decrement whichever parameter is selected
0967            902   ; ** SAME IDEA BUT CHECK THE LOGIC PLEASE ** 
0967            903   dec_value:
0967 D205       904       setb display_flag
0969 D216       905       setb PB3_db
096B E55F       906       mov a, selected_state
096D            907       
096D B40106     908       cjne a, #1, dcheckState2
0970 D56D1E     909       djnz temp_soak, end_button_logic
0973 020991     910       ljmp end_button_logic
0976            911   
0976            912   dcheckState2:
0976 B40206     913       cjne a, #2, dcheckState3
0979 D56E15     914       djnz time_soak, end_button_logic
097C 020991     915       ljmp end_button_logic
097F            916   
097F            917   dcheckState3:
097F B40306     918       cjne a, #3, dcheckState4
0982 D56F0C     919       djnz temp_refl, end_button_logic
0985 020991     920       ljmp end_button_logic
0988            921   
0988            922   dcheckState4:
0988 B40406     923       cjne a, #4, end_button_logic
098B D57003     924       djnz time_refl, end_button_logic
098E 020991     925       ljmp end_button_logic
0991            926   
0991            927   end_button_logic:
0991 22         928       ret
0992            929   
0992            930   
0992            931   ;----------------------------------------------------------------------
0992            932   ; main
0992            933   ;----------------------------------------------------------------------
0992            934   main:
0992 75817F     935       mov sp, #0x7F
0995 1206F4     936       lcall Init_All
0998 1200DD     937       lcall LCD_4BIT
099B 1203BE     938       lcall Timer2_Init ; initialize interupts 
099E D2AF       939       setb EA
09A0            940   
09A0 C284       941       clr SSR_BOX
09A2            942   
09A2 754601     943       mov MeasurementCounter+0, #1
09A5 754700     944       mov MeasurementCounter+1, #0
09A8 754A02     945       mov TimePerSample, #2
09AB            946   
09AB 754896     947       mov SamplesPerDisplay+0, #low(SAMPLES_PER_DISPLAY)
09AE 754900     948       mov SamplesPerDisplay+1, #high(SAMPLES_PER_DISPLAY)
09B1            949   
09B1            950       ; We start with "state=0" (idle)
09B1 753F00     951       mov state, #0
09B4 C207       952       clr start ; compliment in start_oven
09B6 C201       953       clr m_flag
09B8 D20D       954       setb kill_flag
09BA            955   
09BA            956       ; Default setpoints
09BA 756D64     957       mov temp_soak, #100
09BD 756E37     958       mov time_soak, #55
09C0 756FD2     959       mov temp_refl, #210
09C3 757028     960       mov time_refl, #40
09C6            961   
09C6            962       ; Which parameter we are currently adjusting: 1=temp_soak,2=time_soak,3=temp_refl,4=time_refl
09C6 755F01     963       mov selected_state, #1
09C9            964   
09C9 754B00     965       mov LastMeasurement+0, #0
09CC 754C00     966       mov LastMeasurement+1, #0
09CF 754D00     967       mov LastMeasurement+2, #0
09D2 754E00     968       mov LastMeasurement+3, #0
09D5            969       
09D5 C208       970       clr temp_state1
09D7 C209       971       clr temp_state3
09D9 C20B       972       clr debug_bit
09DB C20C       973       clr debug_bit1
09DD C203       974       clr err_tmp
09DF C204       975       clr err_tmp_150
09E1 D205       976       setb display_flag
09E3 757100     977       mov seconds, #0
09E6 757200     978       mov state_sec, #0
09E9 756600     979       mov pwm_counter, #0
09EC 756700     980       mov pwm, #0
09EF D213       981       setb PB0_db
09F1 D214       982       setb PB1_db
09F3 D215       983       setb PB2_db
09F5 D216       984       setb PB3_db
09F7 D217       985       setb PB4_db
09F9 D218       986       setb sound_flag
09FB            987       ; Show initial LCD message
09FB            988       ;Set_Cursor(1, 1)
09FB            989       ;Send_Constant_String(#test_message)
09FB            990   
09FB            991   Forever:
09FB            992       ; Always read the push buttons each pass
09FB 120761     993            lcall LCD_PB
09FE 120907     994            lcall button_logic
0A01            995            
0A01            996   
0A01            997   SkipCheck:
0A01            998       ; Example read reference (AIN0)
0A01 53E8F0     999       anl  ADCCON0, #0xF0
0A04 43E800    1000       orl  ADCCON0, #0x00 ; Channel0
0A07 120802    1001       lcall Read_ADC
0A0A 883D      1002       mov  VAL_LM4040+0, R0
0A0C 893E      1003       mov  VAL_LM4040+1, R1
0A0E           1004   
0A0E           1005       ; Read LM335 on AIN7
0A0E 53E8F0    1006       anl  ADCCON0, #0xF0
0A11 43E807    1007       orl  ADCCON0, #0x07
0A14 120802    1008       lcall Read_ADC
0A17           1009   
0A17           1010       ; Convert to "voltage" in x
0A17 8830      1011       mov  x+0, R0
0A19 8931      1012       mov  x+1, R1
0A1B 753200    1013       mov  x+2, #0
0A1E 753300    1014       mov  x+3, #0
0A21 7534FF    1015            mov y+0, #low (40959 % 0x10000) 
0A24 75359F    1015            mov y+1, #high(40959 % 0x10000) 
0A27 753600    1015            mov y+2, #low (40959 / 0x10000) 
0A2A 753700    1015            mov y+3, #high(40959 / 0x10000)        ; e.g. 4.0959 => times 10000 in math
0A2D 1202B2    1016       lcall mul32
0A30 853D34    1017       mov  y+0, VAL_LM4040+0
0A33 853E35    1018       mov  y+1, VAL_LM4040+1
0A36 753600    1019       mov  y+2, #0
0A39 753700    1020       mov  y+3, #0
0A3C 12033F    1021       lcall div32
0A3F           1022   
0A3F           1023       ; Add partial result to StoreMeasurements
0A3F 854034    1024       mov  y+0, StoreMeasurements+0
0A42 854135    1025       mov  y+1, StoreMeasurements+1
0A45 854236    1026       mov  y+2, StoreMeasurements+2
0A48 854337    1027       mov  y+3, StoreMeasurements+3
0A4B 1201FD    1028       lcall add32
0A4E 853040    1029       mov  StoreMeasurements+0, x+0
0A51 853141    1030       mov  StoreMeasurements+1, x+1
0A54 853242    1031       mov  StoreMeasurements+2, x+2
0A57 853343    1032       mov  StoreMeasurements+3, x+3
0A5A           1033   
0A5A           1034       ; Read thermocouple on AIN4
0A5A 53E8F0    1035       anl  ADCCON0, #0xF0
0A5D 43E804    1036       orl  ADCCON0, #0x04
0A60 120802    1037       lcall Read_ADC
0A63           1038   
0A63 8830      1039       mov  x+0, R0
0A65 8931      1040       mov  x+1, R1
0A67 753200    1041       mov  x+2, #0
0A6A 753300    1042       mov  x+3, #0
0A6D 7534FF    1043            mov y+0, #low (40959 % 0x10000) 
0A70 75359F    1043            mov y+1, #high(40959 % 0x10000) 
0A73 753600    1043            mov y+2, #low (40959 / 0x10000) 
0A76 753700    1043            mov y+3, #high(40959 / 0x10000) 
0A79 1202B2    1044       lcall mul32
0A7C 853D34    1045       mov  y+0, VAL_LM4040+0
0A7F 853E35    1046       mov  y+1, VAL_LM4040+1
0A82 753600    1047       mov  y+2, #0
0A85 753700    1048       mov  y+3, #0
0A88 12033F    1049       lcall div32
0A8B           1050   
0A8B           1051       ; Add partial result to StoreThermocouple
0A8B 854F34    1052       mov  y+0, StoreThermocouple+0
0A8E 855035    1053       mov  y+1, StoreThermocouple+1
0A91 855136    1054       mov  y+2, StoreThermocouple+2
0A94 855237    1055       mov  y+3, StoreThermocouple+3
0A97 1201FD    1056       lcall add32
0A9A 85304F    1057       mov  StoreThermocouple+0, x+0
0A9D 853150    1058       mov  StoreThermocouple+1, x+1
0AA0 853251    1059       mov  StoreThermocouple+2, x+2
0AA3 853352    1060       mov  StoreThermocouple+3, x+3
0AA6           1061   
0AA6           1062       ; Delay between samples
0AA6 AA4A      1063       mov R2, TimePerSample
0AA8 12075B    1064       lcall waitms
0AAB           1065   
0AAB           1066       ; Decrement measurement counter
0AAB 1546      1067       dec MeasurementCounter+0
0AAD E546      1068       mov a, MeasurementCounter+0
0AAF B4FF02    1069       cjne a, #0xFF, CheckHigh
0AB2 1547      1070       dec MeasurementCounter+1
0AB4           1071   CheckHigh:
0AB4 E546      1072       mov a, MeasurementCounter+0
0AB6 4547      1073       orl a, MeasurementCounter+1
0AB8 6003      1074       jz  DisplayValue
0ABA 020C21    1075       ljmp EndForever
0ABD           1076   
0ABD           1077   ;----------------------------------------------------------------------
0ABD           1078   ; If enough measurements collected -> compute final temperature
0ABD           1079   ;----------------------------------------------------------------------
0ABD           1080   DisplayValue:
0ABD 753400    1081            mov y+0, #low (0 % 0x10000) 
0AC0 753500    1081            mov y+1, #high(0 % 0x10000) 
0AC3 753600    1081            mov y+2, #low (0 / 0x10000) 
0AC6 753700    1081            mov y+3, #high(0 / 0x10000) 
0AC9           1082       ; Combine for LM335 reading
0AC9 854030    1083       mov x+0, StoreMeasurements+0
0ACC 854131    1084       mov x+1, StoreMeasurements+1
0ACF 854232    1085       mov x+2, StoreMeasurements+2
0AD2 854333    1086       mov x+3, StoreMeasurements+3
0AD5 E548      1087       mov a, SamplesPerDisplay+0
0AD7 F534      1088       mov y+0, a
0AD9 F546      1089       mov MeasurementCounter+0, a
0ADB E549      1090       mov a, SamplesPerDisplay+1
0ADD F535      1091       mov y+1, a
0ADF F547      1092       mov MeasurementCounter+1, a
0AE1 12033F    1093       lcall div32
0AE4           1094   
0AE4           1095       ; Subtract 273.00 => Celsius reading
0AE4 7534A4    1096            mov y+0, #low (27300 % 0x10000) 
0AE7 75356A    1096            mov y+1, #high(27300 % 0x10000) 
0AEA 753600    1096            mov y+2, #low (27300 / 0x10000) 
0AED 753700    1096            mov y+3, #high(27300 / 0x10000) 
0AF0 12021E    1097       lcall sub32
0AF3 853057    1098       mov FinalLM335+0, x+0
0AF6 853158    1099       mov FinalLM335+1, x+1
0AF9 853259    1100       mov FinalLM335+2, x+2
0AFC 85335A    1101       mov FinalLM335+3, x+3
0AFF           1102   
0AFF           1103       ; Combine for thermocouple reading
0AFF 753400    1104            mov y+0, #low (0 % 0x10000) 
0B02 753500    1104            mov y+1, #high(0 % 0x10000) 
0B05 753600    1104            mov y+2, #low (0 / 0x10000) 
0B08 753700    1104            mov y+3, #high(0 / 0x10000) 
0B0B 854F30    1105       mov x+0, StoreThermocouple+0
0B0E 855031    1106       mov x+1, StoreThermocouple+1
0B11 855132    1107       mov x+2, StoreThermocouple+2
0B14 855233    1108       mov x+3, StoreThermocouple+3
0B17 E548      1109       mov a, SamplesPerDisplay+0
0B19 F534      1110       mov y+0, a
0B1B E549      1111       mov a, SamplesPerDisplay+1
0B1D F535      1112       mov y+1, a
0B1F 12033F    1113       lcall div32
0B22           1114   
0B22           1115       ; Add thermocouple to LM335 reading => final in x
0B22 753400    1116            mov y+0, #low (0 % 0x10000) 
0B25 753500    1116            mov y+1, #high(0 % 0x10000) 
0B28 753600    1116            mov y+2, #low (0 / 0x10000) 
0B2B 753700    1116            mov y+3, #high(0 / 0x10000) 
0B2E 855734    1117       mov y+0, FinalLM335+0
0B31 855835    1118       mov y+1, FinalLM335+1
0B34 855936    1119       mov y+2, FinalLM335+2
0B37 855A37    1120       mov y+3, FinalLM335+3
0B3A 1201FD    1121       lcall add32
0B3D           1122   
0B3D 85305B    1123       mov FinalTemp+0, x+0
0B40 85315C    1124       mov FinalTemp+1, x+1
0B43 85325D    1125       mov FinalTemp+2, x+2
0B46 85335E    1126       mov FinalTemp+3, x+3
0B49           1127   
0B49           1128       ; --------------------------------------------------------
0B49           1129       ; Compare final temperature with soak/reflow setpoints
0B49           1130       ; --------------------------------------------------------
0B49 C200      1131       clr mf
0B4B 753464    1132            mov y+0, #low (100 % 0x10000) 
0B4E 753500    1132            mov y+1, #high(100 % 0x10000) 
0B51 753600    1132            mov y+2, #low (100 / 0x10000) 
0B54 753700    1132            mov y+3, #high(100 / 0x10000) 
0B57 856D30    1133       mov x+0, temp_soak
0B5A 753100    1134       mov x+1, #0
0B5D 753200    1135       mov x+2, #0
0B60 753300    1136       mov x+3, #0
0B63 1202B2    1137       lcall mul32
0B66 855B34    1138       mov y+0, FinalTemp+0
0B69 855C35    1139       mov y+1, FinalTemp+1
0B6C 855D36    1140       mov y+2, FinalTemp+2
0B6F 855E37    1141       mov y+3, FinalTemp+3
0B72 1202A8    1142       lcall x_lteq_y ; mf = 1 if temp_soak<=FinalTemp
0B75 A200      1143       mov c, mf
0B77 9208      1144       mov temp_state1, c
0B79           1145   
0B79 C200      1146       clr mf
0B7B 753464    1147            mov y+0, #low (100 % 0x10000) 
0B7E 753500    1147            mov y+1, #high(100 % 0x10000) 
0B81 753600    1147            mov y+2, #low (100 / 0x10000) 
0B84 753700    1147            mov y+3, #high(100 / 0x10000) 
0B87 856F30    1148       mov x+0, temp_refl
0B8A 753100    1149       mov x+1, #0
0B8D 753200    1150       mov x+2, #0
0B90 753300    1151       mov x+3, #0
0B93 1202B2    1152       lcall mul32
0B96 855B34    1153       mov y+0, FinalTemp+0
0B99 855C35    1154       mov y+1, FinalTemp+1
0B9C 855D36    1155       mov y+2, FinalTemp+2
0B9F 855E37    1156       mov y+3, FinalTemp+3
0BA2 1202A8    1157       lcall x_lteq_y ; mf = 1 if temp_refl<=FinalTemp
0BA5 A200      1158       mov c, mf
0BA7 9209      1159       mov temp_state3, c
0BA9           1160   
0BA9           1161       ; Check error states
0BA9 855B30    1162       mov x+0, FinalTemp+0
0BAC 855C31    1163       mov x+1, FinalTemp+1
0BAF 855D32    1164       mov x+2, FinalTemp+2
0BB2 855E33    1165       mov x+3, FinalTemp+3
0BB5           1166   
0BB5 C200      1167       clr mf
0BB7 7534A8    1168            mov y+0, #low (25000 % 0x10000) 
0BBA 753561    1168            mov y+1, #high(25000 % 0x10000) 
0BBD 753600    1168            mov y+2, #low (25000 / 0x10000) 
0BC0 753700    1168            mov y+3, #high(25000 / 0x10000) 
0BC3 12029E    1169       lcall x_gteq_y ; mf = 1 if FinalTemp<=250
0BC6 A200      1170       mov c, mf
0BC8 9204      1171       mov err_tmp_150, c
0BCA           1172   
0BCA C200      1173       clr mf
0BCC 753488    1174            mov y+0, #low (5000 % 0x10000) 
0BCF 753513    1174            mov y+1, #high(5000 % 0x10000) 
0BD2 753600    1174            mov y+2, #low (5000 / 0x10000) 
0BD5 753700    1174            mov y+3, #high(5000 / 0x10000) 
0BD8 12029E    1175       lcall x_gteq_y ; mf = 1 if FinalTemp>=50
0BDB A200      1176       mov c, mf
0BDD 9203      1177       mov err_tmp, c
0BDF           1178   
0BDF C200      1179       clr mf
0BE1 7534B8    1180            mov y+0, #low (3000 % 0x10000) 
0BE4 75350B    1180            mov y+1, #high(3000 % 0x10000) 
0BE7 753600    1180            mov y+2, #low (3000 / 0x10000) 
0BEA 753700    1180            mov y+3, #high(3000 / 0x10000) 
0BED 1202A8    1181       lcall x_lteq_y ; mf = 1 if FinalTemp<=60
0BF0 A200      1182       mov c, mf
0BF2 920A      1183       mov temp_state5, c
0BF4           1184   
0BF4           1185   
0BF4           1186   
0BF4           1187       ; Convert FinalTemp => BCD => display
0BF4 120138    1188       lcall hex2bcd
0BF7 12081D    1189       lcall SendBCD
0BFA           1190       
0BFA           1191      ; jnb display_temp EndForever
0BFA 1207AE    1192       lcall Display_formated_BCD
0BFD           1193   
0BFD 754000    1194       mov StoreMeasurements+0, #0
0C00 754100    1195       mov StoreMeasurements+1, #0
0C03 754200    1196       mov StoreMeasurements+2, #0
0C06 754300    1197       mov StoreMeasurements+3, #0
0C09           1198   
0C09 754F00    1199       mov StoreThermocouple+0, #0
0C0C 755000    1200       mov StoreThermocouple+1, #0
0C0F 755100    1201       mov StoreThermocouple+2, #0
0C12 755200    1202       mov StoreThermocouple+3, #0
0C15           1203   
0C15 755700    1204       mov FinalLM335+0, #0
0C18 755801    1205       mov FinalLM335+1, #1
0C1B 755902    1206       mov FinalLM335+2, #2
0C1E 755A03    1207       mov FinalLM335+3, #3
0C21           1208   
0C21           1209   EndForever:
0C21           1210       ; Always read the push buttons each pass
0C21           1211       ;lcall LCD_PB
0C21           1212       ; Reset accumulators
0C21           1213   
0C21 753000    1214       mov x+0, #0
0C24 753100    1215       mov x+1, #0
0C27 753200    1216       mov x+2, #0
0C2A 753300    1217       mov x+3, #0
0C2D 0209FB    1218       ljmp Forever
0C30           1219   
0C30           1220   END
